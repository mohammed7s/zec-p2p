{
  "file_map": {
    "102": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "135": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "14": {
      "path": "std/ecdsa_secp256k1.nr",
      "source": "// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n"
    },
    "154": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "155": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "156": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "157": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "158": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "167": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "172": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "174": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "208": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "211": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "212": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "214": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "215": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "218": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "229": {
      "path": "/home/ubuntu/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "317": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "330": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "331": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "333": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "361": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "364": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "382": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "386": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "436": {
      "path": "/home/ubuntu/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "437": {
      "path": "/home/ubuntu/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr",
      "source": "mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n"
    },
    "438": {
      "path": "/home/ubuntu/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr",
      "source": "pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/ubuntu/Dropbox/WEB/attested-frontiers/aztec-zktls/aztec-demo/att_verifier/src/main.nr",
      "source": "mod aes;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AttVerifier {\n\n    use aztec::{\n        event::event_emission::emit_event_in_public,\n        macros::{events::event, functions::{external, internal, initializer}},\n        protocol_types::{address::AztecAddress, hash::poseidon2_hash},\n    };\n    use business_program::BusinessProgram;\n    use sha256::sha256_var;\n    use string_search::{StringBody, StringBody1024, SubString, SubString1024};\n\n    global MAX_URL_LEN: u32 = 200;\n    global MAX_CONTENT_LEN: u32 = 1000;\n\n    //Emitted public log limit: 13 fields\n    #[event]\n    struct SuccessEvent {\n        sender: AztecAddress,\n        att_verifier_address: AztecAddress,\n        business_logic_address: AztecAddress,\n        id: Field,\n    }\n\n    // Opcode count: 71055, Total gates by opcodes: 546716, Circuit size: 550.167\n    #[external(\"private\")]\n    fn verify_attestation(\n        public_key_x: [u8; 32],\n        public_key_y: [u8; 32],\n        hash: [u8; 32],\n        signature: [u8; 64],\n        request_urls: [BoundedVec<u8, MAX_URL_LEN>; 1],\n        allowed_urls: [BoundedVec<u8, MAX_URL_LEN>; 1],\n        data_hashes: [[u8; 32]; 1],\n        plain_json_response_contents: [BoundedVec<u8, MAX_CONTENT_LEN>; 1],\n        business_logic_address: AztecAddress,\n        id: Field, // id for this attestation\n    ) -> bool {\n        // 1. Check signature\n        assert(std::ecdsa_secp256k1::verify_signature(public_key_x, public_key_y, signature, hash));\n\n        // 2. Check that the request_url starts with one of the allowed_urls\n        let mut allowed_url_matches: [Field; 1] = [0; 1];\n        for i in 0..1 {\n            // Safety: Get the index of the url in allowed_urls that matches request_url (unconstrained) and then check it\n            let (found, url_index) =\n                unsafe { get_allowed_url_index(request_urls[i], allowed_urls) };\n            assert(found == true, \"No allowed URL matches the request URL\");\n            let request_url_haystack: StringBody1024 =\n                StringBody::new(request_urls[i].storage(), request_urls[i].len());\n            let allowed_url = allowed_urls[url_index];\n            let needle: SubString1024 = SubString::new(allowed_url.storage(), allowed_url.len());\n\n            let (result, match_position): (bool, u32) =\n                request_url_haystack.substring_match(needle);\n\n            // A match result is only valid if the match position is 0 (i.e., the allowed_url is a prefix of request_url)\n            assert(result & (match_position == 0), \"URL check failed\");\n            let mut hash_input: [Field; 1024] = [0; 1024];\n            for j in 0..1024 {\n                if j < allowed_url.len() {\n                    hash_input[j] = allowed_url.storage()[j] as Field;\n                }\n            }\n            // TODO can we hash without the padding of zeroes?\n            allowed_url_matches[i] = poseidon2_hash::<1024>(hash_input);\n        }\n\n        // 3. Hash plain_json_responses and check with input hashes\n        for i in 0..1 {\n            let hash = sha256_var(\n                plain_json_response_contents[i].storage(),\n                plain_json_response_contents[i].len() as u64,\n            );\n            assert(hash == data_hashes[i]);\n        }\n\n        let result = BusinessProgram::at(business_logic_address)\n            .verify(plain_json_response_contents, allowed_url_matches)\n            .call(&mut context);\n\n        if result {\n            AttVerifier::at(context.this_address())\n                ._emit_success_event(\n                    context.msg_sender().unwrap(),\n                    context.this_address(),\n                    business_logic_address,\n                    id,\n                )\n                .enqueue(&mut context);\n        }\n\n        result\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _emit_success_event(\n        sender: AztecAddress,\n        att_verifier_address: AztecAddress,\n        business_logic_address: AztecAddress,\n        id: Field,\n    ) {\n        emit_event_in_public(\n            SuccessEvent { sender, att_verifier_address, business_logic_address, id },\n            &mut context,\n        );\n    }\n\n    #[contract_library_method]\n    unconstrained fn get_allowed_url_index(\n        request_url: BoundedVec<u8, MAX_URL_LEN>,\n        allowed_urls: [BoundedVec<u8, MAX_URL_LEN>; 1], // TODO this probably shouldn't have a fixed len\n    ) -> (bool, u32) {\n        let mut found = false;\n        let mut index: u32 = 3050913689; // max u32 value to indicate \"not found\"\n        for i in 0..allowed_urls.len() {\n            let allowed_url = allowed_urls[i];\n            if (allowed_url.len() <= request_url.len()) {\n                let (result, match_position) = search(request_url, allowed_url);\n                // If a valid result was already found we don't have to store again\n                // (A valid result being that the match position is 0)\n                if result & (match_position == 0) & !found {\n                    found = true;\n                    index = i;\n                }\n            }\n        }\n        (found, index)\n    }\n\n    // Adapted version of library function, which doesn't assert found to be true\n    // https://github.com/noir-lang/noir_string_search/blob/v0.3.3/src/utils.nr#L1-L29\n    #[contract_library_method]\n    unconstrained fn search(\n        haystack: BoundedVec<u8, MAX_URL_LEN>,\n        needle: BoundedVec<u8, MAX_URL_LEN>,\n    ) -> (bool, u32) {\n        let haystack_length: u32 = haystack.len();\n        let needle_length: u32 = needle.len();\n        assert(needle_length > 0, \"needle length of size 0 not supported\");\n        assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n        let mut found = false;\n        let mut found_index: u32 = 0;\n        for i in 0..haystack_length - needle_length + 1 {\n            if (found == true) {\n                break;\n            }\n            for j in 0..needle_length {\n                if haystack.get(i + j) != needle.get(j) {\n                    break;\n                } else if (j == needle_length - 1) {\n                    found = true;\n                }\n                if (found == true) {\n                    found_index = i;\n                    break;\n                }\n            }\n        }\n\n        (found, found_index)\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "61": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "68": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "69": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "70": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "71": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "72": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_emission.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext},\n    event::event_interface::EventInterface,\n    messages::{\n        logs::{event::to_encrypted_private_event_message, utils::prefix_with_tag},\n        message_delivery::MessageDelivery,\n        offchain_messages::emit_offchain_message,\n    },\n    utils::remove_constraints::remove_constraints_if,\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n};\n\n/// Emits an event that can be delivered either via private logs or offchain messages, with configurable encryption and\n/// tagging constraints.\n///\n/// # Arguments\n/// * `event` - The event to emit\n/// * `context` - The private context to emit the event in\n/// * `recipient` - The address that should receive this event\n/// * `delivery_mode` - Controls encryption, tagging, and delivery constraints. Must be a compile-time constant.\n///   See `MessageDeliveryEnum` for details on the available modes.\npub fn emit_event_in_private<Event>(\n    event: Event,\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    delivery_mode: u8,\n)\nwhere\n    Event: EventInterface + Serialize,\n{\n    // This function relies on `delivery_mode` being a constant in order to reduce circuit constraints when unconstrained\n    // usage is requested. If `delivery_mode` were a runtime value then performance would suffer.\n    assert_constant(delivery_mode);\n\n    // The following maps out the 3 dimensions across which we configure message delivery.\n    let constrained_encryption = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n    let emit_as_offchain_message = delivery_mode == MessageDelivery.UNCONSTRAINED_OFFCHAIN;\n    // TODO(#14565): Add constrained tagging\n    let _constrained_tagging = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n\n    let (ciphertext, randomness) = remove_constraints_if(\n        !constrained_encryption,\n        || to_encrypted_private_event_message(event, recipient),\n    );\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during offchain delivery.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = [randomness].concat(event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    if emit_as_offchain_message {\n        emit_offchain_message(ciphertext, recipient);\n    } else {\n        // Safety: Currently unsafe. See description of CONSTRAINED_ONCHAIN in MessageDeliveryEnum.\n        // TODO(#14565): Implement proper constrained tag prefixing to make this truly CONSTRAINED_ONCHAIN\n        let log_content = prefix_with_tag(ciphertext, recipient);\n\n        context.emit_private_log(log_content, log_content.len());\n    }\n}\n\npub fn emit_event_in_public<Event>(event: Event, context: &mut PublicContext)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n"
    },
    "74": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "97": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "11591029387631908977": {
            "error_kind": "string",
            "string": "Function _emit_success_event can only be called internally"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "att_verifier_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "business_logic_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABEgnAgUEBCcCBgQAHwoABQAGAEQtCEQBLQhFAi0IRgMtCEcEJQAAAE0lAAAAcycCAQRIJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAAJFHgIABgEKIgZDBxYKBwgcCggJAAQqCQYIJwIGAQAKKgcGCSQCAAkAAACrJwIKBAA8BgoBHgIABgAKKggGByQCAAcAAADCJQAAAmspAgAGALd8YNktCAEHJwIIBAYACAEIAScDBwQBACIHAggtCggJLQ4BCQAiCQIJLQ4CCQAiCQIJLQ4DCQAiCQIJLQ4ECQAiCQIJLQ4GCScCAQAALQgBAicCAwQGAAgBAwEnAwIEAQAiAgIDLQoDBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQtCAEBAAABAgEtDgIBJwICBAAnAgMEBScCBAQBLQoCBSMAAAF9DCoFAwIkAgACAAACASMAAAGPLQsBAicCBQQFBiIFAgEnAgcEAwAqBQcGLQgBBAAIAQYBJwMEBAEAIgQCBi0OBQYAIgYCBi0OBQYnAgcEAwAqBAcGACICAgctAgcDLQIGBC0CBQUlAAACfQAiBAIGLQsGBScCBwQCACoGBwI3DgAFAAImACIHAgYAKgYFCC0LCAItCwEGLQIGAycABAQGJQAAAq8tCAUIACIIAgkAKgkFCi0OAgotDggBACoFBAItCgIFIwAAAX0oAAAEBHhIDAAABAMkAAADAAACaioBAAEF2sX11rRKMm08BAIBJioBAAEFoNub0O7p2HE8BAIBJgAAAwUHLQADCC0ABAkKAAgHCiQAAAoAAAKuLQEIBi0EBgkAAAgCCAAACQIJIwAAAoomLQEDBgoABgIHJAAABwAAAsUjAAACzi0AAwUjAAADEi0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAMILQEKCC0ECAsAAAoCCgAACwILIwAAAuQnAQUEAQIABgIGJg==",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "nZbRjuIwDEX/pc99iBM7cfiV0WjUgTKqVBXUgZVWiH9fJ8QFVkqFeMEnDr11bpwql2bXf59/voZpf/htNh+X5nsexnH4+RoP2+40HCbJXhqTfsBKcK1EajYk0ZkS8ZZ38RZRxiHFeItUxt6WGG4xQLMBk8ALgACDQiwQ5VkQUWucQigAVkEzVjNWMw4UqAAaBVVOZWYgfQVxAa+CXgVzzT6BL8BGgQpEzcSSccYooAIXAKcQCuRVZCivcA4UVBBVEFUQVZBUMJspPruYFshtg9nDmIALgGZAM1Yz2cMEzipoBjWDvgCBAhXwRkEzQTMBFfSlrIIsr7Cy7xitgr8BGVDQTCre2gRcwGomFW9lvyhbxwmoQLYuw5Ip/lBq1BtoxjuFtHa+XttGD8bXae77dC4eToqcn2M399Op2UzncWybP914zn/6PXZTjqdullnp+n7aSRTB/TD2ia7t/WlTf5RDdOVpZoBFAIx/koC6BESbGiNrCFtaRHx80rB1DelO64uGMEJNY70ONPc6oq1p4EodSEUBwfpFgN6y05qqnb4uEbwqhHCvAO3LJfDiJDP6agm84iSbAOokGzY1J+PajkrfLztKodoVr7qJXF3KigSadODKjvp7SxA8t9Vab/qoZrjw0BTBvi4RglskYl1ipTNRPpi6EPTV3gZakQhh6W5xdpFwHl/XYFg0GPx7GtGpG/JB5rrGq3aE+udiVcLCXQKrX62V7nJOTphurOMQ3toWJrNYSuFNS5cDi5H/25ZPGXbbYX66hV2T2Dx032NfhvvztH2YPf096oze4o7zYdvvznOflO5XOfn5AEctEH3KBSGNLLZykZMR5EkpXe57aQh5FmToPq+ptH8=",
      "is_unconstrained": true,
      "name": "_emit_success_event"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "tL3PsiU7b+X3Lt+4B0mAf/UqHnTItuxQhELt6FZ7ouh3906AwFpV14cna+9zNVD9cL8qLCZJYGeSSOZ//uP//Jf//X/+3//1X//9//pv/+Mf//S//ec//vf//q//9m//+n//13/7b//HP//Hv/63f3/91//8x3X/v9H/8U/6X/4xxj/+qb/+mP/4p/r6Y9kf8/I/yj/+ab7+EP9D/Y/qfzT/o/sfw/+Y/seyP9blf7iX5V6We1nuZbmX5V6We1nuZbmXcl37z7L/lP2n7j/r/rPtP/v+c+w/5/5z+yvbX9n+yvZXtr+y/ZXtr2x/Zfsr21/Z/mT7k+1Ptj/Z/mT7k+1Ptj/Z/mT7k+1Ptz/d/nT70+1Ptz/d/nT70+1Ptz/d/ur2V7e/uv3V7a9uf3X7q9tf3f7q9le3v7b9te2vbX9t+2vbX9v+2vbXtr/28leuG9aGfgWUgJfPojdoQA1oAS+/pd/wciz2r2bA2jCugBIgAS/PUm+oAS2gB9ye2w0zYG24Q6Tcl3MHiYMEvDxruaEGtIAeMAJmwNpwh41DCZCA8LzC8wrPKzzfQaR3/9xh5LAc5I4khxIgARpQA1pADxgBMyA8l/BcwnMJzyU8l/BcwnMJzyU8l/BcwrOEZwnPEp7vANN2Qw1oAT1gBMyAteGOM4cSIAHhWcOzhmcNzxqeNTxreK7huYbnGp5reK7huYbnGp5reK7huYbnFp5beG7huYXnFp5beG7huYXnFp5beO7huYfnHp57eO7huYfnHp57eO7huYfnEZ5HeB7heYTnEZ5HeB7heYTnEZ5HeJ7heYbnGZ5neJ7heYbnGZ5neJ7h2WLwFcJiMWhQAiRAA2pAC+gBI2AGbM96XQEl4OW5lhs0oAa8PNd+Qw8YATNgbbhj0KEESIAG1IDwXMJzCc9lZyQtOyOpXAElQAI0oAa0gB4wAsKzhGcNz3cM1nWDBGhADWgBPWAEzIC14Y5Bh/Bcw3MNzzU83zHYrht6wAiYAWvDHYMOJUACNKAGhOcWnlt4vmOwjRvWhjsGHUqABGhADWgBPWAEhOcenkd4HuF5hOcRnkd4HuF5hOcRnkd4HuF5hucZnmd4nuF5hucZnmd4nuF5hucZnld4XuF5hecVnld4XuF5hecVnld4Xttzva6AEiABGlADWkAPGAEzIDyX8FzCcwnPJTyX8FzCcwnPJTyX8FzCs4RnCc8SniU8S3iW8CzhWcKzhGcJzxqeNTxreNbwrOFZw7OGZw3PGp41PNfwXMNzDc81PNfwXMNzDc81PNfwXMNzC88tPLfw3MJzC88tPLfw3MJzxGCNGKwRgzVisEYM1ojBGjFYIwZrxGCNGKwRgzVisEYM1ojBGjFYIwZrxGCNGKwRgzVisEYM1ojBGjFYIwZrxGCNGKwRgzVisEYM1ojBGjFYIwZrxGCNGKwRgzVisEYM1ojBGjFYIwZrxGCNGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBFjHYIgZbxGCLGGwRgy1isEUMtojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGOwRgz1isEcM9ojBHjHYIwZ7xGCPGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBETE4IgZHxOCIGBwRgyNicEQMjojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE4IwZnxOCMGJwRgzNicEYMzojBGTE47xjs1w01oAW8PPd7b8427gxmwNpwx6BDCZAADagBLSA8z/A8w/MMzys8r/C8wvMKzys8r/C8wvMKzys8r+15XVdACZAADagBLaAHjIAZEJ5LeC7huYTnEp5LeC7huYTnEp5LeC7hWcKzhGcJzxKeJTxLeJbwLOFZwrOEZw3PGp41PGt41vCs4VnDs4ZnDc8anmt4ruG5hucanmt4ruG5hucanmt4ruG5hecWnlt4buG5hecWnlt4buG5hecWnnt47uG5h+cennt47uG5h+cennt47uF5hOcRnkd4HuF5hOcRniMGV8TgihhcEYMrYnBFDK6IwRUxuCIGV8TgihhcEYMrYnBFDK6IwRUxuCIGV8TgihhcEYMrYnBFDK6IwRUx+Nppv5JKkiRpUk1qST1pJM2k1CipUVKjpEZJjZIaJTVKapTUKKlRUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1OjpkZNjZoaNTVqatTUqKlRU6OmRk2NlhotNVpqtNRoqdFSo6VGS42WGi01emr01Oip0VOjp0ZPjZ4aPTV6avTUGKkxUmOkxkiNkRojNUZqjNQYqTFSY6bGTI2ZGjM1ZmrM1JipMVNjpsZMjZUaKzVWaqzUWKmxUmOlxkqNlRoZ5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxLhnnknEuGeeScS4Z55JxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z55pxrhnnmnGuGeeaca4Z51at1L3a+koqSS+NcRlpUk1qST1pJM2ktckKlzaVJEnSpJrUknrSSJpJqVFSo6RGSY2SGiU1SmqU1CipUVKjpIakhqSGpIakhqSGpIakhqSGpIakhqaGpoamhqaGpoamhqaGpoamhqZGTY2aGjU1amrU1KipUVOjpkZNjZoaLTVaarTUaKnRUqOlRkuNlhotNVpq9NToqdFTo6dGT42eGj01emr01OipMVJjpMZIjZEaIzVGaozUGKkxUmOkxkyNmRozNWZqzNSYqTFTY6bGTI2ZGis1VmpknNeM85pxXjPOa8a5VUYNMZpJa5MVR20qSZKkSTWpJfWkkTSTUqOkRkmNkholNUpqlNQoqVFSo6RGSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1JDU0NTQ1NDU0NTQ1NDU0NTQ1NDU2Nmho1NWpq1NSoqVFTo6ZGTY2aGjU1Wmq01Gip0VKjpUZLjZYaLTVaarTU6KnRU6OnRk+Nnho9NXpq9NToqdFTY6TGSI2RGiM1RmqM1BipMVJjpMZIjZkaMzVmaszUmKkxU2OmxkyNmRozNVZqrNRYqbFSY6XGSo2VGhnnLeO8ZZz3jPOecd4zznvGec847xnnPeO8Z5z3jPOecd4zznvGec847xnnPeO8Z5z3jPOecd4zznvGec847xnnPeO8Z5z3jHOrzBrNqCeNpJm0gizOnUqSJGlSTUoNTQ1NDU0NTY2aGjU1amrU1KipUVOjpkZNjZoaNTXs9bliVJIkSZNqUkvqSSNpJq2gnhp3nE/r8TvON2lSTWpJPWkkzaQVdMf5ptQYqTFSY6TGHeezGvWkkTSTVtAd55tKkiRpUk1KjZkaMzVmaszUWKmxUmOlxkqNlRorNVZqrNRYqbFCw4q8NpUkSdKkmtSSetJImkmpYa+12iuK9mKrkyTdGt2oJrWkW2MajaSZ9NJY92yywq9NJemlsYaRJtWkl8YyL3ecbxpJ837f01/LXIl3pAcWoAAVWIEN2IEDCDWFWoVaNTW7qipABZqadXdtwA4cwAlcie0CFqAAFQi1BrUGtWZqNr7+Uq3jSvQXax0LUIAKrMAG7ECodah1qA2oDagNqA2oDagNqA2oDagNqA2oTahNqE2oTahNqE2oTahNqE2oTagtqC2oLagtqC2oLagtqC2oLaitVLOCtMACFKACK7ABO3AAJxBqBWoFagVqBWoFagVqBWoFagVqBWoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hVqFWoVahVqFWoVahVqFWoVahVqHWoNag1qDWoNag1qDmucTeWfdc4jiBK9FziWMBClCBFdiAUOtQ61DrUBtQG1AbUBtQG1AbUBtQG1AbUBtQm1CbUJtQm1CbUJtQm1CbUJtQm1BbUFtQW1BbUFtQW1BbUFtQW1BbqbauC1iAAlRgBTZgBw7gBEKtQK1ArUCtQK1ArUCtQK1ArUCtQE2gJlATqAnUBGoCNYGaQE2gJlBTqCnUFGoKNYWaQk2hplBTqCnUKtQq1CrUKtQq1CrUKtQq1CrUKtQa1BrUGtQa1BrUGtSQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWZlL5MpcIlfmErkyl8iVuUSuzCVyZS6RK3OJXJlL5MpcItcFtQK1ArUCtQK1ArUCtQK1ArUCtQI1gZpATaBmuaQUwwpswA4cwAlciZZLNhagAKGmUFOoWS4pYjiAE7gSLZdsLEABKrACGxBqFWoVahVqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWodagNqA2oDagNqA2oDagNqA2oDagNqE2oTahNqE2oTahNqE2oTahNqE2oLagtqC2oLagtqlktKNezAATS1YbgCrQYxsAAFqMAKbMAOHMAJhFqBWoFagVqBWoFagVqBWoFagVqBmkBNoCZQE6gJ1ARqAjWBmkBNoKZQU6gp1BRqCjWFmkJNoaZQU6hVqFWoVahVqFWoVahVqFWoVahVqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWodagNqA2oDagNqA2oDagNqA2oDagNqE2oTahNqE2oTahNqE2oTahNqE2oLagtqC2oLagtqC2oLagtqCGXFOQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS6xUsxyH2sqVosZ2IAdOIATuBItl2wsQAFCbUBtQM1yiRTDAZzAlWi5ZGMBClCBFdiAUJtQm1CbUFtQW1BbUFtQW1BbUFtQW1BbUFupZvWagQUoQAVWYAN24ABOINQK1ArUCtQK1ArUCtQK1ArUCtQK1ARqAjWBmkBNoCZQE6gJ1ARqAjWFmkJNoaZQU6gp1BRqCjWFmkKtQq1CrUKtQq1CrUKtQq1CrUKtQq1BzXKJqKEAFWhq3bABO3AAJ3AlWi7ZWIACVCDUOtQ61DrUOtQ61AbUBtQG1AbUBtQG1AbUBtQG1AbUJtQm1CbUJtQm1CbUJtQm1CbUJtQW1BbUFtQW1BbUFtQW1BbUFtRWqrXrAhagABVYgQ3YgQM4gVArUCtQK1ArUCtQK1ArUCtQK1ArUBOoCdQEagI1gZpATaAmUBOoCdQUago1hZpCTaGmUFOoKdQUagq1CrUKtQq1CrUKtQq1CrUKtQq1CrUGtQa1BrUGNeSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pCOXdOSSjlwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOQSr3uVZTiBK9FziWMBClCBFdiAHQi1BrUGNcsl9o0Qr3vdKEAFVmADduAATuBKHFAbUBtQG1AbUBtQG1AbUBtQs1yi93ar171uLEABKrACG7ADB3ACobagtqC2oLagtqC2oLagtqC2oLZSzeteNxagABVYgQ3YgQM4gVArUCtQK1ArUCtQK1ArUCtQK1ArUBOoCdQEagI1gZpATaAmUBOoCdQUago1hZpCTaGmUFOoKdQUagq1CrUKtQq1CrUKtQq1CrUKtQq1CrUGtQa1BrUGtQa1BrUGtQa1BrUGtQ61DrUOtQ61DrUOtQ61DrUOtQ61AbUBtQG1AbUBtQG1AbUBtQE15JKJXDKRSyZyyUQumcglE7lkIpdM5JKJXDKRSyZyyUQumcglE7lkIpdM5JKJXDKRSyZyyUQuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglC7lkIZcs5JKFXLKQSxZyyUIuWcglXveq1XACV6LnEscCFKACK7ABOxBqHWodagNqA2oDagNqA2oDagNqA2oDagNqE2oTahNqE2oTahNqE2oTahNqE2oLagtqC2oLagtqC2oLagtqC2or1NTrXjcWoAAVWIEN2IEDOIFQK1ArUCtQK1ArUCtQK1ArUPNc0g1XoucSR1ObhgJUYAU2YAcO4ASuRM8ljlBTqCnUFGoKNYWaQk2hplCrUKtQq1CrUKtQq1CrUKtQq1CrUGtQa1BrUGtQa1BrUGtQa1BrUGtQ61DrUOtQ61DrUOtQ61DrUOtQ61AbUBtQG1AbUBtQG1AbUBtQG1AbUJtQm1CbUJtQm1CbUJtQm1CbUJtQW1BbUFtQW1BbUFtQW1BbUFtQW6nmda8bC1CACqzABuzAAZxAqBWoFagVqBWoFagVqBWoFagVqBWoCdSQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJcU5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BKve63+vdwCFOCtVtWwAhuwAwdwAleg171uLEABKrAC7dqGYQcO4ASuRM8ljgUoQAVWINQK1ArUCtQK1ARqAjWBmkBNoCZQE6gJ1ARqAjWFmkJNoaZQU6gp1BRqCjWFmkKtQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUHNckkTw5VouWTjrdZsylku2ahAm5PVsAE7cAAncCVaLtlYgAJUINQG1AbUBtQG1AbUJtQm1CbUJtQm1CbUJtQm1CbUJtQW1BbUFtQW1BbUFtQW1BbUFtRWqnnd68YCFKACK7ABO3AAJxBqBWoFagVqBWoFagVqBWoFagVqBWoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hVqFWoVahVqFWoVahVqFWoVahVqHWoNag1qDWoNag5rmkGHbgAE7gSvT7EscCFKACKxBqHWodah1qHWoDagNqA2oDagNqA2oDagNqA2oDahNqE2oTahNqE2oTahNqE2oTahNqC2oLagtqC2oLagtqC2oLagtqK9W87nVjAQpQgRXYgB04gBMItQK1ArUCtQK1ArUCtQK1ArUCtQI1gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUKtQq1CrUKtQq1CrULNc0qbhAE7grdbt71ou2ViAt1pXQwVWYAN24ABO4Eq0XLKxAKHWodah1qHWodah1qHWoTagNqA2oDagNqA2oDagNqA2oDagNqE2oTahNqE2oTahNqE2oTahNqG2oLagtqC2oLagtqC2oLagtqC2Us3rXjcWoAAVWIEN2IEDOIFQK1ArUCtQK1ArUCtQK1ArUCtQK1ATqAnUBGoCNYGaQE2gJlATqAnUFGoKNYWaQk2hplBTqFkuuc/FVq973bgSLZeMYliAArzVxjKswAa81e7DLtXrXjdO4K0272cRr3vdWIC32rL2Wi7ZWBNtVt95yQswVzW8HaxmKEAFVmADduAI9FLL+1xN9VLLjQJUYAU2YAcO4ASuxAK1ArUCtQK1ArUCtQK1ArUCtQI1gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUKtQq1CrUKtQq1CrUKtQq1CrUKtQa1BrUGtQu6ev3CeeqpVaBjZgBw7gBK4b7wlupZaBBShAU7P52yvQ1LphBw7gBK7EcQEL0NSWoQIr8Fa7j01SK7UMHMBbrVh775/CjfdPYWABClCBt5qFv5VaBnbgAJqatWyuxHUBbzWxjrqzRqACbzUxZ3fWCOxA83uvnFhRpdx1sWrlk2I3V1Y+KVYXYOWTgR04gBO4Eu/8ILZSaeWTgQJUoKlZG0oD3mrVGnnnh8AJXIl3fggswFutdkMFVmADmtowHEBTs0bKStQLWIC3mi1HWflkYAU2YAcO4K3WrDl3fth454fAAjQ1a2RVYAWa2mXYgSOxCdA82FVYzNv9sZVEBnbg3bJuY2wfDDC429UdBahA82rDarG9sQPvdtmvtZU+Bt5a4/79tNLHwAK81e6T09VKHwMrsAE7cCRaFA/rUovXYe21eB3WIRavGztwAO/2TutHi1dHi9eNBSjAW23aVVi8bmzAW23axLh/5QMncAVaOWNgAZpaNVRgBY5Ei9f7NHC1EsVA81AMFViB1t5h2IEDaO1dhivR4nVdhgV4qy1rusWr3TlZiaLY/ZKVKL52JQw7cABfanpZy+543XjHa6DeaBJ3DL62LQzHjSah5sEuXs3DPTWs7FDvg/7UCgzVfheswDCwAW+/xfze0RY4E+/fXbXfBSsafG1bGJoH64fWgebB2tDMg3XqHYMb7xgMLEC50drbFViBDdiBAziBK3GYX+vqO7JUrJH3j6KKXfwdTq+tE8MCFKACO9A8WO+sC2gerKPuEFH7dbPKO71fLKlWeRdYgKY2DBVYgW37rVZ5F/91ACdwJZZrX3G1yrtAASowrq1ajZ1dULUau8CVKLLnQ7VqOr1/o6tV0+n9w1ytmi6wAwdwAleiTfuNd3vVWnb/TAUq8Fa7f/urVdOpWtMtRNQaaSGi1kgLkXvSVqum22ghstH8Wp9ZiGxsQPNrLbMQ2TgTLUSqtcxCpFrLLETUxthCZOPtoVp7LUSqtddCxNFCZGMB3v1Q7YIsRDZWYAN24ABO4Eq0EKnWDxYi1RppIVJtYC0Yql2mBcPGCmzAW7hZP9y/OIETuBItcDYWoAAVWIENCLUFtQW1lWpWqBZYgAJUYAU2YAcO4ARCrUCtQK1AzeKtFcMBnMCVKBewAAWowApsQKgJ1ARqAjWFmkJNoaZQU6gp1BRqCjWFmkKtQq1CrUKtmdo0NLVqaGrL8PbbrVNtgncxXIn3nVjgLdHNg037+2avWoFWYAU2YAcO4ASuRPtB2ViAUJtQsxi6bwyrFWgFduCtNqy9FkMbV6LF0LSLtxjaKMBbbVpPWgxtbMBbbVrvWAxtnMAVaAVagQUoQAVWYAN24ACmmpVi6X0/Wa3oSu+bvWpFV3qvbFUrugocwAlciRY4GwtQgAqsQKgJ1ARqAjWBmkJNoaZQs8C57zKrFV0FNmAHDuAErkQLnI0FKECoVahVqNmP2v1NnGpFV4Ez0X7U7vvfaoVUet/0Viuk0vtjOdUKqQIHcAJXov2obSxAASqwAqHWodahZjG/bO5YzDtazG8sQAEqsAIbsAMHEGoDahNqE2oTahNqFvPLZrXF/MYOHMAJXIkW3fcSarXiqNf9rqF5sMGyON44gSvQiqMCC1CACqzABuzAAZxAU7unkRVHBRagABVYgS+/9X4IqlbwVO+HoGoFT4EC1BvVsAIbsAMHcAJXol7AAhQg1BRqamrNsAMH0NSG4UqspmZXXE3Nuu+O41rs4u84DqzAW62Y8B3Hgbea3ZlbwVO121sreKrF1O7V1MACFKACK9D8WiO7ebBG3nFcxZpzx3GgAm8P9lBhRUyBHTiAM3GYX7ugYR7sgoZ5sAsaHTiAE7gS79gMLEABKtDU7IpnA3agqVk/zAlciesCmpp11BKgAm81e4SxwqTADrzV7HHHCpMCV6AVJgUWoABvNXs0ssKkwAY0NTUcwAlciUWA5qEadqB5GIYTuBItju8l1GrFRoECVGAFNmAHDuAErkSFmkJNoaZQU6gp1BRqCjWFmkKtQq1CrUKtQq1CrULN4tgeJ63YKHACbzV7srRio8ACvNXsadGKjQJvNXuqs2KjwA4cwAk0NRs3i/mNpmbttZi3xz4rNqr2YGPFRoENeKs1m3IW8xsn8Faze3srNgosQAEqsALN7x3HVkBUm12FxXyzplvMb1RgBVp77YIs5jcO4ASuRIt5ewCxAqLardct5rs1x2Le7vitgCjw9nt/WL1aUVC915Wrlf/Ue5u4WvlPYAPeLbtXm6uV/wRO4Eq8f3kDC1CAplYNK7ABR7bMQnrjSrSQvpejq9X8BArQJPzvVmAD3hdkzyJW8xN4q9kjjNX8bLSQ3nir2TOD1fwEKrACG7ADB3ACV6KF9EaoVahVqFWoVahVqFWoVahVqDWoNag1qDWoNahZSNsDk9X8BA6gqTXDlWghvdHUbLAspDcqsAJNbRiams1fC2l7OrCan8CVaCFt9+tW8xMoQAVWYAN24ABO4EqcUJtQm1Cz8LcHG6v5CWzADhzACVyJFv4bTc163cJ/owLt2iyy7Cd/YwcOoF2bjZD95BtazU+gAs3DMDQP03ACV6IlhY0vD+3eA69Wm9PsbttqcwIncCXeMR9YgHKjGiqwAhuwAwdwAleixbw9VFhtTqAAFWhq1bABTa0bDuAEmpp1Sb2ABShABVag+bU23HHcinXqHcfN7tet3iZQgRV4t9fu4u2cucABnMCV2E3N2tALUIAKrMAGvNXsxtvOmQucwJV4x3GzO3M7Zy5QgLea3UzbOXPNboXtnLlAU7OOGgN4q9ktq50zt/GO48ACFKACK7ABO3AAoTahtqC2oLagtqC2oLagtqC2oLagtlLNip8CC1CACqzABuzAAZxAqBWoFagVqBWoFagVqBWoFagVqBWoWX6wRxgrfgoUoAJNTQ0bsAMHcAJXol7AAhSgAqGmUFOoKdQUagq1CrUKtQq1an6roXlohivR8oPtBFlBU6AAFViBDdiB5vdO/FaktAego38t5jc2YAfaFU/DCVyJFvMbMXcG1AbmzsDcGZg7A3NnYO54zFsbPOYNJ+bOxNzxmLc2eMw7ViDUEPMDMT8Q8wMxPxDzAzE/FmbqQk8u9ORCT3rMWxsWenKhJxHzEzE/EfMTMT8R8xMxPxHzEzE/PeaL4QRmT85yAQvQ1JahAm812760gqbADhzAW82eLK2gaaPF/MYCFKACK7ABTa0aDmBOcKtiarZRaVVMgQJUYE6N6YHu2IEDOIE57We9gBisisGqGKyKwaoYrIrBqgM4gZgaFv723G21TYEVaB1l/WDhb4/gdtxb4ASuRLs92FiAAlRgBZpfmxqWFDauREsKG2+/9pRv1U2BCqxAu+1w7MABnMCVOC9gAQrQbvYcO3AAJ/D2a3uLVt3kd69W3RRYgbdfW6Cw6qbAAbz9Npu/K2+QrbopsAAFqMAKbMAOHMAJhFqBhD3E2yOBFToFdqA13XECrUvuyWWFToEFaAM7DRVYgXfTbQ3ECp0CB3ACb7Vu7bWQ3liAArzVbO/Wyp+ara1Y+VPgBJrfO2tY+VNgAQpQgRXYgKZmvWPBu3ECV6L9om8sQAEq0JxZp1ps2gKQVUIFClCBFdiAdyNtWcgqoQIncCVaxG4sQAEq8FazFSKrmgrswAGcwJVoEevDYhG7UYAKtCBbhjN7x8LU0X6lNxagNd2mxkKXWJhuHEBrpKlZmN7YrBor0LqkGsYANKvGCqzABuzAAZzAlVguYAFCrUCixNpgu3zZzXElWpjeC2zNjjkLFKCN5jKswAa8m34vITUrzAqcwLvp03rHwnRjAQpQgRXYgB04gBMItQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BjX7PZ42S+z3eGMHmpoNgP0ebzS1dqPF/MYCNDUbWIv5jbfavX7WrLQr8FZbNkIW8xsn8FZb1hyL+Y0FKEAFVqD5tZZZHC+7Covje42pWUVYoAIr0Npr88x+jzcO4ASuxDvQ+2VdfQd6oAAVWIEN2G+0NtzhHziBK9Aqwvq9fNOsIixQgLfafYPRrCKs3ysuzSrCAm+1e7u1WUVY4K1277w2qwjbeId/YAEKUIEV2IAdOIBQK1ATqAnUBGoCNYGaQE2gJlATqAnUFGoKNYWaQk2hplBTqCnUFGoKtQq1CrUKtQq1CrUKtWpq3XAAJ3AlNlOz+dAKUIAKrMAG7MABnMCV2KHWodah1qHWodah1qHWodahNszvMrw9iE3w+3c+8PZwb+A3q3YLnMCVeOeHwAIUoPkVQ4zmRP9azG8sQAHeVywWbxbzGxuwAzF3FtRWzh2rYAssQAEqsAJbNEeuDhzACcxrsyPG+l290KyuLdB6x/xazG+swAa0a5uGAziBK9FifmMBClCBprYMG3DEYFmJW7+fTZuVuG20QN9YgBIDYCVugRXYgB04gBOIwUKgCwJdEOiCQBcEuiDQpXZgTg07QazfyyHNStwCBXj7VesHC2m1lllIb+zAAZzAlWghvbEABWh+bWpY8G4cwAk0v3YV4wIWoAA1frvFf9wdG7ADB3ACVyJuBMRvBBxtO9smge2ebexAu4phOIEr0cK/2t+18N8oQBsLU7Pw39iAd59VGzcL/40TaLfNd1erb7Q7FqAAFViBDdiBAziBUCtQK1ArUCtQK1ArUCtQK1ArUCtQE6gJ1ARqFv73ewfNiuQCG9DUmuEAWk9Ww5VomWCjjVs3FKACK7ABO3AAJ3AlWibYCLUKtQq1CrUKtQo1+3G/l9KaFb71e8mrWeFbv1e0mhW+BTZgB97tvZeQmp30FbgSLeY3FuCt1mws7Gd8YwXeas0aaZlg4wCamg2LZQJHywQbC1CACqzABuzAAYTagJr95DfrPvvJb9Z99pO/UYEV2IAdOIATuBItP2yEmuWHbp1q+WFjBZqaDZblh40DeKt5XNjtgaEV1AXeavdiRrOCukAF3mr3+kOzgrrADrzVbE3BCuoCV6LdHkxzZrcHGwV4q9nTuJ30FdiAt9pde9Cs+C5wAm81e3C04rvAAqx5xfbr382vxfzGlWgxv7EABXi3d1nTLeY3NuDdXnvItIK6wAm09pozi/mNBWjzzP6uxfzGCmzADhxAU2uGK9HuCTaa2jQUoALt2rphA3bgS21c1r93fghcifYisj2FWkFdoAAVWIEN2IEDOIErcUBtQG1AbZiaXdu8spGzAAWowApswLtlxXEAJ/BuWbH5cEd3YAEKUIEV2IAdOIATmGpWZhdoatVQgAqswAbsQFObhhO4EssFNLVlKEAF3mr2wGTFd8Puwe3srcBbzW6QrQ4v8FazhwqrwwssQAEqsAIbsAMHcAKhplBTqCnUFGoKNYWaQk2hplBTqFWoVahVqFWoVahVqFWoVahVqFWoNag1qDWoNag1qDWoNag1qDWoNah1qHWodah1qHWoWSawR0SrwwscwAnMTNCQCRoyQUMmaEOBFdiAHZh5xyruxv0yc2szc4nV1g3xv9CAHTiAE7gSLT9stH4wvwv9u3DFC1dsMW9o9XKB1r/LUIAKrMAcTautCxzACczRtNq6wAKUbIPF/MYKbMCebfCYd5xAqCHmO2K+I+Y7Yr4j5jtivkvOnS4DOIHoSY95a4OiJxU9iZjviPmOmO+I+Y6Y74j5jpjvFePmMe+InqzoyYpx85h3RE8i5jtiviPmO2K+I+Y7Yr4j5jtivjeMW0NPNvRkQ0829KTFvC2dWM1e4K1m6w9WsxdYgQ14q9mKgNXsBU7gSrSY31iAAlSgqVkjLeY3Wsyb8FgRhVadN+wR3KrzAgWoQIzQxAhNjNDEXJ+Y654JDBdm38IILYzQwggtjNDC7EPW6AvzYWE+rJwPVoc3bIHC6vACK9B6ZxraWCzDAZzAlWj5YWMBClCBFTjiJt0q7gLzucUq7gILUIC3X1sOsYq7wAa8r8KWAazibtijvVXcBa5EywQbC1CACqzABuxAqNlzgD1cWcXdRnsO2Fji4coq7gIVaM9kl2EDduAATuBKtOeAjQUoQAVCrUHNYv6uQmp2hNiwlQarzhu20mDVeYEV2IC3h2bOLGJt9cAq7gIVWIEN2IF3/9ryglXcBa5Ei+ONBShABVagtdemp8XxxgGcwHzmtYq7wAI0Neszi+ONFdiAHTiAE7gCreIusAAFqMAKbMAOHMAJhFqBWoGaRbeNplXcBVZgA5paN1wxhFZbF1iA5ncYKrACze807PhnAziBUFOoKdRUgAqswAaEmkLCfsZt8cWq6AIVeDvr/ncbsAMH8PZriw5WRbfRfsY3FuCtZmnQqujGXeDTrIoucADNr42b/WA72g/2xgIUoAIr0NRsNO0He+MATuBKtB/sjQUoQHNmA2tx3K37LI43FqAAFViBdyMtvVrpXOAATuBKtN/jjQUowFvNsrIV1AU2YAcO4ASuGBYrqAssQAHaBV2GI3rH6uUCV6KF6UZruhpml1jpXGAHWiNNzW7HN65EC9P7kLZmpXP7n4kAFQg1gZpAzcJ04wTmcFvpXCDUFBIWhVYMZPVygRO4Eu1u+z5Jrlm9XKAAFWir49Z9vr7u2IEDOIEr0X5jNxagzRLHBuzAAbSrsMu0MHW0MN1YgPcOiOXU5a+pOlZgA3bgAE7gSrSAnDbl7Pd4YwU2YAeORItYW+m1crhha7r2NdFh9UZWGRfYgebBppzF5sa7H6ycyOrlAgvQ2mtNt9jcWIEN2IEDOIGm9poP3aroAgtQgAqswLvX76eObvVy1g/d6uU2lgtofqehABVYgQ1oV7EMB3ACV6IF7zI1C96NArzV7rf4uhXUBTbgrbbsgix4N07grXavuncrqBv3anO3grpxLxt3K6gby3rH4nhjBZpfuzaL440r0eJ4o/m1a7Mf1ntydSuSC+zAAVyJ9uqp2LXZq6cbK/AeQrFrs1dPNw7gBK5Ee/V0YwEKUIEvv/OyPrsDMnACV+L9uzkvG6z7dzNQgAq8r6JY79hLphs7cAAncCXaS6YbC1CAt19Xsw3xjXYV1r9zAlfiuoB2FdbVS4AKrMAG7MD7KrazCVyBVgMXWIACVGAFNmAH2lXc42bVboEFKEC7imZYgQ3YgWOfctP9gLSNK9HOedpYgAJUYAXaWDhO4ErUC1iAAtR9mlIveaJTL3miUy95olMveaJTL3miU/ej0Cxd+VFoGwtQgAqsQLsKc9asvfZfWwEKUPcxTr3kiU7dD1Pb2IEDOIEr0U90cixAAUKtQ61DrUOtQ61DrUNtQM3jeBlWYAN24N07xf/ZBK7EO44DC1CACqzAW+3eS+p2XlvgAE6gqVmIWHRvLEABag6WR7djA3bgAE7gCrRqt8ACtKtQwwbsQLuKamhX0QxXokX3xgK0q+iGCqzABjQ1a84d3fOuPOxW1xa4Eu/oDixAASqwAhuwA6Fmp7gNu2I7xc3RTnHbeM/qYf1gp7htVOA9q++Hle6nuG3swAGcwJVoMb+xAAWoQKhVqFXrs3ueWTHbtJ9mK2ab9hNqxWyBFdiA5sGGpZuHYShABVZgA3ag9e8ynMCVaL/SGwtQgAqsQFOzeWbRvXEAJ/BWUxtji+6Nt5pan1l0272nncwWWIEN2IEDOIEr0aJ7YwFCzU9jtOb4aYyODWi/Fzaafhqj4wTa3Lm7xE9x21iAAlRgBTZgBw7gBEKtQM2i+94a6FagNu8l8W4FavNeEu9WoBa4Ei2ON94e7vq+bkVn816D7lZ0FjiBK9F+jzcW4N2/9zuk3YrOAiuwATtwACdwJVZrr11xLUABKtDUqmEDmpr1jv1Kb5zAlWi/3RsLUIAKvNWadZ/F8cYOHMAJXIn3b3dgAdq9hhgqsAIbsANHokV3s2GxOG7+XyvQPFjv2AmLGwdwAleinbC4sQAFqEDrBxtCi9jm/3UCV6JF7MYCFKAC7Sps2tvv8cYOHEBT64Yr0MrLAgtQgAqsQFMbhqY2DQdwAlei/UpvLECJsbDyssAKbMAOHMAJXIkW3Rszuq28LLABO9D83jFUEd0V0V09uh1vv93+mUX3xga8/Xb/uwP/bAIzl1h5WSDUKtQsujdWYAN2INQqJCx4u3WJBe/GCrSmV8MOHMAJvP3e68rdqscCC1CApmZzx36au80d+2neOIHm16aGBe/GAhSgAiuwAU3NRtN+mjdO4Eq0n+aNBShABd7OhnWqRazd+ljJWKAAFViBDXg30m7grGQscAJXoJWMBRagABVoas2wATtwACdwJVrE2rBYyVigABVova6GM3rHKsI2WkBuLEBrejfMLrHar8ABNL+mZj/CjhamG83vNMwBsNqvwAqEmkJNoWZhunEl1gtYgFCrkLAotBvZVidwJdpv7EZztgzznra1BuzA26/dn1kRV+BKtIC0+7OGO+iGO+iGO+iGO+iGO+iGO+jmd9COE7gS/Q7aEWoDEhaF9ntsNVqBE2hNt0lrUbixAAV4+502Pe0GeWMDdqCpWf9amNoSh52KFihA82tzx8J0YwN24ABO4Aq0Kq9pC7lW5RUoQAVWYAN24Ei0KLT1XyvXmncNcrdyrcAOHMAJXIkWkLYUbOVagQJUYAU2YAcOoKk1w5VoYbqxAAWowBrDYuVagR04gNbrd96xaqzdO/ZjubECG9Ca3g3RJRaQGwvQ/Jqa/W5urEDzayPfMAANA9AwAA1qHWodahamGxWI4e4Y7g61DgmLQltqt7KqZcvRVlYVWIENOBPv0Fu2QGwFVIHmwSTuIFu2pmvlT8sWUa38KVCBpmYDuxqwA0f6XRP/dQXa4WSBBXjfbd+v0HQrigqswAbMa7PyJ78gK38KLEDzYH+3WHvNQ7H2DsMBnMCVKBewAAVovTMNK7ABTW0Z3mq2yGflT8vW8Kz8adkSnZU/2QdeupU/BQrw7ofL/+7t11bVrNBp2aqaFToFrsT7py6wAAWowPsqbNnNCp0CO9DUrCerqVk/VFOzK26mZlds5/zb5LJCp0AF9v3Zre5fUNw4gbdfW4SyLygG3ldh61FW/hSowPsqbBHKyp8CO/C+CvvBtqKowJU4LmABmppdm0XhxgpswA4cwAlciRabtprkX0W0Xz0rdFpqV3w/WW68fwAD75bZypMVOgXeLVPrB4vYjQ14t8zWjazQKXACV6AVOgUWoABNrRlWYAN24ABO4IortpKmdVd2ditpCqzABjS/w3AAJ3Al2lfWhmMBClCBFdiAHTgS1XpnGhagABVYgfdV3DWR3UqaAgdwAleixfHGW80yotU8BSqwAk3N2mtxvHEATc1aZnHsaHG88VazlRyreVq2DmPniS1bDrHzxAIbsAMHcCZaHNtShNU8BSqwAhuwJ1qQ2VO+HfYVeEvYk7tVLC17KLaKpUAFVmAD9kQLHHsessqiwAGcwBVolUWBBShABVZgA3bgAE4g1ArULHDs0d6KjJY9uVuR0bIHPCsyClyJ9lNnD9tWZBQoQAVWYAOa33sArHBo3VWr3c7cWrbtYTVEgRV4e7DnLKssChzACVyJFgwbTc2u2IJho6nZxVswbGxA83tPI6sWWhbSdrpWoHkohubBLtMm+MYOHEDza/1gP1+O9vO18VazBzyrIQpUINQ61DrUOtTs52vjyrEYGM2B0RwYzYHRHBhNiyEfwnnlEFoM+WBNjObEaFoM+VhMjObEaE6M5sRoToym/aj5uC2Mpv2o+WAtjObCaFoU3kM4rFrIxm1YtVCg7CEcVi1kHTWsWiiwATtw7MEaVkMUuBIt3u7BGlZDFChAqBWoFagVqJWRaMFwP0sPO9kqcADv5txPScPKczZaMGwsQAEqsAIbsANNzbrPQmTjSrRfho0FKMBbbVmvW+BsbMAOvNWWXZsFzsaVaIGzrGUWOBsFaGrVsAIbsANNrd1oIbJs7liIbBSgAs2vjZDd4S2bBPePT7kuG+87cpIn8QLfIfViu+w7ppKFWImrsV3kdC1r+XQta9l0LWvaNK1i/3ZdxIVYiJW4Ejdi0y02EmsQm26xNqyVbHU/yYVYiJXYdO9982HFP8mdeBCb7v0YMKwsKLhcxKZ7v986rDIoWYldtxq7rrWndOJBPIkXWC5i01XzL0KsxJW4EXfiQTyJF1gvYtJV0lXSVfdv16uDeIKr/51mPIj979g11gVuF3Eh9jYMY2/DNK7EjbgTD+JJvMD9Ii7EQky6nXQ76XbS7aTbSXe4/2VsfqrNw0FjN2jsBo2d5wG1Oel5wNnzwOZCLMRK7LrOjdh0q2l5Ttg8wR77977zKB7j1cbaY3yzt9+uy2Pcx85jfPNKFo/xze6/GQuxEtecG+IxvrkTD/I5iUm3kK7H+Gb7O9XY43FzIfb8o8ZKXIkbcScexN6303iBPR43F2IhVuJK7GO3jCfxAteLuBALsRJX4kbciUm3km4l3Ua6jXQb6TbSbaTbSLeRbiPdRrqNdDvpdtLtpNtJt5NuJ91Oup10O+l20h2kO0h3kO4g3UG6g3QH6Q7SHaQ7SHeS7iTdSbqTdCfpTtKdpDtJd5LuJN1Fuot0F+ku0l2ku0h3ke4i3UW6C7p6XcSFWIiVuBI34k48iCcx6RbSLaRbSLeQbiHdQrqFdAvpFtItpCukK6QrpCukK6QrpCukK6QrpCukq6SrpKukq6SrpKukq6RL+UopXynlK6V8pZSvlPKVUr5SyldK+UopXynlK6V8pZSvlPKVer66F6uGer7arMQt87DuHOU8iCcxcr72i7gQC7ESV2LS7aTbSbeTbifdQbqDdAfpDtIdpDtId5DuIN1BuoN0J+lO0p2kO0l3ku4k3Um6k3Qn6U7SXaS7SHeR7iLdRbqLdBfpLtJdpLugW6+LuBALsRJX4kbciQfxJCbdQrqFdAvpFtItpFtIt5BuId1CuoV0hXSFdIV0hXSFdIV0hXSFdOneqdK9U6V7p0r3TpXunSrdO1W6d6pKukq6SrpKukq6lXQr6VbSraRbSbeSbiXdSrqVdCvpNtJtpNtIt5FuI13KV5XyVaV8VSlfVcpXlfJV9Xx11x+O6vlqsxKb7r3QPqrnq82d2HTv2sRRPV9tXmDPV5sLsRC77jKuxI24Ew/iSbzAnq82F2IhJt1JupN0PV816zfPV5sn8QJ7vtpciE33LiMc1fPV5kpsuvfOw6ierzYP4pncPC/dK/+jXfDTPP9s7sTupxlP4gX2/HOX+Y3m+WezECux6w7jRtyJB9jzzL3iPJrnk3vJeTTPJ5sbsfe//9tBPIkX2PPJ5kIsxKZrK8PN88nmRtyJB/EkXmDPJ5sLsRCTbiXdSrqVdCvpVtKtpNtIt5Gu55N7DX80zyebK3Ej7sSDeBIvsOeTzYWYdDvpej4ZNm89nwybt55PNg/iSbzAnk82F2IhVuJKTLqeT2z7oHk+2TyJXffOh83zyeZC7Lo2nz2fbK7EpjvNp+eTzYN4Ei+w55PNhViIlbgSk67nE1uib55PNk/ildz9/mdzIRZiJa7EjbgTD+JJ7Lp3vHfPP5sLsenainz3/LO5EpvuMp+efzYP4lu33DVNw8rogi0vBRfjZizEStxzfLvnH9t06p5/NhdiIVbiSnyXHFiqtjK5wAH0xpuoLnC9iL3x1iFViJX4LnO498iHVdMFdqA7t55vF3EhFmIlrsSNuBMP4klMup10O+l20u2k20m3k24n3U66nXQ76Q7SHaQ7SHeQ7iDdQbqDdAfpDtIdpDtJd5LuJN1JupN0J+lO0p2kO0l3ku4i3UW6i3QX6S7SXaS7SHeR7iLdBV2rB0wuxEKsxJW4EXfiQTyJSbeQbiHdQrqFdAvpFtItpFtIt5BuIV0hXSFdIV0hXSFdIV0hXSFdIV0hXSVdJV0lXSVdJV0lXSVdJV0lXSXdSrqVdCvpVtKtpFtJt5JuJd1KupSvBuWrQflqUL4alK8G5atB+WpQvhqer+76zTE8X21eYM9XmwuxECtxJW7Epms7DsPz1eZJ7Lr3j8LwfLW5EAuxElfiRtyJB/EkJt1Jup6v7iLRMTxfbVZi07Ud2OH5anMnHsSTeIE9X20uxEKsxKS7SHeRrueru350TM8/d0XsmJ5/NrufYdyIO/EgnsQL7PnHdvem55/NQqzEpmu7itPzz+ZObLpq7ff8s3mBPf/Ybu/0/LNZiJXYdZux61r7Pc/YDun0POPseWZzITb/tnM6Pc/YDub0PGO7k9PzjO1ITs8zmwfxJDZd22Gcnmc2F2Ihdl1rv+cWWwmZnltsxXh6brGV4em5xVZCpucWZ88tmwuxECtxJTZdW/GYnls2z4yRufOJ8c4nzoVYiJW4EjfiTjyISbeT7iDdQbqDdD2f2NP09HyyuRH7NVo/ez7ZPIkX2PPJ5kIsxEpciRsx6U7S9XxiN9LT84mz55PNhViIldh0bbVkej7Z3IkHset245W8/P5ns+tOY9ddxkpsuvY0vTz/bDZde+pfnn82T+IF9vyzuRALsRJX4kZMuoV0C+kW0hXSFdIV0hXSFdIV0hXSFdIV0hXSVdJV0lXSVdJV0lXSVdJV0lXSVdKtpFtJt5JuJd1KupV0K+lW0q2kW0m3kW4jXc9RtgKzPEdtrsSNGL+Pqw3iSYzf5dUv4kIsxEpcif267t+C5flHnL391ViIlbgSN+JOPMCeZ+4a0rEm9f+kfpjUD55PNg9i73+LX88nzp5PNhdiGvdFuovGfdG4Lxr3ReO+aNw9n9ztmZfnk82FWIg12jOvnU+cG3Hqzgv5ZF7IJ/NCPpkX8sm8kE/mhXwyr6JoQ6nEjbgTD7SnTOIFFtIV0hXSRT6ZF/LJvJBP5iV0vTLQhp1PnKmflfpZC9qz84kz9bOSrpKukq5SPyv1s1I/V7reStdbaXwr9XOlfq7Uz5X6eeeTYTyJXXfevPOJcyEWYtOd1h7PJ5sbcScexJN4gT2fbDbdaW32fLLZ73+sn/0+547reXk+uUua5+X3OZsX2PPMZhrHQeM4aBwHxcugeNl5xpnm7aBxHDSOk8Zx0jhOmreT5u2k+TNp/kyaP55/7tfmplf/Bhdi7zfrH88/09rp+WdzI+7Eg3gSr2Sv/g0uxO5/GDfiTjyIJ/ECe57ZXIiFWIlJt5BuId1CuoV0C+kK6QrpCukK6QrpCukK6QrpCukK6SrpKukq6SrpKukq6SrpKukq6SrpVtKtpFtJt5JuJd1KupV0K+lW0q2k20i3kW4j3Ua6jXQb6TbSbaTbSLeRbifdTrqddDvpdtLtpNtJt5NuJ91OuoN0B+kO0h2kO0h3kO4g3UG6g3QH6U7SnaQ7SXeS7iTdSbqTdCfpTtKdpLtId5HuIt1Fuot0F+ku0l2ku0h3QVeui7gQC7ESV+JG3IkH8SQmXcpXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKF8J5SuhfCWUr4TylVC+EspXQvlKKV8p5SulfKWUr5TylVK+UspXSvlKd76axgu885VzIRZiJa7EjbgTD2LSLaQrpCukK6QrpCukK6QrpCuk65VCw3mB9069cyEWYiU23fuw4OnV0cGd2HTvlxunV0eX+zXF6dXRmz1fbS7EQqzElbgRd+JBTLo1K0nmro7eXIizomPu6ujNldgrOppxJx7Ek3iBvVJocyEWYiWuxKTbSdfz0v1a5/TK57LsWjz/LGuz55/NjbgTu591s+UTuWwcLZ8EV+JG3IkH8TQW4wW2fBJciIVYiStxI/b225z0fLJ5Eq/kXcl8V9HMXcm8WYhdtxpX4kbciQfxJF7gchEXYiEm3UK6hXQL6RbSLaRbSFdIV0hXSNfziY27VzIHN+JO7Lr33POKZR9rr1gOFmK/rm5ciRuxX9cwHvRvJ/ECV9KtpFtJtypxJW7EnZh0K2k192nzpylxJTafxf9+Jx7Ek9j83/vF06uRgwuxEJvu/cbx9Kpjufe+p1cdB09i92/jOy7iQizESlyJG7Hr2riPQTyJF3hexIVYiJXYfdoc8PxQrG89P2wWYiWuxI3Y2izW55YfgifxSrbTKJMLsRArseneb1tPrzQO7sSDeBIvsOcHGzuvNA4WYiX2ObyMZ/Zb89h39tjfXIj9WsQYfeXVxcGD2NtsurLAHvubva+qMcbIq4uDKzHpKukq6Xrsb17gehEXYtKtpOWVw915Evu13HPPK4eDC7EQK3ElbsQ+7tbPHvubJ7HrWhs89jcXYtftxkpcibMyfO7K4c2DeBIvsFcOby7EQqzEldj927h7hfBmvy77Ox77mwuxECtxJW7E1p9qMeL5YfMkNl21+ex5Y3MhNl21mPW8sbkS55sCc1cIbx7Ek3gl7wrhzYVYiJW4Evt1qfEkXmDPD3ctyvRK4GAh9utqxpXY+vN+u3x6JXDwIHbdYbzAnkM2F2IhVuJK7LrTuBMP4km8wJ5bNvubQXaNXiF8n0Iw+37jya5xv/HkPIgn8QLvN56cC7GNl/eJv6GwuRI3Yte9jAfxJF7g/caTcyEWYiWuxN5vdu2eTzYvsOcT//ueTzYLsY1Xtbnn+WSzjdd9WsL0OuHgQWy61eak32M4+z3G5kIsxEpciV3XxtfvMTYP4km8wJ5nNpd92tHsfpaZ9Yifw+TYgQM4gSvRz2FyLEDZ5xpNPw50YwU2YN/nRk0/DnTjBK5APw50YwEKUIEViBkxrkmMGeEVvj7yXuEbLMSYEV7hG4wZ4RW+wYMYM8IrfDfLRVyIhViJKzFmhFf4Bg/iSYwZ4RW+wTkjrJDXZ8TQnBF+eOjGAZzAnBF+eOjGAswZ4YeHbqzABswZ4YeHbpxAzIiGGdEwIxpmRMOMaJgRniMsl3ltbvAC7xzh7CPTjYVYiSvxfTXd/2kHDuAErkQ/hc2xAAWoQB9w692dApwn8QLvFOBciO1ymk0ov9XYXIkbsek2mzh+q7F5Eptus3b6rcbmQuy6Nuv8VuMuuZteeivN2uaPKJs78SCexCvZy23t1ZTp5bbB9m/tlsLLbYPt394vSU4rt/U7Vau2DRSgAiuwAd3z3WNeOCv3CYvTjxC1e1c/QnRjBZqPYdiBAziBK1EvoMtZM/wZY7N18l07OL2ONrgRe7PNT7Urt//sjwzeN75csLkSN2Lvb7sgXy7YPImpv/2xYnMhJt1Guh6+FspeChu8wB6+w3rdw3ezECtxJW7Edi22nOulsMGTeIH9J96ynpfCBgux6VqZipfC2unF00thgzvxIJ7EC+zxvbkQC7Hr2nTw+N7sujbWHt+bB/Ekdl27Fo/vzYVYiJW4EjfiTmy6tjzupbDB3s93v3kprCznQizESlyJTes+LnB6+WvwJDYtWxL38tfgQuxazViJXasbN+JO7LrDeBIvsN8cbC7EQqzErjuNG3EnHsSTeIH95sCWytdOG3a9O23432nEnXgQT+IF9qWJzSVz8Np5xlmJK7HrWtt2nnEexJN4gXeecS7EQqzE3m/LeBBP4gX2nLP59m+Hr08vZw1W4krciDvxMLY5YzkneIEt5wS7rs2HIcRK7LrW/6MRd2LTtWXYZTlHbYl1Wc5RW2L1stjgQizESlyJX/7tod2KYjetoDurbCpJ4rS8PFWLsxJX4td13Qsfy4pTN42kmbSC7MNyTu6zGluf3Euvy0pMq/+NmbSC7mi9HxSWlZZukiRNqkktyVW68SD2nh/GC6wXsbd2GrufZTyI7+t1Mi9iqhaHwYVYiJW4Rg/V7N2avVuzd2v2bs3ebYI+taXA3acWYyr+dwaxXfm9/Lq8xHNz9zbbGN8x1qxld4Rt0qSa1JJ6kvu09niciLXnjpNuf+OOkk0t6f731o93fGyaSSvojoxNJclVbFw9KjbbrBUbS/slDu7E3lob4+V+zOdS4vt6/W809NHqxIN4Epv3e3lveUlmcCGWHAM/kDW4EkPXSzWDB/EkJt1CuoV0C+kW0i2kW0i3kG4h3UK6ZYH9k81GiAAv1AxW4krcwPZrqGqt8RjcPIjvqGhGK8g+u+pUkiRJk2pSS+pJIyk1amq01Gip0VLDfu/0XhpdXh4Z3Ij9irrxILY+tZzs5ZGbPUY3F2IhVuJK7Lo2Iv47uHkQu+4wXmD/HdxsupZdvTwyWInvXp1GLaknjaSZtII8mi3ze4mjVhtlj9pq12L3z8GTeIHt/lmrjcUqxEKsxJX4brWNhEd5dR7Ek9hV79Z7gWNwITZVy5Be4BhsqveLjssLHIM78f3r2I1m0gq643tTSZIk9ynG1uZ7tWF5kaLeqwrLixSDC7EQe5vNp8fq5kbciQfx3epltILu39lNd6utj+6H6k2aVJNaUk9ylWE8iRfYf3M3e2vt39ZOfPew/42ZtILs7lbtd8qLC4OF2PqnWz97tG82xW597tG+2VrerW892u/FhOXFhdqt3zzau7XBo32zEN+/yk41qSW5Z7tGj9tufe5xO6zlHrfDZprfvw5rud+/Dmut36cOa63fpzr7ferml39XuiN4kybZtQ+7Ro/SYdd4R6lf7R2jm7x1dgUeocN8eIRubsSd2Pp12FV6jG5eyV7UF1yIhViJK7H5v9dTlxfp2Veblxfg2Sdylxfg6f0yy/ICvOBBPMEec5vdTzVuxO6nGdu13CsGywvh9C4MW14IF9yJXXcaT+IF9jtW9+93rPu/C7ESV+KGfvCo2jyIJ7jR9XoM+TV6DG2mfvBYsbnjhW06bSw8VpaNhcfK5kIsxEpciRuxtX9ZO/2XcfMkdl0ba/9lXHYtHmHL2uwRtqzNO8JsvHaEOTdi9++8wB5hm+8IMe8WYU6a5C23EfcIWzY6FmHWVoswJ2+d9aJFWL3s6i3CghtxJx7G1hMWYcEr2cvcgguxECtxJXb/dzu9bK3eH15YXpJW75Kx5aVn9S4BW156FrzAchG/2mBZzQrPNmlSTWpJPWkkzaQVdP+ObUoNTQ1NDU0NTQ1NDU0NTQ1NjZoaNTVqatTUqKlRU6OmRk2NO/4s91tp2SZNqkktqSeNpJm0gu4o3JQaPTV6avTU6KnRU6OnRk+NnhojNUZqjNQYqTFSY6TGSI2RGnb/WIv1zPT5c8eNl4BVW/PwUq9qz9heflVtFcHLr4IbscWLrRxY+ZXlLiu+2rSC7hm+qSRJkibVpJbUk1KjpIb9qlRbpfADHas9UflHge1K/CPdRiNpJq0g/2y3UUmSJE2qSamhqaGpoamhqVFTo6ZGTQ37+KhdlX171Kkl3RrW7/Z9YKcZZL821dY+vGyq2rOtl01Ve1b1sqngQTyJF9h+bYILsRArcSUm3U66nXS769q19wUeF3EhFmIlrsSNuBMPYtIdpDtJd5LuJN1Juv4dYaOW1JNG0kxaQct92sj6b5Ct5lhJlP3+WkHUppl0b/be87v7p02NSpIkaVJN8h641b3Qqdq6jxc6BQuxXamtonihU3Aj7sSDeBIvsP9abS7EQky6QrriumLciQex61bjBVbXbcau241d1/pElbgSm6498XsBVLDp2hO8F0BVe4LfBVD2V7z+ybEABajACnTPd4x4KVOtdhUe4/bE66VMwUpsLbcnOj8KMbgTD+IJ9hi3Z04vWar27OolS9We5L1kKXgQT+IF9ljeXIiFWIlN11YEvGQpuBO7rvW2x/LmBfZY3uy61p8ey5uV2EvADBuwA63uzP/uBK5EPzbVsQAFaINtc9CPTHVsQL9Gk/P7z82TeCX7sYXB3lfNuBO7n248iRd4H4BqWIACVGAFNmAHDuAErkSBmkBNoCZQE6gJ1ARqAjWBmkBNoaZQU6gp1BRqCjWPeVtp8EMIgyex9+YdLX4IYXAhttG6dyGXH0IYbDPenm78EMLgTjyIJ7Hp2pqKH0IYbLq2zuCHEFZbR/FDCKutVfghhMGN2HWtzZ4pNk9ie9nHmr/PDDMsQAEqsALNs92b+nGC1dZm/DjBanfwfpxgsBJXYmu5rc14TVPwIJ7EC+yveZqbfSqGoata33mGsDUXr2gK9gL6G/cCrKE/ARtWYAN6A60LPcA3T+KVPP0Bc3MhFmJroi3J+HmBwY14RBu9ZmnjSvQ1nm5YgAJ0lWZciRuxXZ0txvjpgMF2ddP9LLDfDGz2xRJDASqwAhuwAwdwAlei73k6Qk2hplBTqCnUFGoKNYWaQq1CrUKtQq1CrULNE8B07sSD2PvTRt8TgLMngM02W+zGz8uggpW4Epuu3WT6SYHVFn68VKr6f57AlejPCLYy5HVSwUKsxJW4EXfiQTyJF3iQ7iDdQbqeM+z6PGU4NmAHDuAErkS/oXD0O0hDASrQL9JCazbiTjyI/SItivzh3Nkfzjcrsfux6PI8YotgXuwUvJK92Cn49tPsRtMLmZotSHkhU/AkXmBLE8GFWIzVWIkrcSPuxIN4Ei+wZwpbyPNCpmAhVmLXrcaN2HWb8SCexLeu/TJ7HdPGAhSgAivQPd95zUuV2l02s7xUqdlNhZcqBStxJbaWFxspywXBg3gSL7DlgmbLOl6qFCzESlyJG7HrWvvbIJ7EC9xd19rfC7EQm64t03gJU7NfUi9hCjZdW8LwEqZg07XlAy9h2mzpILgQC7ESV+JG3IkHMekO0p2kO0l3ku4k3Um6k3Qn6U7SnaQ7SXeR7iLdRbqLdBfpLtJdpLtId5HuSt37y8IXG4UNYUPZqGw0Njobg43JBrfAk9C9AnMbhQ1hQ9m4W7D2v2/EnXgQT+IFtkQUXIiF2C+wueGX0d1YZKhfxnCjsCFsKBuVjcZGZ8N1phmVh6Vyp3iuCaOx0dnwYVluTDYWGZ5xwuCJ0bgFjSdG44nReGI0nhiNJ4Znnt02Tz3b6DwxOk8Mzz67bTv9bKOywS3o3ILOLeg8NTtPzcHBMbgPBk/NwaMweBQGj8LORd62waMweBQGt2ByCya3YPIoTB6FyaMwuQ8m98FOS962yaMweRQWj8LiUfDcdC/m3YayYS24C/1uo7HR2RhsWAt0u14wvAQtjcKGsKFsVDYaG96C5sZgg8LM68+adjcKG8KGskGTz4vQ0uhsDDYmGxSAfmhgGjT0Xo2WhrJR2WhsdDYGG5MNmnx+TGDT4YayUdnw7vV+88Sl3mq/cwpjsrHI8JuqMAobwoayUdkwnXq5MdlYZHhKC8N0anFD2FA2Kht+7+mX7SktjMHGZGOR0S82ChvChut4Qz1xhTHYmGz4lYoZnp4ub7WnpzAqG6ZTfbQ9PYUx2PAe9fgZixzMi43CBrdgcgsmt8DTUxidjcHGZINbsFjUCwGWh7PvwoTR2fCL86D1vBOGd6JNZS+KS6Ow4dNluaFsVDbs4lpxo7Mx2JhsWAuaDaOf/5dGYUPYsBY0dcN1qhuDjcmG61iHeCldGoUNYUPZqGw0NrwF3Y3BxmRjkeF3T2EUNoQNZcNd+5B4Dmne8Z5DwhA2lI3KRmPDLqH7kHh2CWOyscjw7BJGYUPYUDasBd2H0bNLGJ2NwcZkY5Hh2WUPsGeXMIQNZcMv+3JjUo96QtmG3wmFUdjwi/PJN7gTPaGEMdjwS/AWeELZhieUMLwTfVZNHsbJwzh5GCe3YHILJrfAE0oYi4zFE2nxRFrcgsWiK5aPb57EK9nL9/yH1cv3goXY58Z0o7LR2PC5sdwYbEw2/FUnY39lbXMhFmIlrsSNuBMP4klMukK6QrpCukK6QrpCukK6QrpCukK6SrpKukq6Srp+QzMuNxobnQ3r7CFuTDZsDg0fa09GYRQ2bA6N6oay4S3w5ngyCsNbMNwYbEw2/M0zY3+zbXMhFmIlrsSu4FPNU8rw/8VTyvSu8JQShrJR2bArmd5JfisTxmBjsrHI8MwzmxuFDWFD2ahsNDa8BX49npPCmGwsMjwnLb8ez0lhCBvWguWt9pzkKwh+5F8a1oLlg+45KQxrgd+jeC1kGJ6TwihsCBvKRmWjsdHZGGxwCxa1wEsj0yhsCBvKRmWjsdHZGGxMNrgFhVtQuAWFW1C4BYVbULgFhVtQuAWFW1C4BcItEG6BcAuEWyDcAuEW+F3S6m4MNiYbiwy/S5rOhViIlbgSN+JOPIgn2NPWGm74Zez/pbHhl7HcGGxMNhYZfqcURmFD2Lh1uj/e+DGA0XeNO8VTVBiFDWHD1vb9QcE/TZ5GY6OzwROjcws6T4zBE2PwxBg8MQZPjMETw1PUbujgiTF4YgyeGIP7wFJUv8SNwobtblzqhrJR2WhseB9s14ONycYiY11sFDaEDWXDW+BTbDU2Bg39clGfb2vB8HMH0yhsCIbRa1/TqGw0Njobg43JBg1946zUOCs1zkqNs1LjrNQ4KzXOSo2zkp9K2K/lRmFD2PANrMsN38LyVlvuSaOzMdiYbCwy9ubZNgobwobriBudjcHGZMN1bPL5OYVpFDaEDb938sve907baGx0NgYbk41FRrvYKGxYvYs32s9f39yJb5FSnSfxAne/xu5GYUPYsEobv14vtdnciL2LhxuDjcmGqTv7KeybC7EQK3ElbsSdeBBPYtKdpDtJd5LuJN1JupN0J+lO0p2kO0l3ke4i3UW6npeKJw/PS2E0Nrzgx4dnV/xsw3vb54knKTf8kMM07Gb8chZiJa7EjbgTm8I2LNV0f870Mt8u4kZlo7HR2bB548v6XuubxiLDk1AYhQ1vQXND2ahsWO2NOnfiQWzlN94ur/Zx9nKfzYVYiJW4EjfiTjyISVdJ1/ORPyZ61W/3bTmv+01D2ahsNDY6G4ONycYio11scAvsdqn7potXDadR2fAWTDc6G4MNa4Fvx/jxiGF4vgpD2fAyZOdBPIkX2Mt8Nhdi23D1WWK5J7gS22Xo/gedjcGGX4aP3lhk+F1SGDaH/Cr2ASXOSlyJG3Endm1vot8fhbHI8Psj3yTxeuI0hA3vXJ9tnofCaGz41XtO8ZulMCYb1gLf8LCKYt8esILiQPvHPgpeUJzGIsPuc9IobAgb1nxfJffS4jQaG50Nb8FyY7KxyPDk4wuVXmichrBhLfDFdC83TqOx0dmwFvhiupcdd18d9RLj7uvaXmSchrJR2XCd4Ybr+JX6HVD3hvodkK8De71xGJ5xwihsWAt8tddrjtOobDQ2rAW+ouq1xt1XVL3YuHebUV5t3H2B0cuNuy9Zeb1xGspGZaOx0dkYbFgLfNHMy47D8Psgn7leb5yGslHZaGx0NlzUL9tvhcJYZFg+6sM7ZBQ2hA1lo7LR2OhsDDYmG4uMyS2Y3AJ/dPOFOK9cTqOy0djobAw2rAW+qOYnMobhqSmMwoa1YKobykZlw1rgK2xeE92nzypPTWF4CzwwPDW54XXRfU43ChvChrJR2WhsdDYGG5ONRUbhFhRuQeEWFG5B4RYUbkHhFhRuQeEWFG6BcAuEWyDcAuEWCLdAuAXCLRBugXALhFug3ALlFii3QLkFyi1QboFyC5RboNwC5RZUbkHlFlRuQeUWVG5B5RZ45vNFXC+4TmOysciwNDg2F2IhVuJK3Ig78SCeYE94vnrsddT7p9oLqfsqbnQ2BhuTjUWGp7UwChum46vUXiQd3TW4UwZ3iqeoMAobNiy+su0F02lUNhobPDEmt2DyxJg8MRZPjMUTY/HE2CnK27ZT1DYaGzwxPEXttnmKCmPBWJyiFqeoxSlqcYpanKIWp6jFKWpdNDXXNdmgUVjlYqNQ24qwoWxwCzhFLU5Ri1PU4hS1OEUtTlFLaB6snaK2oWxUNmgeePF2GoMNbgGnqMUpanGKWpyiFqeoxSlqcYpaSvNgKY+C8igoj0LlUfAU5ds3XgKeho9Cc6Oy0djobHgfeNs8RYWxyPA7tTAKG8KGslHZ8Bb4JfidWhiWqXwQ/JnPE4WXfg9fj/Xa7zSUjcoGD3bnwe482H2ywSG3k9g2eMIPHuzBgz14sAcP9uAJz4lvDZ5ug6fb5Ok2/UqLG5WNxoZlfl9999Lv4cvqXvudxiLD0lsahQ1hQ9mobDQ26Dnei73dKF7snUZhQ9hQNlynudHY6Gz4lXY3/EqnG4uMcrFR2BA2lI3KRmOjszHY4BbsskrjXVXpXIi90tBZiSuxv0jh3IkH8SReYN+621yIhViJKzHpKumq9+wyw9LPKP6/WPoZxS/N0k8ajY3OhnmzFeriNd6j+Nj6DU8YlY3GRmdjsGGjYUutxWu8w7Ask0ZhQ9hQNiobjQ1vgY9WH2xMNhYZnmU2F2Ihdnnv6FHZaGx0NgYbk41FxrzYKGwIG9yCyS2Y3ILJLZjcgsktmNyCxS1Y3ILFLfDks6eHJ58wGhudDWuBrVIXL+PeM8LLuNMQNkzHFrOLl3Gn0dgwHVu/Ll7GnQ4mG4uMwi0o3ILCLSjKRmWjsdHZ4BYUFrXEMqzAq3ixdhqVDb+4/W86G4ONyYbp2NJ08W+9p1HYEDa8BcMN15luDDYmG65j88CLtdMobAgbykZlo7FhLVCfIXWwMdlYZPgzWhiFDWFD2XDXPl086ah3vCedMIQNZaOy0djwS/Ah8aQTxmRjkTEuNgobwoay4S3wYfS8E0ZnY7Ax2VhkeN7ZA+x5JwxhQ9nwkatuTOpRTyjb8IQSRmHDL84n3+JO9LQRxmDDdbwFa8Hw+uw0XGe5QcPo9dlpVDYaG52NwcZkY5FRLjYKG9yCwqKeKexBv3hJdhqLDLtPScNc20sIxUuy01A2Khu+6bONzsZgY7KxyPBnrTAKG8KGdaLtJhT/8Hoag43Jhl+pd4gnlDAKG8KGvQ88XNTP2AijsdHZGGxMNhYZ/qJ9GN6j1Y3KRmOjszHYmGR4dqnNDffW3XBvw43OxmDDvfkk9xyyDc8h1We855AwhA27nuYTyXNIGI2NzsZgY7KxyPAc4jejXqydhrChbFQ2Ghs2cs27yhPK7jdPKGFwj3pC8Vt4P3Q1jcpGY6Oz4VfqU8xTTRgLhhdvp+FX2twQNpQNb8Fwo7HR2fAWTDcmG4sMTzW2LVW8gntY8XnxEu5hu0rFa7iHbRcVL+JOo7FhOrZDVLxeOwzPO2EUNlzH+8BvV3wqe3F2GoONSYbfoYRh4exT2auv02hs+P6yX+k+oWsbk41Fhh/YE0ZhQ9hQNiobdgnd+9rvQ8JYZPh9SBjeVT70fh8ShrJR2fAr3Q46G4ONycYiww/rCKOwIWwoG6bjv+i6T+/bhl+pj4+nmm14qgmjsOFX6lPZU00YlY3GRmdjsGFX6reGuk/yc2Mf5beNwoawoWxUNhobnY1Bhqea7h3iqSYMYUPZ8CvdDhobnY3Bhl+pd6If7eHGPoQ2jMKGsKFsVDYaGzam9vZC8XrqMDyhhFHYEDaUjeqHV97YgB04gBO4Eu/0Mr1pd3IJFKACK7AB/Yosj3kR9LAN5OJV0GkoG94/22hsdDYGG5ONRYbnlzAKG8KGssEtqNyCyi2o3ILKLajcgsYtaNwCzy+2hFu8gDqNzsZgw3u0urHI8AelMAobwoayUdlobHgLfCL4TU4Yk41Fhmee4UPvmScMYUPZqDT0nnnC6GwMNiYbiwy/yQmD59vk+ea3MvYqTvEC6jQGG64z3XAdywheQJ1GYUPYsCudHo+eecJobHQ2rAXTG+o3OdOHxG9y3PBq6jQKG8KGslHZaGx0NgYbk407N1gwWy11YAHeuUEcFViBd264HDtwACdwJVom2liAAlRgBUJNoOYrMZ7jvB56WGlD8U+5D9tCKP4t9zQaG50N87bctT8ELe8MX1UJo7LR2OhsDDZ8/1ndWGTsne9tFDaEDWWjstHY8OtZbgw2JhuLDM82y+eFZ5swvAXdDW+Bd5VnmzAaG52NwcZkY5Hh2SaMwoawwS24s83ysb5zTWAHjvtTto4TuBLvDLOvzT7GvFGACqzABuzAAZzAlbigtqDmmWT5QFi+mJfPGMsX8/JYs3yxDS9sTqOwUc2obri35sZkY5FRLjYKG8KGmjHcqGw0Njobg43JxiJDLja8BeqGsKFsVDa8BdONzoa1wDdnvMI5jUWGPSGlUdgQNpSNyoa1wFffvdI5jcHGZGORUS82ChvCxt0CnyD7oOPNjbgTD+IJbq7gQ9v8SrobjQ2/R7rcGGxMNhYZ+7DzbRQ2hA1lo7LhPebToXuP+Wj2Rca42ChsCBvKRmXDr3S50dkYbEw2rAW7oXaHkkZhQ9hQNiobjQ1rgS/ueXHz9HtLL25OY5GxLjYKG8KG0pguHu3Fo706G4ONycaCMTwXhVHYoFzkpyqn0dkYbPiVWlQPzkWDc9HYuWgb3qPuwHNRGJ0N79H9byY7oGw45GKDWyDcAuEW7Fy0jcZGZ2OwwS1QFvUk44+RXuCcRmPDL266MdiYbCwyPMn4E7cXOKchbCgb1gLfzfHjk6cXKHhNcxqLDLulmb734DXNaQgbykZlo7HR2fAW+Axpk41FRr/YKGwIG8pGZcNd+5B4dvENHK9PTkPZqGw0Njobfgk+JJ5dwlhkeHYJo7AhbCgblQ1vgQ+jZ5cwBhuTjUWGZ5cwCg2wZ5cwlI3Khs/R4cZCj3rhcRqFDWHDXPtmjJcX70708uI0Jhum45sxXl6cRmHDdHxfxMuLw0GpbDQ2uAWFW1C4BZ5QtuEJJYzChrDBLRAW9XUXfyjxuuEwfF03jMKGX5y6QU8oXh2cxmDDLsEXK706OAxPG2F4J/r48DPS5Gekyc9Ik5+RJj8jTX5GmvsZaRuLjP2MtI3CBregsahnCl/19vLfNBYZnil81dsrg9MQNpQNmyG+aO01w2l0NgYb1gLfwPHK4On7L37SchrKhun4jokft5xGZ2OwMdlYZHhCCcNb4DPEE0oYykZlo7HR2RhsTDI8U/jOjBcDz+Yd78khjMHGZGPB8GLgNPwSphvChrJR2WhsdDYGG5MNb4ENoxcDp1HYEDaUjcpGwwB7MXAag41JhucQ35j0Kt/do17lm0Zjo7Nhrn2rymt5oxP9YScMYcN0fN/Ka3nTaGyYjm9VeS1vOphs8DBWbkHlFlRugd+HhFHZaGx0NrgFlUX91sO30bxId/oWkhfpptHY6GwsMjw5+H6S1+Km4d5c1FOA77J49ez0zQuvnk2jsuEt8OnigR7GYGOSjgf6/l880MMobAgb9gTmj9BeV5tGY6OzwX3g9wf7sv3+IAzuHf9ugy/K+DnJ07c1/KDk6VsKXj2bxkpDvHo2jcKGsKFsWI/aGrF49WwanQ1vgbrhLahueAuaGR71tswtXj1rX0u8DWFD2bB3Vfs2XGe44Tr7f1lkeKCHUdgQNpSNyoZf6XKjszHYsBbYGqp4teyc3m+eHKb3jieH6b3j73t3d+AvfIdR2bBXu5tfKT6yexuLDE8B07vXU0AYdqVz/zVlo7JhVzr9sj0FhDHYsCtdfqWeD7bhDylhFDaEDWvB8j7wTBFGY6OzMdiYbCwy/NYjDNfxyeefFW1+Cb7qsbx3fNUjjMKGt9rnqGeXMLzV3m+eXcLobHirXdSzSxiLDM8uYRQ2hA1lw1vgM8RvI8LobAw2JhuLDP9SzO4de/pYlw+WPX2k0djobAwzfMZb3kljwfDC2TQs6u2uRsr+PPc2lI3KRmOjszHYmGRYdlm2niteHpuGslHZ8CvdDjobg43JhkVjdQf+Se8wChvChrJR2WhsdDa8R21ee61sGoUNv9LmhrJR2fAr7W50NvxKhxuTjUVG9RZMNwobwoayUdlobHQ2vAXLjcnGIqNdbBQ2hA3ra9mG9ah4V/n3jW1FRvzI4zQWGf6J4zAKG8KGsmFjKj5y/p3jMDobgw1rgfj4+LeOt+EfOw6jsCFsKBuVjcZGZ8N0ineIZaRV/BIsI6UhbCgblY3GRmfDxrR4CrCMlMYiY11s2JUWb6h/OjkMZaOy0djobAw2JhsLhlfeLnujRLzyNo3Khl+putHZGGz4lVY3FhnFr9RFPVeFIWx4C7oblY3GRmdjsDHZWGT4pyNse0C8QDcNYUPZqGw0Nryvlxs0q7wMd88DL8NNQ9hQNiobjY3OBs0qL9BNg2aVF+imQbPKC3TTUDYqG42NzsZgY7KxZ9X/+l//5R//9t/+j3/+j3/9b//+X//jv//Lv/zjn/4z/8P/+Mc//W//+Y//55//+7/8+3/845/+/X/+27/9l3/8v//8b//T/tL/+H/++d/tz//45//++l9fl/wv//5/vv58Ofy//vXf/uWm//Vf8K+vr//pXTsc//yuCdZ08fo1/cVJ+drJvF+lNBevp1g4GPUXB3JoxXUPgTfidWf2pYvThfgnwdzHveX/5YXUr53Ue9HNXFRqxSi//Pv29b/X+7HN/r0uQQPaeHwVKhou7tLPr4djfO3kvt3d/YB//xrZh//8dRHRka9nK7qM8ms/rIOLmR7oEn4bzMO/t2P+7N+/tn3z3+v1az+Ww5S8C7yiF1qZX/uQU0fcG0G7I4Z+6ePUl7Y85C7mXF/2ZTlMylc2jfB6pUKaEdp+9XGamJrNWOjQ113G8wtZ8HDNry/k4KPZoV3m44Xw0X/NVvfe8dfDej+g7GFt8qWLw9yyUjrzMDlZtfbYg+2WuIdevvQgh9n5+sHPIb0DO4NUfnVxmJy2lOWNWOPrRuhhSEvN6X3/u5zevb43HuPr8TjNCnu73GfFuNZXLu5Q/LI764yU9/oJK1+6GB+P6fx8TNenY6qH349XaMZ4vJ5y8Bv4evp4fiH2Bdh9Ia18dSF6mJyC/H996eCcKlbPSUG/Yr+NqNbPs/fJRxWJC6nSv/4p1H78JZIMEeqN1938rz5O3TFjRPrVyEN5PjHsBnzfo4325cTQw/Rc9lFX99EuThi/tqMe2iF2fIRPriGUMP5gTEYE++t2bXw5JvV0vzlb3mW9HnrIx2+3iof0eX9OC7mvNv5NnL96qZ/Pjto+nR3na7Fzq3czeltfX8s4JY6BDEg3O6+n0199zI/nx/o8BZ77Y1XcPi6+ZfqtP1o5/cCOK39gB/fHbz5OmdQK6nd/TMx2nb/Oj6aniMkf+io0T//i45RNJSfIa1Xq+tpHO93IamTT+5H6ax/9+LyakftLRp7PJ8jDVNjm56mwrU+n+nlgV3RGVUpjv3doP01SO551/0zWrydHl88HtuvHA3vsjpUPSq/b0q/naG8/0B39B7pjfN4dx5uwDHuZ49CMwxxt14zHvlbo5+kvIXtqx+qad4PX1+0Yh1nae7ajj/J1Gjwm9dcNYTi5S8PHl0l9HLx0yajtKv1rH6dbmHJl3BaR93wM3AZNukv/i49+ehTOX7nx+j/0avltXeAwUUfNH6jRpH3t45BNFXFLWey1Vvyrh1MuLQshRw+Rv/uYh1tT+x6pT3W93vOw8kastK+v4zS7VGNUX6twX8/Qqadnp5oX0vubPuwt1P38NeQ9HxMP9vP62sc5Zu2gsx2zr6Wbr1vy8ePTsR2j5ELeXZr+9Q3hXKc1aqvZ22uzc1xf/Oavjx+gjpkDy/V1URt+v5Iln2eOpZ9njlU/zRyrfZ45Vv80cxw9PMoc5xk6sZEzVvs63tb6NFJOs6vZBx/3HYPU96L+deeSdz+zrq8frct1uvFQPDvxsreU39Z6L/003s7tqLmd8bqru75sx3HFYuRMf21rzy9XLMp1ujG1j0rvddJfsvrvTsYpfeS6Wp2/OBnPnbw2GjNkKu9y/cXJ+nztpJTr0xn/TbfOnCJdyptjYx/v2E5OY1NOT0DXzLEpv6zitD9pycT9urRDS9ppI3Pl73b9Zb7+1pLST7tWmUtU53jPyeM+Oe9zPJ1q62+danphb/aab6YBvXLT5rUHNL52ctp/KkuyX1+81peZ8dQS+yLjHuBT5Mhpf/Qa2K/45c5Mf3NymK+j59WM8cta7h84mT23C2b/5ZnsdyfjB6baaQ/n4VQ7RnClO95yCL7TtoNYqU/szPWDk3L87ctcMgYP8G89ctySevg7fkxHuTH2ovFm8GmuHOpr/e5rJ9o+rK84N6PmDfxryUsPzTguUmFBRZXne/0DJ6tm+F7zOjg5remOXOtag55pfn+WKKe9qTVa+qDFVNU/acdAO2gL5K/tOKbWkUFz8aLbX1pyKjEomdCEF+z/EjTH3ak+lB6/e/sqbE7bU9Kuljmg1UNL+nGWLMyScejY8flTazntUD19bC11ffrcWtr1+YNrOW1RPXtyPbt49Oh6/gVvuVL0ug0+/G6edqjuN9tyhtDv1e+lKKcdKsXKyPV1AUZpx8X/krUoMioF72+/ve2UE+/PjkTc3V8d+XKD6ZhaX4OQXVLLIT+3n3jK6p8/ZR3TyMzizNdjiX6dRk47VbXkY0kVniTP26EFv5yv9Hxox2nGd6T4sQ6/V6e9qsfp7LRZ9TidnXarHqazPn8gnR23q56ls6OLZ+nseNPb8/bsddd5uOkdcixBQCVwW/RI8ttcHcfFK6WYkUNLjgU3BUVQXNb8e/3paJ9n59N21cPsPMYPZOfTdtUfZOdjIpHc69Ff+vX3RHLacuK9ZuXN1d/Dd5YfSCRTfiCRnPaMHiaSWX8gkcz2cSI5uniYSMZx4TgXsNs6PBrN01JAlWhIa9Qffwnf487Vw/A97Vw9DN9VfiB8l/xI+B4rVFvHLuuXNcfHZ7SKzc06dH2ZAU6r8aipr/x89pe6/HVcEMx1K31NyK/vv49O5MrVEVE5OPmJ+v4fKPD/vML/+oES/+vzGv/rJ4r8H4/Kocr/8fTg18z+aI6VrIpSOSywynVeYH30apBcp5KVh9Xl58tpPRfiT+vFctrAGiO3a15Yv8zvZyd2hp87eW24HpzIx8Erpx2sZ8F7dPH09Zz2efCe9p0eBu/pN+Zp8D4flXEYldP0WLk5ORbX3P8+PeR0q/rwLZ3Ti1MPx/a0cfX43Sv9eGxPa16P39Q5OnlYyiynt6ee1jLLadfq2fbKNzko60RfS+dvJrJZFhLI+PphVU4P8PdZ4rnhRA9Vv78veU7uqEbWNb6+qRL9gZSqn6dU/Tyl6g+kVP08pepPpFT9PKV+Mz1ykahevywS/TY9TjtWT6dHLR9Pj/p5Vj6VfD2dHqfdqofT45vF3WfT4/GovD09sBJyXfO92+V6lSx9ueppjp0WRJ+9tS3tB+Zp+3yets/nafuBedo+n6ftJ+Zp+3yefjM7Hi2DfOPj0cu+0s6zNB5g2vrloIXfpvppl+oH1mPale/Jve6lvj4nQU67VN1+BX3tsOrhJub0QpWdExSLXNeX9zDHs2FKzXJ1USo3W789KZ92qZ6+ayunXaqn5a9nJ82eT/aEF/26OFlOO1WvxXoUrZX61a3u0YXiwZ8LG39zMa5PdzK/64+HbzDLOL+imgU8rxWILy9GPt9jlmPl+aM95qOLnvWmXdabLvI3ptMv7l9dHLf+LsU0lUNvHLtUFs31g5Pjsv+zIs9vptnTl8tlHguanr1dLvPjKsBzOyR/JH4prPprO05OWk4T4bOq/uLk3LFjYIt4Xu3Qsf3jfHZ08SyfnbapfiSf/dIfRQ/5/ejm6cv/so5v/1dUWVPZm7zvZP6Ak67vOnl2mIEcX7Z6eJqBHJ9qHh5nIGsctyMenWcg61yzghrLq7/p5OHb4nqdj/F78rr4Nw3Jl65eON69mjyS4HUTe707ONklL+zvOsEOjej4ASdVDk5Os/7hC/B62rXqV8Zfv1Z5M3QenpCgp9eunh6RoOX6PHTOTp6GznF/5OGJIueGPAudb5w8C51vBqfTvmT5CSftXSeTjpEcbzpBXf9rf0PedGIHze+VeHm3T/DTpbzN+oGT+e7l5OkROsu782TmC5g667tDPHOfRHnX+E9bkvNk9reHOE/DeOF6NwBxdyKnIT46UTxhaNG3nVxwUn/AiejbSWnBybvJXvFuq7b1Ay053lkc7x2fnZik+gNnBOlpL+vxD6D+wElDqvPzH8BzQx7+AJ6dPPwBPA/Owx/A507au04e/gAenTz9ATy/LvjsB/B8F/vwOCmtx+VxnCd1rf7erXDTrPBtfIzTn91PPzxR6vHlnI7Hev5kPb9+PNf2eVWLnva2VPM1LOWjrf7akMP652h5ctBoXMXxu4/jadUTy0m8Rfbbya3H97AWnUHLpw/97uNUKViuLHt+MZfXzj/p1twi++W1YfkzJwtjsw5rOMeVrV5yltzfBP96ZUtPRwYO1OmMr3dAv2lI+rgbMg8NOW1xjVzivgotK48/asrTU+H0tMv19Fg4PbXl6blwZycPD4bT0wbV0zdC9PQq1dM3QvS0z/XsjRAdx52DZ2+E6Gk/5dkbIWcXj94IOQ/uw7O7dPzAe4M6+k8M7vh8cOdPDO76fHDX3zq4T4/OOs+QWqIhL5zvOWmaObH9etLFn6TEh2cZ6vEtqoeHGZ6dPDzN8Ozk4XGG31wObhj77G86wctYbbX25i5Xr3mayYvr+25QQ/Aaq/Gum6fnPOrST0sAji6elQCcXTwrATjXuzw9b1LX8Qb22YGTun7gSPZzO3A44f29xy+c1NMe1yo4W6V8ucl8doG7tCUy39pkHpovMr14rDcn/KDiu9HK4cT9q366d3928Wjvvl797927/7U/5INuRel+03ez2kB9xov71zda9bRk+XB0ji6ejU6Rv3l0fumPw43nt6MzyE15183To07r6QWth6cCn1w8+7E4u/iBH4tZchn4xYff4Hp8P+tRHd/RxStD46Zi9Ha952TQb9/o5U0nNEd4r+1Ppv0UrDBMfTubPD7Otsrf70Zk0YkRvBzV3nRS5E0nD8/nrfrxedjndjw+n/d4CGzFKWe9vOfkNR75ztj1y1Lw74Xf7ZisH9VK1+PrWg+PCq6nDZ2nL0kfnTw9b/jopNlRav7IJLO86UTzdZqmMr52Uj+/J6if3xPUj+8JvumN3LZotbRDb5yqpa98beP1I7wOTo6P9/krTOUQf/kI17EZufPYyy8v4/3JtZR8Ueq1vF3edZJLUf318Pa2k5lODqdrn8f34RHd9Xg44E84ef6NtI+XBo4uHt7ttY+XBs698fDtgG+69NnbAfX0Eaynbwd880Pz7PD0s5OHR5bX07bW0yPL6+nVradHlh+dvJ7Xcx/oOhxZXvvnSwP986WB3j//oTntBj888/zs5OHZzWcnDw9NPjvB925fu0VvTnjFa5cvJ4eWfPPW1aODcOrpiMHn93jnDf9Hh2LX8emh2EcPzz47Xsf4iT79gcOF6mnj9LXOirKuyvfNv3+N8/q4T49vJjw7I/zspOfXx8vs15tOHh40Xmf9gd+8k5PVc4Fj/VKj9vtd0dlJju/i72b/qRNNJ6JvOnl4+Hqdx5PTnxy+fnRRLryufPVycHK8mGcnuNf1Aye4H5289iryvKSLizv/6HJmPpSsyS+w/NEAT0y1RcU6f+2T/jc7kYITMYse5sl6WjXbroOT87fcJna05E0nqOoqr5u+N53UPE/i9ZPTvnTSTkcNVrs13mUDvLS4/qBftWeC1Xno13Eu8350Zrl9VODrafLoE/ZHH0+fOtv18ZcHjy6ePXWeXTx66jz3xsOnzm+69NlTZys/8OGh8yx7eLJuK6cDBx6erNuOn9kZ+XRzb4/hYn77GPVpD+nh8TqtHL+N8eR4naOLZ8frtNMnsh6WMbfT1s+z43WanN+YfnS8zvNRGYdROR6bnjfgZa0vj8Zpp0MC6SD59rrfe7Mdj85/bvLx8e3teMpgzx/dF9LN2W/nP5+doPzxheU9J+XCR23q4STqc0ua4kTM/q6Th2diN/2RM7G/c7Po1CF+weOP3Nzrb3lzVfl9oj90k18fu11+fbTluYN1Yaj5nbE/GqWKzXWukvurk+NiWjSk0jEOf02w52MYLyTY+VYy+OUmnN6T/N3H6cjAh8ng/JksfBZu8VP070n61I6HXXoe2nyX4TXK+mYAlktRqffL496fTXl8UfHF4+0ALDgpq/z6C/gn951ZfNh/OXbkj25dczus1y9dfPOQhRpIPhL2Dx+yUJ9apfzA4568u0Ax8ylrzUP1fmsfbw6cXTzaHGit/60uHu4vnDs058erb/uhQw9DWzvaMUr5Ol6On9pqM3+v+vX1TD076VmlcL/P9KaT2VBR1t5tycNVsKOTp6tg55bglbUy5uFyjmVcD1d8zk4ervicnTxd8Tm9nfVwxeebfsWW6Szl3S55lp+/6ZJn+fn54Jzy83m78tnXldv5c1nPFjna59tZ7Se2s9qPbGcdu/Xhp6Lb8WtZDz8V3Y5fy2r5PDB66W86efi96aOTWXJHa+ovL4z9iZOWkTOb6MFJ+/h+4tyOXG+d7XBevi2pftqO8fFNyWkj6tlNybk3Hn5KvK2/28njdfDPX8xqn7+Y1T5/MevcG0/XwdcPVF+19QPVV+eE+PDLu/14+OCzJex+lY+XsPtpD+vZEvbRxbMl7H56n+rhEnY/bZQ8W8Luxw+8P1zCfj4q4zAq18dL2P1aHy9hf9OOR0vYvXy8atVP21dPl7DPTh4uYR+dPF3CPrfk4RL22cnDJexefuSb2d+5ebiEfXbzeAn7OzcPl7DPHfxwCfvs5OES9jGCnq23HgP54RL22cezJez++X5WP+4iPVzC7p/vCnwztM+WsL+Zq0+XsL9x83QJ+zs3T5ewj7eMz5awz3edj5awz/XtOECxH97G6scXqa68X3xNma+ryo9Onq0p9ON5gw/XFLquH1hTOBbrS3arvn7IvuyRs5OBb5KuX47U+qOK/4djc/yG1rOqp6OPp097/fhC1qOnvaOLZ097ZxePnvbOvfHwae+bLn32tNeP32p6WvV0fMOl0ovV5euXU3qTv9nJfapt3jb+8mWy352carEHfijG4Mj7vWOPnyR48v7wuR0LJ4KsXy5G/sRJpVsBfdPJmHj195dzAH53sn4gP58+pfU0Px8v53VrhjNy5fr6ck6p9T5aCCcUjfJV5HznROl8IjoJ8ncn9bjYglfEWz1czrkSK1/MvubX27/9tNHx9AS43k8Vgw9PgOvHL2E9OgGunzaynp4A108Foc9OgDu7eHQC3HmGzDxEQC85JIHTG1nPVp+P7Xhl53zR7bV1e2jH8aYV279jff1aSB8/MVPHT8zU8flMHT8xU+fnM3X+vTNVJZ/1Xnsu8vUMmacbVnoRQ6+v3z7qp/KNxzPktH/1eIYcv4L1bIacNp+ez5D5+QyZH8+Q04/3049pnp3gNuK1RHm4oVk/8J5rX/oTNzTHxV/NO4De+5v3zi3XJO4U+7WT1X+iT8bf3ie5P/C6Fz/0ybGyrq28t3px+fL+7Bsniu/HrfbVmVHjtGUiQ+knXL68nHF8G0tK1ub8kl31dyf68YbHOB4O+GiNcxzfxXq4uD9Ou1nPF/fPbp6vyn83UTpNlPrlRPmR2fZxpcF5mjzbvR3HraRnu7ej6Ke7t0cXz3Zvxzf18U92b8fpxZ9nu7fjtHr9dPf2+ah8vXv7TRJ5tHs75Pp49/acRR5um56dPNw2PTp5um16bsnDbdPvkuLDrcrvkuLDPcbzJT3cYzw7ebjHePzRerYhdpz2D/cYzz6e7TGO04sYD39/VT/fYzy242mXts/3GL+Zq0/3GL9x83SP8Ts3D/cYv1tcxMEV/esDT0e9fmKF8vjrV3DLqO8uLvZ8eBxDvn6fYpw2TVrHwXGdX0D4g3XBXz6OJm8uLo58m+J1Z//107QdgfK3OikdT2ydjuf9Myf4OEwZSw5Ojt91iUkyan/Pxcp1Tr7x/SMX5aIngv71IsVonx97cVxvfaWkXDy6PxgFL+u3CX/8blb2KcKu6h/0aO5BLXl3UHLrd4328biO9mbEae65vgK4vOlEJj4WeR3m+WkP6+HkOPooOBT0dW8132tIKdiU50NB/8yJ4ux1Xe+2pOEHr9F63B866Xgumevdy8GuHn+Y9K9OxseZ7OTiYSbr4wcy2fi7J6viS6Daxpsd8iwRHV08S0QPh+WUiI71I49Kv74pQXlU+tU+LkD75tDZR604n26Ox+9fQvaPjkjv2NzoS990MpHZ19Xec/L6SRhYpD1cjp7WRh8e1n508tqVypOn5/jyUwdHF1j6fm2DjPdcZOD31b50cRyXodjtffsQ/V+c1HedCJzo1+My1sfHtJ9dPHqRbCz5W108fEH+3KH9//fDIH84KrTNs97NINySt53MLGB74dtOsLlydHL89suz3H7+fMyj3H7+KFYu7rw2Wd78rlY+ar/wqwor/bzQWj8vtP7mS4Ellx1GfftLgdiAn1redYKPXM/17pcCZ0NLxrtfT8SHv1/+3v5mYU6ytuT9Pllw8u73cVseSFzbL4WWbzt58yubry34/FRnb+9+77NnyedrVfXdz/3i9JIxytdLdvO0Z1VbztjXldUv10K/a8mjxcN5OkXw2eLh+ZvBDxcPz04ervtNkb/ZydPFw7OTh4uHU9qnj9xHF88euY8unj5yT5kfP3Kf+3RhGYNT2l/nWfuB8NXyA+H7TUueha/q5+E7fyJ85w9Enva/2cnj8NUfWPuf+vHa/9HFw/DVH1j7n/Xztf9znz4N3+PXtq900i75+gZrHt+5kokvnPH94u8+Tg8TI7v1tSU5v/LxzcX0vFvkVZG/Xsz8gYtZf/PFlDwG7YVv3is2vOv022fj/sSJoCXSfsJJL+86mfgK3nW96yQ/9/Dy93bH5mbEC/u7ThRO6tc34eeU9mjN++zi0Zr308R6cHH+yXu4+fbNj++zzbfZ9fPsfPLxdPPtGyfPNt/OTh5uvp2dPNx8+8bJs823by7n2ebbPO1YPbyVOLl4eCtx/CrQ01uJ8XdP1oebb+cOeZaIji6eJaKHw3JycXzGe3YhRxfPLuThk+Yxo5afyKjlBzLq/IFJOn8io86fyKjzJzLq/ImMOn8io86fyKjr84y6Ps+o6ycy6vq7J+vTjLo+z6jr84y6Ps6oev7uZFapve7eaH1nyrtO5ptO5pUnpkz6YvMfOslFIp1cs/5nTvJ1oBeut1uSH0mcXd51koszLzy15Phhsxyd1y9GfdOJ4kAMLfq2kwtO6g84kXdbIgs/nTLfbQnOX9K2fqAl/etpL2t+PsRnJw+H+Dsnj4b4uRN5tyUPh/ibljwb4uctOQ3xPN7sVbww2Xgv/NcXNpZ8XL9ydvGo+GSJ/K0untWvnDtU89dTdFyHDj1WBmR9Av1k/bZIdG5GRQUM39L8tRnj45XRddq3ergyer6Yhs8y8IEJv1/MN05yPVJanwcnx1fp8FJfa9d7Tp6V4Z1dPCrD+8bFkzI8GadKvkdlNGcXj8popB434PNl3te4fvnm6dkHvpPe+PvGv/lYpxVRqVduvtXy5St46/hi1bN3m9fpK1PP3m0+unj2bvOq55can7zbbJPwy2Y8erd51eOXHJ692/x8VL5+t/k8OzR/Wn55Y/WPfDRBClP9enYcT7duqI36+v3ob3w8esf6m2iZyOn0evTvPtrHZ7AfXTyc6eeD4x6dhLmOBwPi0/fXwcPnJ8G/Mv3H8dZOP/cl72x7qV+/APwHTvqbTvCRnl5pt/wvTk6HWD4cl+O1zPylLvPda5GcYp3v0v/QSYZLl/Xu0Ch+sJUPwPpLr56/zp6fvZ+/vHh//YGTK5ep18Unvv2Rk5K1LotXh//MiWTVzXo9E77pRLMYeOk4tOS0dL9qvjmz2vX1G+JrHGsAnxxSem7HyKLkNXiV6i/teOxkvetkYT10tfeclOvqOPvimgc35yHOXYTXrdN8d7JVTLbW33WiqMJvhwB8/gv+5bEV6/xlqnAxxpe/WXL8FuKVwVev+vUHss5OsDJUeVHndyfrdDYgHcb1euT5+u5sts/v/2f/+K7o5OLhXdHpUL+n9yOnT1s9vB85vhf19P7/8agc7v/Ps6Mjq359QMvRh5aBr/2t8a6P62MfitsipZ/eP/PRsWY4v/ZxOhLw6bPM2cezZ5njtVRMstrn5z7enGOvddh807TOL8f29RN2rt7HketyCLtjS0YutunoemhJ/Xh4v3PyA+M7Svn/2838a0OOL94POgWovduvC7uZX8+0cp3O8Xt2zlO5yvETAc8Oejq35NlJT9/8dOeqf9X19WcpX5ejH6/dvZzUj3+8X07ap7/eZx/Pfr5fPsbHv98vJ/PTH/CXj/X5L/gfjM04jY1+vIb3jZNni3jFPkX9YVb7btI/WoJ7teQH5qv8wHyVn5iv8gPzVdbnD/Ll0uvzJ/mXl/Lpo/w3HftsedPPyvtoHe2bfn24aPSNl4dPvt+N8bMn+W+8PFzB+sbLwyWs7/rl2RrWN7P24brPn3hZb3t5tvJz9vJ86ee7/n22bPMnGftw+1f737rmUivu24q+ueZScex4Pay5vC7mB77vVq72Ax8QOl/QyjMxW7nkcEFNfuSC9G++oFbSSSv1eEHt75xureYtfmurn9pxOjEgTxutfAjTNX/3MT//PT22I09z52eev7bjeHbatSZK4y+63el/5GXifNtXarve9LLyWf/FXx4o+02v5PFWdZ1Gp9e/18frKZ2OuZ7l0LP1R3q2/kTPfuPl0VyR4yA//Prdq/uuT8Pn3JCHn7/7xsmzz9990yXPPn/36pL6E+n+dBLC43Tfj58pfvYBvFdTTstcD7+A962XRwdM3+F6etR+9g28V4ieZ8ujj+Dd6eL0nPzsy1EvL6eKl4efjroT0GG6PPp21MvHserl2cej7vR3+Gl/9PWob3w8+nzUNzPl4bfwXi05ndHyqHz43JKnX8Mr12nb6+nn8F5efmTOrh+Zs+sH5uz6kTm7fmDOrr95zj79Kt59A3Dok4efxbu/+fEDM6Vc1w/MlHL6KNbDmVJOm2CPZ0o5fZTj4Uw5+3g0U44/7E+/a/dqyA98xO3l5Qe+4nZ8IOwFnfLrMRp/sP7QMdl6u9abThRvarRRvn40LaX8RNeevsD0M13b8iaw93K8oNNd7cMv5H3r5dFHy15eTucM9bzZH1eX0xWdnk8ffiSvlNN+2MOv5L2cfL59W06vWz39Tt7Ly7Eu7umH8r7x8/hLece5OzQvamg9zV35vIzr5eTzOq5S5ONCrrOPh1trRT4v5Xo5+biWy498+Hgr+PnYjNPYfF7OdXbysJ7rWyfX504e1uuU0zvHv2xKtzc79mFt2XdOHhWXvS7n8zdlvnPybKP+fDk1l1S0ytcb9eV0AuEPteRRpdsfOHk3AJ/WupVvPnP1qNbtu3n/dKL0v3t4HhaqlXZc0H9WqPZdU55VqpX28RcJXz5+4JOE55Y8q1T7/n72yZd8Xy3pP3FXfPLycKnqfDf77GO+r4asH7hTOj3hPr1TOvl4eqd0+rji4zul09lsT++Uev2JO6XHY3NK1Odnnkcf9X1dz/iJ7HhcFH32Wd9vvDz8ru/Zy9MP+37Tlodf9v32Me7hp32/fYx7+G3fb67q4cd9v/Hy8Ou+54ftx3n//Pz05Pu+3zh59oHfUsYPLB3Mn6j8Prbkab+eR/jZR36/m7VPv/L7nZ+nn/n91s/D7/x+s0aaT3S9jEN5VTkV6D/4UOi3G7mPPjf8mnPrJ7aDTzP36QeHv9nIffjVgVdaOT2NPfrswDdbsA+/O/CNl4ffDHhdT/u7vTz99MA3Xh5+e6CU08bYs/Mtzz6eHXB59vH0hMtX1jh9cOPZEZfn/e3HHx9+tUU/Syrnbn10TOY3Ph6dk/l4eE8+zuH38Mje71LBszN7XwOzPp8kRydPT+39zsuzY3u/8fLw3N5vvDw8uPc7L89O7v3uip4d3VvktCf2MLcdfTzMbUcfz3Nb+dun7cPze7/plGeZ6ezjWWZ6OjjHzPRN4eiiG+Pr65uuo5eCD87cNRdfFtTK8Ru6j852PPt4Wp31TbHz0z65fqJP9CeKwI9envbK8VWblSU367Xa8/WDzzdeMGnXPL08VI+z9vkLO/XjbyV/4+PRKY3f+XhyTOP5DJyHw/ONk2ejs45Pg88P0jm5eTY2ZxePhuYbF49G5nyaVh47+cK3DwfLnZau19dHcsl5LeXZC/CvhZbP1/Ll9EbXw7X8o4+Ha/nSrs/X8u0zVx+u5ctxE+zpWv7zsfl6LV++WZh98v772cfD19+l/cCO6zdOHu0piHx81qqcNkqfvtd8dvLwteazk4dvNZ+dPHwd+ZvLefY28vF+7+nLyH/gZL3r5NmryN/0ybM3iL9J889eIJZ+WhR+9Ebn6fSYsbJmafzy7tTv1ZRyPJbv4f6zDPmB36zTJ7me/madfDz9zTq9B/b4N2v0z3+zTvdGz3+zHo/NOI1N+Xz/WU5bB0/3n79pybPqX5mfl8TI8VtFTzefjy15uIV37JKnW6NnJw+3RmWOH+jX+QNbo8eWPDwU65RfZ8m971n4i6fa/uBX6+Fj4zdOnj02/n+1XcuuJbcN/Bevs9CLenxLYBj2xAkGGNjGxF5k4X+PznhM6vSZrq6WdDYXPffCZbUebKpIFiHIjTt9aOn9OCQ3gDE4buACg7mBorIGtndCXr85Rrfe98BHt+yMYwzyKxzdeuuDDrLc+6BjbGh+cGNtytweIS+Oef3eGN2GlO4LEO7eWFZ3KiRLyVsjxCCvahCDvKnBVtLkRY3HaJMY3DUNYfCfGDir5E08btBLixvU0mJ787uwO3WDwhmiWtmdymO0SQxup0rdslM36JphD4IjJWJcVZKPSD3I6V7vHs1YPeiPw0AyBVQrvAsMLtgJW3xyYT00H7FZVN2VjOYD0s5kaXOMYK+ypc0xL7sx6GWytqHLo4TYYUIggrqXeUy8OCLA8g/NF/IyaCiFQzE/nopgUxHiKcZfORHnt92gteL9uZ0p/aAuYb6IiSiN3QH9DQwJQ35OGB2qQ5PB/j5l/ehCDPLoprZ6dBNM6bTU91LOCoRQ2zRup0MEaqfD/UXudIhB73QkYUjvdCSjG5z10g3nnSMhBtl9Ep+WUqx8rDoBp0Xa+mmBGORpQR26yNPCz8iTnunzjKBIb58Dq+WWsZXlLEZdx3jqynnAQGEE30wJbkxLOHQWhhghqwJVGBUdbmFoZgPscCywTtgapneQSQxzP0Is6xjpvHE7Irqz07BZdmMHtwMGav3Eri3EINcWY3Brm6HsYR7cQr8BQyYxTLMg1zKHUYyrKxLmMKpGU3o4Y3I+iqb4P5WQz2PUyXdxVj/uJ/dH1SKbWNPk2laVpumPbXYcuj9qnl1bLWrpj23yzBXzQdDaQirXNFzj8K28ieEMI61jhDhrg6xqItTJcUSbD2nr40C2MGyw62GDXQ8b7LrfYNf9BrvuN9h1v8Gu+w12HUUtnPahFdfylP8hUVUR+yPwg6B/OsgV1XP/1CckRsiG2BLUIrTs236IMxoKyleV8jdKkbEB1QsIvAlVuwmN8b4DS5ZQ1D+0ocvK2IDgBQSXQyervBqLcl5fCM6t6LYf+wSHmyhtEIM63yzwepe97hWfA7rwJr/ax+BiIDkOA6loIAWS/0rbD/LavhwOMuK6v/wP/ro0J38+EIQhUcMHMq7wEQMlIkk2o5RrnsOwrKpHePcUAy9N0iZH/TlNo1STPk8NzMkyyVyXSWZYb+/rUFrU3GmKS0JR7uY1zN2jdmUOI6i72UKoUxRztJYBJZY2t7ZlCB8U8Q0cXhSmImkzjMHRZgnFmDbQZs8zEubn1TpLSJw8ecWY0f6cHVqdsmF1yobVae9dnacZKW56dcqA4k9RkDg4Z9EgAhdMQG/SeV1NA64e2GafkqyGVjBGN4v2tSn5vDvMBUoREy8EyipXKGbpy0jW3NhrNZhLUiM4w1Bz3dek18/+3OocTL+ADoL2o+cpkyA+TIJIsvYjw/rcAumvENSpf7ovHUE2qK5DEPmiGvmXoxXqaArugETNwpE4Km6+XFJQ7gprpyEGaafzhuJpOCF6H5Y0qm2+TAhiXbLTnMTspCEU5EqbmP3AuL7YRzwQK0YdL+Y3X8c0RPqlyU+jaPA3j1ljt1G0T4BvEWx72MLO5J4SAkH3e+47iiGoD6nHOiZcWB6DsHH5VOJ6XB72B0hOk+jT89GR41Bk3SJBDNIilbJukZDWRjFarITx8N0Bycb/lKeGSse3gVqDbPZYqn7D1w8l1GWvJ2dwcL4xkLjlddKO10F5eV7ttA9PvT3TcSholY1wHIxaSTfGkU16tD7d244gbYMdgJmsWd3p9hR0OJpoDKLT2srQVOYuSFSQAFoyJagOY7qLYzprjPFIvyCaXT854UkZ8wiCE9H1Y97qmPlwa06qTWwbqNPXOWn53ShP9YZjSsnL1EKUUb1RHEK5YOqMqAuzKMaz902VZlGS1ix18ybnKIIuPKyaF57cmPWaPjaAeB0KagpIdr7P6z5bXvfZZIfPJjt8NnE7bDXkp8nKf8Fdt7iaQ0FNt8iaQ4hB1hwK6i3ABkQFhbjImkNB7jRdc8ivDaj8h5uELPwXv6F/C2qjSevOQxBWdr5BpXey8B+OhBWdR/rHNzTnIQzdOewKhlWuhzPDCtdDEFa3vkFiitJmQMeHlWaAGKQyg8R1xQuJO5rAwJGQs4pXl9Ssx9uVlqzHMLRi/QUMKViP3RxRT+kpbf2Wp6R8X07nEBeusI6ju3/TDnXSag8/duxacMsRCr45qSvcKmrNK2md38IYHL8lGwqsIAbJkeFJ1V3S5xc0ARCBjXltIMUD3VSI0g+xfruyAzsWo2QNzPgc2yxKFYuyyvRYmnUvd85PotDkBR6L5X35UuEblQ3XdIzCXtMxCn1Nh6Ev8pp+MbmW/FG9n54W0mRfTAtpsvklQighLHPNkne065a8I3CMGq4WUbe4ZD/GBCMPUn1SSasY0iSI6BpXeYpKHNe4rOdw4YGoyHuVp+TJl4Gsiw1gDPKDWpbFBjzK86tZ5X1qFtC7OdRlsg1CcGQbehWabIMgNNlW/QayDVUu0mQbDn2RZBuKfLFkG8Jgyba6ofpAalkn25DgIE+20WsDyDa4SViyDV2OWbINqTrTZBsEYck2yRvINjgSlmyDTglPtmEnlibbLmBYsk3yBrINgrBkm8gyLSRpnWyDGCTZll1aJtuykw1kGxwJO6t5A9mGtytNtmEYmmy7gGHJNujmcGQb9pQoss3H5XtOhk212XtO9rLhngNDX0FLgWO324MPKzdAiqajxfZUrPbSpHU9cu2Xs/YxBOdMw+7RrDMNQVhn+ss7LzvTsGlTGpL2fTlf3gjdeqtoamm8UIc7IGmw0nESpFTT73oqqniZ2brjDIe24QxDwahcrDVXLv58kZEmkY2kO35oVmLYMStQTJDOFoSd01UbMeScwa6FnV/0oxNySecgOeYts7KD14LtCcQ0vB8Xm9NmcKXucKqheGXKVtD71O35GD5LMMfAlrmk80tcThsaauS03lADYpA3/Zw2NNTIab2hRk47Gmrwa1PQ2sBdotxlKOiekbAMhMmUtTIN4tZBili6ewabXiLJXMjkxMYhnbr7frMg2TjhCkB29NfKG/prXbxO0s9xHOMpryNpbx+JncAeQdsAMnsAO+1fFKSCbZ+hWIGpP5eAzBLe9+xGie9enuLtGCOrlCFRVoY7uiBbDYfSTLoM7RSk18MSMcXtIGJyWyZiLjylmM1TktNQVYblXsNGeaDUKRQyWFVkPSKSC6tHjT4ZZbmRBMZg/aTSNvhJqNqL9ZOq3+En0WsDzDTcJGREJKNoFWsa0frSEREIwkZELtr/chEROBI2IgJvXXxE5OLyxoYy4CuxoQwIwoYySl639bIeyoAYbCgD1QCxX9BWdnxB24ZZLRtCGXi70qEMDEOHMi5g2FDGBWNnlY4Z6KAUh1FiHVBOuZwE8wK8NXiMINUW3fRLVu++lABSSwuUlcgmOJDHRMxDqAnxdWOB4lC3GUK7AVI0rbSzS+4cpPi3o3Q319kS11mUUiwhtAWEggguFa0rY2jkFsbQWlHqJIZ3QQn8UezxGygZ0o9UMmiGFUHRLl8uDVpv7bjxUaxH1XKGrLoU78yqxlZamF6ZbO2ZZH11EQY8fFGDZ/0s+0mQUE2c2KH9HtL6DoEg3mRhurdVJ4fifTaB0yqzKNbWrD9Oj0WG1jVDpOguSrbryuDh330ji3yNativKLAPF2nYEAZr2GBkkjZs8e3bNmpI30cps5NC2iWIQdolcnEQBswL4LJPcGoBl32yXnDm1wvOsEic3c6fzu4tpblscnW5xUmQaoZ+zDy5KVcXlJt2AbxOQhl1tOgdRCHbNGMMrk3zBQbVphmuTVEe6MHETC7wE0iaBQkGEsHSFNwNh6pcwBhc5UJBMaodGKzkFpzU/E1V0Zsro4RjKG3WkowjmQapGhXqj9Mg6klAkLb8oWnr35kLDWtvXXTDrA62Xsb741lWElQFp+YC64ozcwG12otXVqI8qY7d0HuvmswnNfpJDGtkUduk7nwVG8es/n3VaEWHm9W/9xaCDdPz0QzjfF1gTwHRgHKSEjdgzPUlSFkd5ZQlTWJoWmMnW8/nFFHpxYq7S/GIx0PxrCS6U/uLpVOK9GIkJKOIezUwjCIMEpKEIsSgmUBYwLUFhecTIQrNJyKlFfbajTDYazcUXaKv3W2DBhye2GZ8xmjUjkNBA+EPcZP1Q3wxEvIQt+WwQJP1Qwwx2ONXnXs3Cn2IMQp7iKtbDwpADPIQQwz6EFe3ISiAJ5Y8xLBTkVMMceHcy+ojQUmEoZr8/egzHkEgYVR0ZnvYsp6B4LfRxnYyciOvb4M0B/m3ie99G6/Zt/1xzmuUqEkYh54CNzCCjSPIBozsJzGq9UdwbhKj6I0g1Nk51cCERHBmMEY0jJTQuVuPx2EMjvdmDSvAgJ89MhyHP79kNK4iNoE2zVCigo3GXaCQ0TiMwkbjMAobjbtAIaNxF29ERuMqil+xHgXCYD0KhMF7FPHt25aNxuFJIa0SxCCtErk4MKIH731kZBFikJFF8v4JMCA7QFpYzFKwFjbt2Kppi4VNWyxs2mJh0xYLm7ZY2LTFwsoGCysbLKxssbDy9m1LW1jZYGFlg4WVZQuLW4BrYttTadK9NuIjRp3DqM7qkvxka/aqBFKsabKtetWK5/7YZseh5V41z7ZVV9KmP4JxwEaBui79w5HmMKL2uO1frTiL4QwjrWOEyXGEZl/PUCfHEW0+pK2PI5/vdZH1tRVZX9sLDGptaYwwOQ5ybfE4uLWlxwHWFn2jOnetnuKo1ROOfadqXU9jwRhcCkqt+b0YZM9hWMZk/U5jcWhOEc/KNKGEw0iWBzP6MK/DgFqELEGKgjYkQQrfRkzFuhOMp2+DMZSYDJLBjETUMDVYR+kO6CZRyKQ8jMEl5V1gMEl5SBuES6iBCFRCTVxO6onLST1oJlsT9bJbPVexxxjmZbdRZf1YCRYDDD47EzVwrsokDrtHIQa5RzEGs0eR5lILmmDUgoyVpe4GRrT0NSnnGG19j2AMdo/4TXvEb9gjfsMe8XN75Pv+jx8/fPz8w6dfP/z4+8dff/lv/+/+fEB9/vjjT59+/vrPf//xy4fhr7//77e///LT54+fPn38zw+/ff71w8//+uPzzw+kx9++c19//NOHR+93/3DJvv/Hd7H/pvMhEvqz//rnvvCPn+XxK//lVw+S7vFTvv/zMcj/Aw==",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "11591029387631908977": {
            "error_kind": "string",
            "string": "Function _emit_success_event can only be called internally"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABEgnAgIEAScCAwQAHwoAAgADAEctCEcBJQAAAEElAAAAdicCAQRIJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEAQEnAEUEAScARgQEJiUAAAVkKQIAAgANrZ10CioBAgMnAgIBACQCAAMAAACbIwAAA1otCAEEJwIFBAUACAEFAScDBAQBACIEAgUfMABGAEUABS0IAQUAAAECAS0OBAUtCAEEAAABAgEnAgYEAC0OBgQnAggECS0IAAktCgUKLQoECwAIAAgAJQAABYotAgAALQoKBwAiB0UJLQsJCCcCCQQKLQgACi0KBQstCgQMAAgACQAlAAAFii0CAAAtCgsHACIHRQotCwoJJwIKBAstCAALLQoFDC0KBA0ACAAKACUAAAWKLQIAAC0KDAcAIgdFCy0LCwonAgsEDC0IAAwtCgUNLQoEDgAIAAsAJQAABYotAgAALQoNBwAiB0UFLQsFBB4CAAUBCiIFQwcWCgcLHAoLDAAEKgwFCwoqBwIFJAIABQAAAbgnAgwEADwGDAEeAgAFAAoqCwUHJAIABwAAAc8lAAAF+ykCAAUAt3xg2S0IAQcnAgsEBgAIAQsBJwMHBAEAIgcCCy0KCwwtDggMACIMAgwtDgkMACIMAgwtDgoMACIMAgwtDgQMACIMAgwtDgUMJwIEAAAtCAEFJwIIBAYACAEIAScDBQQBACIFAggtCggJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECS0IAQQAAAECAS0OBQQnAgUEBS0KBgMjAAACgAwqAwUIJAIACAAABSAjAAACki0LBAMnAggEBQYiCAIEJwIKBAMAKggKCS0IAQcACAEJAScDBwQBACIHAgktDggJACIJAgktDggJJwIKBAMAKgcKCQAiAwIKLQIKAy0CCQQtAggFJQAABg0AIgcCCS0LCQgnAgoEAgAqCQoDNw4ACAADJwIFBAAnAggEAwAqBQgHLQgBAwAIAQcBJwMDBAEAIgMCBy0OBQcAIgcCBy0OBQcnAgcEAwAqAwcFACIDAggtCwgHJwIJBAIAKggJBTsOAAcABSMAAANaJwIDAlUnAgQCbicCBQJrJwIGAm8nAgcCdycCCAIgJwIJAnMnAgoCZScCCwJsJwIMAmMnAg0CdCcCDgJyJwIPAnsnAhACfS0IAREnAhIEHAAIARIBJwMRBAEAIhECEi0KEhMtDgMTACITAhMtDgQTACITAhMtDgUTACITAhMtDgQTACITAhMtDgYTACITAhMtDgcTACITAhMtDgQTACITAhMtDggTACITAhMtDgkTACITAhMtDgoTACITAhMtDgsTACITAhMtDgoTACITAhMtDgwTACITAhMtDg0TACITAhMtDgYTACITAhMtDg4TACITAhMtDggTACITAhMtDg8TACITAhMtDgkTACITAhMtDgoTACITAhMtDgsTACITAhMtDgoTACITAhMtDgwTACITAhMtDg0TACITAhMtDgYTACITAhMtDg4TACITAhMtDhATJwIDAAEKIgJEBCQCAAQAAAUgJwIFBB4tCAEGJwIHBB4ACAEHAS0KBgcqAwAHBelJQ+ibN90sACIHAgcAIhECCCcCCQQbLQIIAy0CBwQtAgkFJQAABg0nAggEGwAqBwgHLQ4DBwAiBwIHLQ4BBwAiBwIHPA4FBgAiBwIJACoJAwotCwoILQsECS0CCQMnAAQEBiUAAAY/LQgFCgAiCgILACoLAwwtDggMLQ4KBAAiA0UILQoIAyMAAAKAKAAABAR4SAwAAAQDJAAAAwAABYkqAQABBdrF9da0SjJtPAQCASYlAAAFZC0LAgMtCwEEDCIDRgUkAgAFAAAFqSUAAAajACIEAgYAKgYDBy0LBwUtCAEGJwIHBAIACAEHAScDBgQBACIGAgctCgcILQ4FCAAiA0UFDioDBQckAgAHAAAF7iUAAAa1LQ4EAS0OBQItCgYBJioBAAEFoNub0O7p2HE8BAIBJgAAAwUHLQADCC0ABAkKAAgHCiQAAAoAAAY+LQEIBi0EBgkAAAgCCAAACQIJIwAABhomLQEDBgoABgIHJAAABwAABlUjAAAGXi0AAwUjAAAGoi0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAaYLQEKCC0ECAsAAAoCCgAACwILIwAABnQnAQUEAQIABgIGJioBAAEF5AhQRQK1jB88BAIBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "nZjRTmM5DIbfpddcJLETO7zKCI0YpjOqVBXUgZVWiHdfO7Fd0CpHnd7gLy7nt+O4SU7fdz/3P95+fz+cfj3/2d1/e9/9OB+Ox8Pv78fnp8fXw/NJvO+7pH9ygd19vttlKNPWursHtX3ahmZtTDYmGzPt7lFsz2bbsCUls2i2T5ttnHl338Rq/GFpWshm67SYzPq4T1vlua6Wp21l+pvpkOmQPUf2HKNZG3eL32noQCpm2/BDzmar2fkcWN5Q5jwAbAwzPmCeOtimrXMeUE2nmk6z5yxvoGLWxmzxWZ7LSaAnB5lJRgWRyvI/qLWewPMjzOCgHhYY662ghZ7QDLTUJStIrFIENOkJbKDpFhXUPCc0A810gnu6e7p5qnbFBHToBhkc2KAUBzKA7OCCI2dSqA7doKKDe5p7mnsIHMiAi0MzGLMYYCFaSg7oYIItg4MJtmKCbaQqdW6jmNITTXsWkgIZkHvIPewezWeA5jPBPJSyQzXIyQEdukFxT3GPtu4EC0rogtq9IOtONTtUg5Yc3KNfOQCFZsDuYfdo906oEzglh/B0g5H8ADbQ7p2gniowkh9ABlgc3KMFB+kW1u6d4B5yD7mH3cPu6e7p5ukJHNyT3ZPdU9xT3KNb7AQyQPege6p7ajMYdR5QHbrB2IsHeAhPvrMLdhfsJpjTaJdJ1SmnIAzqTj4XIXby2QiRE4YyRrQayjWi1VBuEa2FMkU0CmWOaBzKPaJ1V84pBWGQR8u+SkIeLZcS5NEy5CCPljGUMaJhKNeIVkO5RbQWyhTRKJQ5onEo94im2zzQoG40DtVJuQSRU8lBzQnCpwfrJGQnPUyNwtfC10KZQoVChVNQ+Hr4IvsS2UOCII8GYx48iJxK+MY8uhKkuXcKYVB3wvAhO+ncjMKnG69RMxoHI6ZBeqXRu9A4I42ak8Yw0itNUdLVNwqf1g9hEDnp6huFj8PH4RuXqUlSU9Q+GEenUfi0n43YSauG+PFxt/Pb3vfX836vl71P1z+5FL48nven19396e14vNv983h8G//05+XxNOzr41k+lYrsTz/FiuCvw3Gv9HF3eTqtH8WU/WlMkEOg87UK0spoCqVwWymUtYLcv5pLAMoBGRqtX50F6K1oZgH9pnkQeyXkIsorhbpW4O4C/dMcQGpyrQBxCPBSgNYCsrX2ahJ6SlxWQ76UX0R4YznkOV8NedW4SDS8No9rJdJWU+hmYj3R62o5ct4qZweTYM6XnpBz7KvGRm/mLpu2V7SXsuzNDBtzkTefqEdpmJci25lgumTSy1KkblXV2wPlzAiFeltNS1rXdKM7qLmE3EJDAcv1SXCUk/lTk/8vib5RTk7kO4Ywp1U5y1aTFnlxiYWttO6Oa0uKvJ5N3tzGORa2XVqj5q9z2WpSeWnxqdCn3qByvQQRhERfS2w0KCL41w2xLXtc138pQRRNLqVdbj6bGpxDg3O7TaODV0NernmtcW05aLlvbEvEySgSuJKAje4C4Mt+Dkx0wwEt7eUzEew3HNBSt/iuUUorBb2RLyXkNuZ7qHC95aaBUOLGBJWWaWx0BpXY/y7bH/xFc9bIgD9l8HfNGbsfdm63nNCtenu3isvbypZAbDiU2k0CfBGgmwSad1QjvkWAijc1IXwVeJDh49Ph/OUH3Q+VOh8efxz3Nvz1dnr69Onrvy/+if8g/HJ+ftr/fDvvVenyq7D8+QYSXm7MD/IDo47kd0W5Xjzo27YMC8NdYdZh1k9rvpMXrYcPTe0/",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    },
    {
      "abi": {
        "error_types": {
          "11019205087382408538": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "12087256528359734805": {
            "error_kind": "string",
            "string": "needle length of size 0 not supported"
          },
          "12480987221041334580": {
            "error_kind": "string",
            "string": "URL check failed"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17568106868988118403": {
            "error_kind": "string",
            "string": "substring not present in main text (match found if a padding text included. is main text correctly formatted?)"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "5899151545213940874": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 31 limbs"
          },
          "7499498444266164243": {
            "error_kind": "string",
            "string": "No allowed URL matches the request URL"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7688826323084302732": {
            "error_kind": "string",
            "string": "utils::search could not find needle in haystack"
          },
          "9752593157046867219": {
            "error_kind": "string",
            "string": "haystack length of size 0 not supported"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "public_key_x",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "public_key_y",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "signature",
            "type": {
              "kind": "array",
              "length": 64,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "request_urls",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 200,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "allowed_urls",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 200,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "data_hashes",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            "visibility": "private"
          },
          {
            "name": "plain_json_response_contents",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 1000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "business_logic_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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pjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkM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GJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAamMDCFgSkMTGFgCgNTGJjCwBQGpjAwhYEpDExhYAoDUxiYwsAUBqYwMIWBKQxMYWAKA1MYmMLAFAam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le6s0l1QuitKd0PpbivdfaV7rHTPlO6V0r1Vug9K55WIdyGVzk/pwitdZKWLrnSxlS6+0iVWuuRKl1rp0itdZqXLrnS5lS6/0hVWumJKV0rpyildJaWrpnT+SldX6RoqXYDStVC6NkrXQem6KF0PpeujdAOUbojSjVC6MUo3QemmKN0MpZujdAuUbonSrVC6NUq3Qem2KN12pduldPuU7qDSHVW6E0p3WunOKt0FpbuidDeU7rbS3Ve6x0r3TOleKd1bpfugdF6JeRdS6fyULrzSRVa66EoXW+niK11ipUuudKmVLr3SZVa67EqXW+nyK11hpSumdKWUrpzSVVK6akrnr3R1la6h0gUoXQula6N0HZSui9L1ULo+SjdA6YYo3QilG6N0E5RuitLNULo5SrdA6ZYo3QqlW6N0G5Rui9JtV7pdSrdP6Q4q3VGlO6F0p5XurNJdULorSndD6W4r3X2le6x0z5TuldK9VboPSueVhHchlc5P6cIrXWSli650sZUuvtIlVrrkSpda6dIrXWaly650uZUuv9IVVrpiSldK6copXSWlq6Z0/kpXV+kaKl2A0rVQujZK10HpuihdD6Xro3QDlG6I0o1QujFKN0HppijdDKWbo3QLlG6J0q1QujVKt0HptijddqXbpXT7lO6g0h1VuhNKd1rpzirdBaW7onQ3lO620t1XusdK90zpXindW6X7oHReSXkXUun8lC680kVWuuhKF1vp4itdYqVLrnSplS690mVWuuxKl1vp8itdYaUrpnSllK6c0lVSumpK5690dZWuodIFKF0LpWujdB2UrovS9VC6Pko3QOmGKN0IpRujdBOUborSzVC6OUq3QOmWKN0KpVujdBuUbovSbVe6XUq3T+kOKt1RpTuhdKeV7qzSXVC6K0p3Q+luK919pXusdM+U7pXSvVW6D0rnlYx3IZXOT+nCK11kpYuudLGVLr7SJVa65EqXWunSK11mpcuudLmVLr/SFVa6YkpXSunKKV0lpaumdP5KV1fpGipdgNK1ULo2StdB6booXQ+l66N0A5RuiNKNULoxSjdB6aYo3Qylm6N0C5RuidKtULo1SrdB6bYo3Xal26V0+5TuoNIdVboTSnda6c4q3QWlu6J0N5TuttLdV7rHSvdM6V4p3Vul+6B0Xsl5F1Lp/JQuvNJFVrroShdb6eIrXWKlS650qZUuvdJlVrrsSpdb6fIrXWGlK6Z0pZSunNJVUrpqSuevdHWVrqHSBShdC6Vro3QdlK6L0vVQuj5KN0DphijdCKUbo3QTlG6K0s1QujlKt0DplijdCqVbo3QblG6L0m1Xul1Kt0/pDirdUaU7oXSnle6s0l1QuitKd0PpbivdfaV7rHTPlO6V0r1Vug9K55WCdyGVzk/pwitdZKWLrnSxlS6+0iVWuuRKl1rp0itdZqXLrnS5lS6/0hVWumJKV0rpyildJaWrpnT+SldX6RoqXYDStVC6NkrXQem6KF0PpeujdAOUbojSjVC6MUo3QemmKN0MpZujdAuUbonSrVC6NUq3Qem2KN12pduldPuU7qDSHVW6E0p3WunOKt0FpbuidDeU7rbS3Ve6x0r3TOleKd1bpfugdF4peRdS6fyULrzSRVa66EoXW+niK11ipUuudKmVLr3SZVa67EqXW+nyK11hpSumdKWUrpzSVVK6akrnr3R1la6h0gUoXQula6N0HZSui9L1ULo+SjdA6YYo3QilG6N0E5RuitLNULo5SrdA6ZYo3QqlW6N0G5Rui9JtV7pdSrdP6Q4q3VGlO6F0p5XurNJdULorSndD6W4r3X2le6x0z5TuldK9VboPSueVinchlc5P6cIrXWSli650sZUuvtIlVrrkSpda6dIrXWaly650uZUuv9IVVrpiSldK6copXSWlq6Z0/kpXV+kaKl2A0rVQujZK10HpuihdD6Xro3QDlG6I0o1QujFKN0HppijdDKWbo3QLlG6J0q1QujVKt0HptijddqXbpXT7lO6g0h1VuhNKd1rpzirdBaW7onQ3lO620t1XusdK90zpXindW6X7oHReqXkXUun8lC680kVWuuhKF1vp4itdYqVLrnSplS690mVWuuxKl1vp8itdYaUrpnSllK6c0lVSumpK5690dZWuodIFKF0LpWujdB2UrovS9VC6Pko3QOmGKN0IpRujdBOUborSzVC6OUq3QOmWKN0KpVujdBuUbovSbVe6XUq3T+kOKt1RpTuhdKeV7qzSXVC6K0p3Q+luK919pXusdM+U7pXSvVW6D0rnlYZ3IZXOT+nCK11kpYuudLGVLr7SJVa65EqXWunSK11mpcuudLmVLr/SFVa6YkpXSunKKV0lpaumdP5KV1fpGipdgNK1ULo2StdB6booXQ+l66N0A5RuiNKNULoxSjdB6aYo3Qylm6N0C5RuidKtULo1SrdB6bYo3Xal26V0+5TuoNIdVboTSnda6c4q3QWlu6J0N5TuttLdV7rHSvdM6V4p3Vul+6B0Xml5F1Lp/JQuvNJFVrroShdb6eIrXWKlS650qZUuvdJlVrrsSpdb6fIrXWGlK6Z0pZSunNJVUrpqSuevdHWVrqHSBShdC6Vro3QdlK6L0vVQuj5KN0DphijdCKUbo3QTlG6K0s1QujlKt0DplijdCqVbo3QblG6L0m1Xul1Kt0/pDirdUaU7oXSnle6s0l1QuitKd0PpbivdfaV7rHTPlO6V0r1Vug9K55WOdyGVzk/pwitdZKWLrnSxlS6+0iVWuuRKl1rp0itdZqXLrnS5lS6/0hVWumJKV0rpyildJaWrpnT+SldX6RoqXYDStVC6NkrXQem6KF0PpTuY4T+/XX2u9Cmlu6R095XupdJ9VLowGXkXW+mSKV1GpcujdEWUroLS1VK6AKVrr3Q9lW6o0k1QutlKt0zpNijdLqU7onRnlO6q0t1TupdK91HpwmTiXXSlS6h0aZUuh9IVVrqySldd6RopXRul6650g5RujNLNULrFSrdO6XYo3bdKd0rpLindHaV7pnTvlS50Zt5FUbr4SpdK6bIoXQGlK6V0VZWuvtK1ULouStdf6UYp3VSlm690q5Xua6Xbr3QnlO4npbupdL8o3Vul88nCuwhKl0vpiihdeaWro3TNlK6j0vVRutFKN03pFirdGqXbqnT7le6E0p1XuptK91jp3iqdT1beRVS6OEqXTOkyKV1epSuudJWUrrbSNVO6jkrXR+mGK91EpZurdCuUbrPS7VG6o0p3VumuK91DpXutdI5svAundDGVLonSpVe6nEpXROnKK52/0jVRurZK11PphijdeKWbpXRLlG6D0u1UusNK94PSXVa6e0r3Qul+Vzq/7LyLqnQJlS6N0mVXukJKV1rpqitdQ6VrrXTdlG6A0i1SurVKt13pDivdD0p3RenuKd0bpQuRg3fhlS6W0iVWuvRKl0vpiihdeaWrqXRNlK6d0vVUuiFKN07pZindUqXboHQ7le6Q0v2gdFeU7p7SvVC6D0rnl5N30ZQuodKlUbpsSldI6cooXXWla6h0rZSum9INVLoxSjdd6RYq3Vql26503yrd90p3QeluK91TpXuvdKFy8S6S0sVTupRKl0Xp8itdCaWronT1lK6F0nVWur5KN1LppijdfKVbpXRblG6f0h1Xup+U7mele6R0EXLzLrbSJVO6LEqXX+lKKl0VpWukdG2UrrvSDVK60Uo3XekWKd1apduudAeU7nulu6h0t5XuqdK9U7pQeXgXWeniKV1KpcusdPmVrqTSVVG6ekrXXOk6K10/pRupdFOUbp7SrVK6rUq3T+mOK905pftZ6R4r3a9K552Xd+GVLrbSJVO6jEqXR+mKKl1FpautdE2VroPS9VK6YUo3UenmKN1ypduodLuV7qjS/ah015TuvtK9UjpHPt6FVboYSpdI6dIpXU6l+0rpyildDaXroXSDlW6c0s1RuuVKt0npdivdCaU7r3Q3le4XpXujdN75eRdB6WIrXTKly6B0eZSumNJVVLraShegdB2UrrfSDVO6iUo3W+mWK90mpdutdEeV7ozSXVO6B0r3SukcBXgXRuliKF1ipUundDmVrrDSlVO6mkrXWOnaKl13pRusdOOUbqbSLVG6dUr3jdIdUrrTSndZ6e4o3XOl+6B0vgV5F1Xp4itdaqXLpnQFla600lVVugZK10rpuirdAKUbpXTTlG6h0q1Rum1Kt1/pbindE6V7p3S+hXgXVekSKF1qpculdEWUrrzS+StdI6Vrq3Q9lG6w0o1TuhlKt0Tp1ivdN0p3SOlOKd1lpburdM+V7oPShS7Mu6hKl0DpUitdNqUroHSlla6a0jVQulZK10XpBijdaKWbpnQLlW610m1TugNKd1LpLijdTaV7onTvlC7kV7yLpHRxlC6F0mVWunxKV0LpKildXaVrrnSdlK6v0g1XuslKN0/pVirdFqXbo3THlO6c0t1QukdK91rpQhThXXili6V0SZUuvdJVULpaShegdJ2Urq/SjVC6yUq3SOnWKt12pftW6U4o3QWlu6V0T5TundL5FOVdJKWLq3QplC6z0uVVuhJKV1np6ipdc6XrqHR9lW6E0k1WunlKt0LptijdXqU7pnTnlO660j1SujdKF6IY78IrXUylS6p0GZQut9IVVbrySldL6QKUrr3S9VK6IUo3QelmK90ypduodDuV7ojSnVG6q0p3X+leKN1HpQtTnHfRlS6R0qVRuhxKV1jpyipdDaVrqHRtlK670g1SurFKN13pdijdQaU7pXRXle6+0r1Uuo9KF6EE72IrXTKly6h0uZSuqNJVULpaShegdO2UrpfSDVW6CUo3W+mWKt1GpduldEeU7ozSXVG6+0r3Uuk+Kl2YkryLpnSJlC6t0uVQusJKV0bpaihdI6Vro3TdlW6g0o1VuhlKt1jp1inddqU7qHSnlO6S0t1RuqdK95vShS7FuyhKF1/pUipdVqUroHSllK6q0tVTupZK10Xp+ivdKKWbonQLlG610n2tdPuV7rjSnVe6m0r3i9K9VTrv0rxLrnSZlC6v0pVSuqpKV1/pWipdD6UbrHTjlG6m0i1SunVKt0PpDirdKaW7qHR3lO6Z0v2mdKHL8C6y0sVXulRKl1XpCihdSaWrqnT1la6l0nVRun5KN0rppirdAqVbrXRblW6/0p1QuvNKd1PpHivdW6XzKcu7iEoXR+mSKV0mpcurdMWVrpLS1Va6ZkrXUen6KN1wpZuodHOVboXSbVa6PUp3VOnOKt11pXuodK+VzlGOd+GULqbSJVG69EqXU+mKKF15pfNXuiZK11bpxivdLKVbqnSblW6P0n2ndGeV7pbSPVG6d0oXsjzvIihdHKVLrnSZlC6v0hVTukpKV0fpmildR6XrrXTDlW6S0s1VuhVKt0np9ijdd0p3VumuK90DpXutdF4VeBdO6WIqXWKlS690uZSuiNKVV7qaStdE6dopXU+lG6J045RultItVboNSrdT6Q4p3Q9Kd0Xp7indC6X7oHR+FXkXTekSKl0apcumdIWUrozSVVe6hkrXSum6Kd1ApRujdNOVbqHSrVW67Ur3rdJ9r3QXlO690oWqxLvISpdQ6dIoXXalK6R0FZSultIFKF17peuhdEOUbrzSzVK6pUq3Xul2Kt1hpftB6a4o3V2le6F0vyudX2XeRVO6BEqXRumyK10hpSujdNWUrqHStVa6bko3UOlGK910pVukdGuVbrvSHVC675XuotLdVrqnSvdO6UJV4V1kpYundCmVLrPS5Ve6kkpXRenqKV1zpeusdP2UbqTSTVG6eUq3Sum2Kt0+pTuudOeU7mele6x0vyqdd1XehVe62EqXTOkyKl0epSuqdE2VroPS9Va6kUo3RenmK90qpduhdAeV7pTSXVK6W0r3VOneK12oaryLrHRxlS6l0mVRuvxKV1LpKitdPaVroXSdla6f0o1QuilKN1/pVindVqXbq3THle4npftZ6R4r3Rul867OuwhKF1vpkildBqXLo3TFlK6i0tVWugCl66B0vZVumNJNVLrZSrdc6TYp3W6lO6p0Z5TumtI9ULpXSueowbswShdD6RIrXTqly6l0hZWunNLVVLrGStdW6bor3WClG6d0M5VuidKtU7rTSndZ6e4q3Sulc9TkXVili6F0yZUuk9LlVbriSldB6WorXVOl66B0vZVuqNJNVLo5Srdc6TYp3S6lO6p0PyrdNaV7oHQvlc7hz7uwShdD6RIrXVqly6l0XyldOaWrqXSNlK6t0vVQusFKN07pZijdEqVbr3TfKN0hpTuldJeV7q7SPVe6D0oXuhbvoipdAqVLrXTZlK6A0pVWumpK10DpWildF6UboHSjlW6a0i1UutVKt03pDijdSaW7oHQ3le6J0r1TupC1eRdJ6eIoXT6lK6F0lZWugdK1UrquSjdA6cbX5t0spVuqdBuUbofSHVK600p3WenuKt0zpfugdL51eBdV6RIoXSqly6Z0BZWutNJVU7r6StdK6boq3QClG610U5VuodKtUbptSndA6U4o3QWlu6V0T5TundL51OVdJKWLq3QplC6z0uVVuhJKV1np6ipdc6XrqHR9lW6E0k1WunlKt0LptijdXqU7pnTnlO660j1SujdKF6Ie78IrXUylS6p0GZQut9IVVbrySldL6QKUrr3S9VK6IUq3TOk2Kt0upTumdOeU7obSPVK690oXqj7vIitdPKVLrnSZlS6f0pVQuspKV0fpmitdJ6Xrq3QjlG6S0s1TupVKt0Xp9irdd0p3TuluKN0jpXujdF4NeBde6WIpXVKly6B0uZSuqNJVULpaShegdO2UrpfSDVW6CUo3W+mWKt1GpduldEeU7ozSXVG6+0r3Uuk+Kl2YhryLpnSJlC6t0uVQusJKV0bpaihdI6Vro3TdlW6g0o1VuhlKt1jp1inddqU7qHSnlO6S0t1RuqdKF6UR7+IrXSqly6F0hZWurNLVULqmStdB6Xor3TClG690s5VumdJtVLpdSndY6c4o3VWlu690L5Xud6UL05h30ZUukdKlVbrsSldY6coqXQ2la6R0rZWuu9INUrqxSjdD6RYp3Tql26F0B5XulNJdVLo7SvdM6X5TutBNeBdZ6eor3Z3ArmyDdYlmxPUJid1jpXuiLPO50lUM4N2cwO7yg8sFTwXsjIvdXuV4D5XuF6WL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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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Xh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe/V8V4d79XxXh3v1fFeHe818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4fJWmwBO818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXgPvNfBeA+818F4D7zXwXuPyXp9/xiou7/VVGuUzrc5/e7LkVT7Tnn+TIi7v9VU+055//jku7/VVPtOef9opLu/1+ReW4vJeX+Uz7fmHGOLyXvcZfLLkVSblojzT1lluyqacuzxZ0ufbOVnyKp0yKJNyURblM63P93uy5FXO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fXbawnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbvnOGX3HKfsnuOU3XOcsnuOU3bPccoO0ow0e++I1eW9np0W77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++1rEgr0oq0Im2TtknbpG3S9ntHrC7v9eq0sATvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F7LnbQgLUgL0oK0IC1IC9LivSNWl/d6dlq818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXR0kaLMF7fZSkwRK818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzX8iFtSBvShrQhbUgb0pjjvLzXOcv3jljhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b1WMMcJ5jjBHCeY4wRznGCOE8xxgjnOy3s9O229d8QK77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++1kjlOMsdJ5jjJHCeZ4yRznGSOk8xxXt7rnOV7R6zwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4L77XwXgvvtfBeC++18F4rmeMkc5xkjpPMcZI5TjLHSeY4yRzn5b2enXbeO2KF91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaiznOYo6zmOMs5jiLOc5ijrOY4yzmOC/vdc7yvSNWeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivVcxxijlOMccp5jjFHKeY4xRznGKO8/Je5yzfO2KF91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaeK+F91p4r4X3WnivhfdaxRynmOMUc5xijlPMcYo5TjHHKeY4L+/17LT73hHDey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnstvNfCey2818J7LbzXwnutzRxnM8fZzHE2c5zNHGczx9nMcTZznJf3Omd574jhvRbea+G9Ft5r4b0W3mvhvRbea+G9Ft5r4b0W3mvh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XjtgCd5r47023msHLMF7bbzXxnvtgCV4r4332nivHbAE77XxXhvvtQOW4L023mvjvXbAErzXxnttvNcOWIL32nivjffaAUvwXhvvtfFeO2AJ3mvjvTbeawcswXttvNfGe+2AJXivjffaeK8dsATvtfFeG++1A5bgvTbea+O9dsASvNfGe2281w5YgvfaeK+N99oBS/BeG++18V47YAnea+O9Nt5rByzBe22818Z77YAleK+N99p4rx2wBO+18V4b77UDluC9Nt5r4712wBK818Z7bbzXDliC99p4r4332glL8F4b77XxXjthCd5r47023msnLMF7bbzXxnvthCV4r4332nivnbAE77XxXhvvtROW4L023mvjvXbCErzXxnttvNdOWIL32nivjffaCUvwXhvvtfFeO2EJ3mvjvTbeaycswXttvNfGe+2EJXivjffaeK+dsATvtfFeG++1E5bgvTbea+O9dsISvNfGe228105YgvfaeK+N99oJS/BeG++18V47YQnea+O9Nt5rJyzBe22818Z77YQleK+N99p4r52wBO+18V4b77UTluC9Nt5r4712whK818Z7bbzXTliC99p4r4332glL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNdesATvtfFeG++1FyzBe22818Z77QVL8F4b77XxXnvBErzXxnttvNcuWIL32nivjffaBUvwXhvvtfFeu2AJ3mvjvTbeaxcswXttvNfGe+2CJXivjffaeK9dsATvtfFeG++1C5bgvTbea+O9dsESvNfGe2281y5YgvfaeK+N99oFS/BeG++18V67YAnea+O9Nt5rFyzBe22818Z77YIleK+N99p4r12wBO+18V4b77ULluC9Nt5r4712wRK818Z7bbzXLliC99p4r4332gVL8F4b77XxXrtgCd5r47023msXLMF7bbzXxnvtgiV4r4332nivXbAE77XxXhvvtQuW4L023mvjvXbBErzXxnttvNcuWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O99oYleK+N99p4r71hCd5r47023mtvWIL32nivjffaG5bgvTbea+O9dsMSvNfGe228125YgvfaeK+N99oNS/BeG++18V67YQnea+O9Nt5rNyzBe22818Z77YYleK+N99p4r92wBO+18V4b77UbluC9Nt5r4712wxK818Z7bbzXbliC99p4r4332g1L8F4b77XxXrthCd5r47023ms3LMF7bbzXxnvthiV4r4332niv3bAE77XxXhvvtRuW4L023mvjvXbDErzXxnttvNduWIL32nivjffaDUvwXhvvtfFeu2EJ3mvjvTbeazcswXttvNfGe+2GJXivjffaeK/dsATvtfFeG++1G5bgvTbea+O9dsMSvNfGe2281x5YgvfaeK+N99oDS/BeG++18V57YAnea+O9Nt5rDyzBe22818Z77YEleK+N99p4rz2wBO+18V4b77UHluC9Nt5r4732wBK818Z7bbzXHliC99p4r4332gNL8F4b77XxXntgCd5r47023msPLMF7bbzXxnvtgSV4r4332nivPbAE77XxXhvvtQeW4L023mvjvfbAErzXxnttvNceWIL32nivjffaA0vwXhvvtfFee2AJ3mvjvTbeaw8swXttvNfGe+2BJXivjffaeK89sATvtfFeG++1B5bgvTbea+O99sASvNfGe2281x5YgvfaeK+D9zrHzZLBex2818F7neNmyeC9Dt7r4L3OcbNk8F4H73XwXue4WTJ4r4P3Onivc9wsGbzXwXsdvNc5nGtz0pxrc9Kca3PSnGtz0pxrC9KCawvSgmsL0oJrC9KCawvSgmtL0pJrS9KSa0vSkmtL0pJrS9KSa1ukLa5tkba4tkXa4toWaYtrW6Qtrq1IK66tSCuurUgrrq1IK66tSCuubZO2ubZN2ubaNmmba9ukba5tk7a5tiatubYmrbm2Jq25tiatubYmrbm2IW24tiFtuLYhbbi2IW24tiENluC9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0+Sq4NluC9PkrSYAne6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvgvQ7e6+C9Dt7r4L0O3uvg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YBr7g2nsD6axP5jG/mAa+4Np7A+msT+Yxv5gyvntKee3p5zfnnJ+e8r57Snnt6ec355yfnvK+e0p57ennN+elpIrvDLhlQmvLCVXeGXCKxNe2ZJc4ZUJr+T89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPb09gfTGN/MI39wTT2B9PYH0xjfzCN/cE09gfT2B9MY38wjf3BlPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb89nf3BdOGVC69ceOXsD6YLr1x45cIrZ38wXXjlwis5vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89nT2B9PZH0xnfzCd/cF09gfT2R9MZ38wnf3BdPYH09kfTGd/MOX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vT1+SK7xy4ZULr3xJrvDKhVcuvPKSXOGVC6/k/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz29PZH0xnfzCd/cF09gfT2R9MZ38wnf3BdPYH09kfTGd/MJ2/j5NyfnuG8CqEVyG8Cs7rSzm/PeX89gzhlZzfnnJ+e8r57RkmucKrEF6F8CpMcoVXIbwK4VWY5AqvQngl57ennN+ecn57yvntKee3p5zfnnJ+e8r57Snnt6ec355yfnvK+e0p57ennN+ecn57yvntKee3p5zfnnJ+e8r57Snnt6ec357BeX0ZnNeXwd/HyeDv42Tw93Hy5bfnVcPJ4Ly+fPntr9qlDqnleoVXcn57yvntKee3p5zfnnJ+e8r57Snnt6ec355yfntGSa7wKoRXIbyKklzhVQivQngVW3KFVyG8kvPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm/P4Ly+DM7ry+Tv42SyP5jJ/mAm+4OZ7A9mcl5fvvz2V72lbqm5Xjm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2TJdc4VUKr1J4lS65wqsUXqXwKl1yhVcpvJLz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vz+S8vkzO68vk7+Nk8vdxMvn7OPny269+uOBkcl5fvvz2V+1Sh9RyvcIrOb895fz2lPPbU85vTzm/PeX89pTz21POb085vz1zS67wKoVXKbzKLbnCqxRepfAqW3KFVym8kvPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm/PxXl9uTivLxd/HycXfx8nF38fJ19+e151Sg0nX377q95St9RyvcIrOb895fz2lPPbU85vTzm/PeX89pTz21POb085vz1XSK7wagmvlvBqheQKr5bwagmvVkiu8GoJr+T89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPbU85vTzm/PeX89pTz21POb085vz3l/PaU89tTzm9POb895fz2lPPb8+W3X32sUuoldUm9pYaTL7/9qjecfPntr9qlPnP3Vd8+YZ5++12X1Fvqlnqo+5DapHapQ2rJbcltyW3JbcltyR3JHck9/x796Tfm6bffdUq9pIaTcn57yvntKee3p5zfnnJ+e8r57Snnt6ec355yfnvK+e0p57ennN+ecn57yvntKee3p5zfnnJ+e8r57Snnt6ec355yfnvK+e0p57ennN+ecn57yvntKee3p5zfnnJ+e8r57Snnt6ec354l6+0vv/1Vm9R8fkt4VTK+KpkPyvntWcKrkvFVyXywhFcl46uS+WAJr8RvT/HbU/z2LOGV+O0pfnuK354lvBK/PcVvTzm/PcVvT/HbU/z2lPPbU/z2FL89xW/PEl6J357it6ec357it6f47Sl+e8r57Sl+e4rfnuK3Z8n4Svz2FL89i/P6sjivL4vz+rK29CtZvyrZHyzZH6yW5yvrVyX7gyX7g9XyfGV/sGR/sEb6lay3l6y3l+wP1sjzlfX2kvX2kv3BGnm+st6+ZX9wi8+wZf1qy3r7lv3BLT7DlvWrLevtW/YHt/gMW9bbt+wPbvEZtqxfbVlv37I/uPGvcsv61Zb19i37gxv/Krest2/ZH9z4V7llf3DL/uCW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Jrzq/e0vjS+8mvBqBr7wasKrmfjCqwmvJryaiS+8mvBqwquZ+MKrCa96f/tL48t8NZmven/7S+PLfDWZr9bTvusZ6IluTq5now/6ogPdnFxPc3KN5uQaAz3RC93Pu+DVglcLXvX+9pfmeeHVgldr8rzwasGr3t/+0vjCqwWven/7PxpeLXi14NVa+MKrBa/WwhdeLXi14NXa+MKrBa8WvFobX3i14FXvb39pfJmvFvNV729/aXyZrxbz1Tr4HnyZr9ZpTq7TnFz3QQ/0RDcn193o5uS6Fx3oRPO88GrBqwWven/7S/O88GrBqxU8L7xa8Kr3t780vvBqwave3/7S+MKrBa9W4guvFrxahS+8WvBqwatV+MKrBa8WvFrVvhtebXjV+9tfeqE3+qDbdz+BTnT//u6B78CX+WqP5uQeG33QFx3o5uQezck9m5N7DvRELzTPC682vNrwqve3vzTPC682vNqL54VXG171/vaXxhdebXjV+9v/0fBqw6sNr/bGF15teLU3vvBqw6sNr/bBF15teLXh1T74wqsNr3p/+0vjy3y1ma96f/tL48t8tZmv9sX34st89e23f75jtzn57bd/9UBPdHPy22//6ubkt9/+1YFONM8Lrza82vCq97e/NM8Lrza82snzwqsNr3p/+0vjC682vOr97S+NL7za8GoXvvDqwKvztO+BVwdeHXh1nvY98OrAqwOvzoMvvDrwqve3vzS+zFeH+ar3t780vsxXh/nqTHwnvsxX3377+uiNPuiLDnRz8szm5FnNybMGeqIXmueFVwdeHXjV+9tfmueFVwdenc3zwqsDr3p/+0vjC68OvOr97f9oeHXg1YFX5+ALrw68OgdfeHXg1YFX5+ILrw68OvDqXHzh1YFXvb/9pfFlvjrMV72//aXxZb46zFcn8A18ma9ONCdPNCdPPuiBnujm5MmNbk6evOhAJ5rnhVcHXh141fvbX5rnhVcHXp3ieeHVgVe9v/2lB3qiF7p9L7y68OrCq/skXvjCqzvwhVcXXl14dQe+8OrCqwuv7sAXXl141fvbXxpf5qvLfNX7218aX+ary3x1F74LX+aru5qTd230QV90oJuTdzUn725O3j3QE73QPC+8uvDqwqve3/7SPC+8uvDqHp4XXl141fvbXxpfeHXhVe9v/0fDqwuvLry6F194deHVvfjCqwuvLry6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HuiJXmieF159+u0/HWieF159+u0/PdA87+Z590bjC68+/fafTjS+8OrTb//picb34HsOGl949em3/3T//9GEVxNeffrtP73Q+F5870XjC68+/favjgeNL7z69Nt/eqPxDXwj0NnfsQ+vPvrDq68e6Ile/T388OqrT3/fPrz66kAnmuctnhdeTXj16bd/n7F4Xng14dWn3/593kp082o97buegZ7ohW7fT7/9py860IkXvvDq02///vyBL7xa8OrTb//+/IEvvFrw6tNv/3pNfOHVp9/+/fkT34nvPGh8J74T39m/v59++9dr4bsmev19xz799p8+6IsOdHPy02//6t2c/PTbf3qiF5rnhVcLXi14tZivFrxa8GrBq8V8teDVgleL+WrBqwWvFrxazFcLXi14teDVYr5a8GrBq8V8teDVglcLXi3mqwWvFrxa8GoxXy14teDVp9/++/n4Br7MV59++/fnJ76JL/PVp9/+9Up8M9DNyU+//avrQQ/0RDcnP/32n25OfvrtPx3oRPfzbni14dWGV5v3wQ2vNrza8OrTb/8874ZXG15t3gc3vNrwasOrzfvghlcbXm149em3/7zwhVeb98ENrza82vBq8z644dWGVxteffrtXy94teHV5n1w8z64ma8289XmfXDzPriZrzbz1eZ9cPM+uJmvPv32z3fs02//6YO+6EA3Jz/99q8+zclPv/2nJ3qheV54teHVhleb98ENrza82vBq8z644dWGV5v3wQ2vNrza8GrzPrjh1YZXG15t3gc3vNrw6tNv//58eLXh1YZXn3779+fDqw2vNrz69Nu/XvBqw6tPv/338/FlvtrMV59++/fnF77MV5v56tNv/3oVvsxXn3779ztWzclPv/2nB3qim5OffvtPNyc//fafDnSi+3kPvDrw6sCrw/nVgVcHXh14dTi/OvDqwKvD+dWBVwdeHXh1OL868OrAqwOvDudXB14dePXpt39/Prw68OrAq0+//fvz4dWBVwdeffrtXy94deDVp9/+/fmcXx3mq8N89em3f38+51eH+eowX3367V8vzq8O89Wn3/79jp2NPuiLDnRz8tNv/+rbnPz02396ohea54VXB14dePXpt3+fEV4deHXg1aff/n1eeHXg1aff/v358OrAqwOvPv3278+HVwdeHXj16bd/veDVgVeffvv358OrA68OvPr0278/H14deHXg1aff/vWCVwdeHc7bD+fth/nqMl9dztsv5+2X+eoyX13O2y/n7Zf56tNv/3zHPv32rx4PeqAnujn56bf/dHPy02//6UC/fOf46Gr95tVPD/REL/RGH/RFBxrfie/Cd+G78F34LnwXvgvfhe/Cd+G78d34bnw3vhvfje/Gd+O78d34HnzfvJrzoyd6oTf67fv5Tr559dOBTvTb9/OdfPPqpwd6ot++n+/Ym1c/fdBv3/zoQCf67fv5vr159dMDPdEvr/V89EFf9Mtrff7c3oz66Wr9ZtRPD/REL/RGH/RF45v4Jr6Fb+Fb+L4ZtT6f45tR68OBN6N++u37+ezejPrpRNef/nTaf3qg3773oxd/faMP+qKDfzb56/gOfAe+A9+B78B34DvwHfgOfAe+E9+J78R34jvxnfhOfCe+E9+J78J34bvwXfgufBe+C9+F78J34bvx3fhufDe+G9+N78Z347vx3fgefA++B9+D78H34HvwPfgefA++F9+L78X34nvxvfhefC++F9+Lb+Ab+Aa+gW/gG/gGvoHvh1fx0dX6w6uvHuiJXuiNPuiLDjS+iW/hW/gWvoVv4fvhVX30RQf65bvHR9ef/nTaf/rlu+dHv3z3/uiF3uiDfvnu/OhAJ/rt+/73+XTaf3qgJ3qhN/rle56PvuhAJ7pav3n10wM90Qu90fhOfN+8OuujE12t37z66bdvfPREL/Tb9/Pn9ubVT799P38Ob1799Mv3fv593rz66jev7ufzffPqfj7fN69++uV7P/9ub1799EFf9Mv3fj73N69+ulq/efXTAz3RC73RB33R+B58D74X34vvxffie/G9+F58L74X34tv4Bv4Br6Bb+Ab+Aa+ge+bV/d+dLV+8+qnB3qiF3qjD/qiA41v4lv4Fr6Fb+Fb+Ba+b17dz3f4zaufTnT96U+nPZ6PHuiJXuiXb4yPPuiLfvnG+uhEV+s3r2J/9EBP9EK/vc5HX/Tb6350oqv1m1E/PdATvdAbfdAXje/Ed+K78F34LnwXvm9GRXz02zc/+qLfvp/P7s2on67Wb0b99EBP9Ms3P5/Xm1G/v37QF43vm1G/fxbfg+/B9+B78D34HnwPvgffg+/B9+J78b34Xnwvvhffi+/F9+J78Q18A9/AN/ANfAPfwDfwDXwD38Q38U18E9/EN/FNfBPfxDfxLXwL38K38C18C9/Ct/AtfOvP93567D890BP953s/PfbfXz/oiw508s++fHO99ZtRP/3yzf3RE73QG/3yzfPRFx3oRL99463fvPrpgZ7ol289H73RB33RgX751ud537z66jevfnqgX741P3qhN/qgLzrQia7Wb1799EDj++ZVfT6LN69++qAv+u37+bN98+qnq/WbVz/99r0fPdELvdF8vofP9/D5Hj7fw+d7+Xwvn+/l8/3w6qs3ms/38vlePt83r366Wgefb/D5vnn10wvN5xt8vsHnG3y+wecbfL7J55t8vsnnm3yvEt/k800+3zevfjrRb9/P7+CbVz890LM/9zevfnqjD/qio78Db179dP3pT4/9p8ffd+DTY//phd7o8/dZf3rsPx3oRPf36tNj/+nx97l/euw/vdAbfdD37zvw6bH/dKKbG58e++fz+vTYf3qiF3qjD/qiA53o/l59euw/Pf6+A58e+08v9Eafv+/Dp8f+04Fubnx67F+9H/RAT3Rz49Nj/+mDvujmxqfH/tPV+s2rn25ufHrsP73QG8336vC9Os2NT4/9p5sbnx77T/O9us2NT4/9pzf6oPl8L5/v5fO9fL7B5xt8r4LvVfC9glcDXg149emxf78Dkehq/eHVVzc3Pj32n17o5sanx/7TF/32/fyZf3j11W/f9xzy6bH/9EBP9D+++/n8+b94tZ/Pn+2HV9+/56IDnej6+znvHvv353x67J+/59Nj/+mF3ujDz7n8nODvSXQ/76fH/tOjf86LV7+fM/Ad+I6Dvujg5yQ/B9+J7+R5J887+8/53WP//ZyJ78R38ryT5538OS/+nBe+C9/F8y6ed/HnvPhzXvgufBfPu3nezZ/z5s9547vx3Tzv5nk3f86bP+eN78H38LyH5z38OR/+nA++B9/D8x6e9/DnfPlzvvhefC/Pe3ney5/z5c/54nvxvTxv8LzBn3Pw5/zi1R7fv/563jE/+qAvOtCJrtYvXv3pgZ7ot2989EYf9EUHOtHVuh70QE80voVv4Vv4Fr6Fb7Xvu8f+pwd6ohd6ow/6ogOdaHwHvgPfge/Ad+A78B34DnwHvgPfie/Ed+I78Z34TnwnvhPfie/Ed+G73r710RO90Bt90Bcd6ERX6/2g8d34bnw3vhvfje/Gd+O78T34HnwPvgffg+/B9+B78D34Hnwvvhffi++LV/vdE7jvHvufPuiLDnSiq/WLV396oCca38A38A18A9/AN/BNfBPfxDfxTXwT38Q38U18E9/Ct/AtfAvfwrfwLXwL38K32vfdY//TAz3RC73RB33RgU40vgPfge/Ad+A78B34DnwHvgPfge/Ed+I78Z34TnwnvhPfie/Ed+K78F34LnwXvgvfhe/Cd+G78F34bnw3vhvfje/Gd+O78d34bnw3vgffg+/B9+B78D34HnwPvgffg+/F9+J78YVXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXG15teLXh1YZXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXB14deHXg1YFXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXF15deHXh1YVXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbyq5lU8zat4mlfxNK/iaV7F07yKp3kVT/MqnuZVPM2reB58B74D34HvwHfgO/Ad+A58B74D34nvxHfiO/Gd+E58J74T34nvxHfhu/Bd+C58F74L34Xvwnfhu/Dd+G58N74b343vxnfju/Hd+G58D74H34Pvwffge/A9+B58D74H34vvxffie/G9+F58L74X34vvxTfwDXwD38A38A18A9/AN/ANfBPfxDfxTXwT38Q38U18E9/Et/AtfAvfwrfwLXwL38K38IVXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXA14NeDXg1YBXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXE15NeDXh1YRXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXg1YJXC14teLXgFf32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9Ntjwyv67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pei3B/32oN8e9NuDfnvQbw/67UG/Pb799vzoRL9837uO49Nvf+8xjk+//adfvvt89EK/fHd89Mv3vV83Pv32n375vvflxqfffr//bLV+8+qnX743P3qiF/rl9d5rGp8ee3z/eqKr9ZtLP/36+fn5Z99c+umF3uiDvuiXb37+3N5c+ulq/ebS9+9f+C58F74L34Xvm0v5+TN8c+mnE1399298N74b343vxnfz8zc//82f/HxGb/789EBP9EK/f/796IN+P9fn+/Pmz08nulq/+fPTAz3RC/3yja8+6IsOdKKr9Zs/Pz363//Nn59eaJ438H3z5/s9DL63wfc2+N4m39s3f36azzH5HJPPMfn+JN/bN39++v3n/P2Z1frNn58e6Ile6N3f+cK38C183/z56f7efvrqP92+n776Ty/0Rp+/7+qnr/77OYFONL4D3zHQ+A58B75vFv30RQe6f48+ffXP78Wnr/7TAz3RC93f509f/afv3/ft01fP719PdP8effrqPz3QE73QG43vuuhAJ7p/jz599Z8e6P49+vTVf3qjDxrf3b9Hn776T/fv0aev/tMDPdH9e/Tpq//0QfO9OnyvDt+r079Hn776T/N9vnyvLt+ry/fq8r26fK9u///Op6/+9b18n4Pvc/B9jonmeQPfwDfwDb7PkWieN3ne5Hk/vPp8/+FVwquEVwmvEl59+uo/jS+8SniV8Crh1aev/tM8b/G81f8/+Omrf38Hq39/P331nx7oiV5/39VPX/2n+/v86avn968HOtH9+/vpq//0QE/0QuM7DvqiA53o/v399NV/uv9/8NNX/+mF3mh837x675aMT1/9pxNdrd+8+umBfvm+90PGp6/+0xt90Bcd6Lfv/mh8N74b3zevfnqhNxrfje/G982rn67Wb1799Nv38106+B58D75vXv00vgffg+/B9+L75tVPv30/n92bVz+90Qd90f/4nvc+vXj31f85oP3oav3i1T8HtB/9j+8Zn+/Mi1f/HIL+t3/9m//7f/ov//F/+p//03/4P//N//D//vNf/9f/+r//+//rP/7n//37X/+v/+f/+P0v//N/+Y//6T/9x//tf/w//st//vf/4X/5r//lP/yP/+k///vX//Zvntd/vH5z/u0/P32Of/fP3zxef+mf5/m3/6QL//rnpP/f/evzN/xzsPKvfw5IXv91vP7r2P/81/v6J+bvn5jjvH7Kvb9/Zs6z//XPf9Tvn5r/HAb98xciXv/c+v4b/Nsxsv415vP6214/Zzxr/2s8e/9+zhgx/vXPf9zfz/nnn3j++Qs5Xz9n/37O3P/Yv91fP+U8/7rP37/JPz9xrv732Otfc5/XP31+//Zr/mvP399/xr/O++Hu35/Qfv71+Sfi73nrX58f+f/7n/O//wPr7wfO8c+/7fuP/Pnv/SP/7b/9u//2/wE=",
      "is_unconstrained": false,
      "name": "verify_attestation",
      "verification_key": "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"
    }
  ],
  "name": "AttVerifier",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "BusinessProgram"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "allowed_url_hashes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "sender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "att_verifier_address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "business_logic_address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::SuccessEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "att_verifier_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "business_logic_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::_emit_success_event_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::_emit_success_event_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AttVerifier::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "public_key_x",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "public_key_y",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "signature",
                    "type": {
                      "kind": "array",
                      "length": 64,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "request_urls",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 200,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "allowed_urls",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 200,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "data_hashes",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 8
                        }
                      }
                    }
                  },
                  {
                    "name": "plain_json_response_contents",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 1000,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "business_logic_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::verify_attestation_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::verify_attestation_abi"
        }
      ]
    }
  },
  "transpiled": true
}
