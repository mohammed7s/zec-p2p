{
  "file_map": {
    "102": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "// This file generates call interface stub functions for Aztec contract methods.\n// It creates wrapper functions that serialize arguments and return appropriate call interfaces\n// for invoking contract functions across different contexts (private, public, static, utility).\n\nuse crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "135": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "14": {
      "path": "std/ecdsa_secp256k1.nr",
      "source": "// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n"
    },
    "154": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "155": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "156": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "157": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "158": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "167": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "172": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "174": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "208": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "211": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "212": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "214": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "215": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "218": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "229": {
      "path": "/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "316": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we absorb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "329": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "331": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "359": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "362": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "379": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "383": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "400": {
      "path": "/root/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "401": {
      "path": "/root/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr",
      "source": "mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n"
    },
    "402": {
      "path": "/root/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr",
      "source": "pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/root/x/work/PADO2/AZTEC/aztec-demo/att_verifier/src/main.nr",
      "source": "mod aes;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AttVerifier {\n\n    use aztec::{\n        event::event_emission::emit_event_in_public,\n        macros::{events::event, functions::{internal, private, public}},\n        protocol_types::{address::AztecAddress, hash::poseidon2_hash},\n    };\n    use business_program::BusinessProgram;\n    use sha256::sha256_var;\n    use string_search::{StringBody, StringBody1024, SubString, SubString1024};\n\n    global MAX_URL_LEN: u32 = 1024;\n    global MAX_CONTENT_LEN: u32 = 1000;\n\n    //Emitted public log limit: 13 fields\n    #[event]\n    struct SuccessEvent {\n        sender: AztecAddress,\n        att_verifier_address: AztecAddress,\n        business_logic_address: AztecAddress,\n        id: Field,\n    }\n\n    // Opcode count: 71055, Total gates by opcodes: 546716, Circuit size: 550.167\n    #[private]\n    fn verify_attestation(\n        public_key_x: [u8; 32],\n        public_key_y: [u8; 32],\n        hash: [u8; 32],\n        signature: [u8; 64],\n        request_urls: [BoundedVec<u8, MAX_URL_LEN>; 2],\n        allowed_urls: [BoundedVec<u8, MAX_URL_LEN>; 3],\n        data_hashes: [[u8; 32]; 2],\n        plain_json_response_contents: [BoundedVec<u8, MAX_CONTENT_LEN>; 2],\n        business_logic_address: AztecAddress,\n        id: Field, // id for this attestation\n    ) -> bool {\n        // 1. Check signature\n        assert(std::ecdsa_secp256k1::verify_signature(public_key_x, public_key_y, signature, hash));\n\n        // 2. Check that the request_url starts with one of the allowed_urls\n        let mut allowed_url_matches: [Field; 2] = [0; 2];\n        for i in 0..2 {\n            // Safety: Get the index of the url in allowed_urls that matches request_url (unconstrained) and then check it\n            let (found, url_index) =\n                unsafe { get_allowed_url_index(request_urls[i], allowed_urls) };\n            assert(found == true, \"No allowed URL matches the request URL\");\n            let request_url_haystack: StringBody1024 =\n                StringBody::new(request_urls[i].storage(), request_urls[i].len());\n            let allowed_url = allowed_urls[url_index];\n            let needle: SubString1024 = SubString::new(allowed_url.storage(), allowed_url.len());\n\n            let (result, match_position): (bool, u32) =\n                request_url_haystack.substring_match(needle);\n\n            // A match result is only valid if the match position is 0 (i.e., the allowed_url is a prefix of request_url)\n            assert(result & (match_position == 0), \"URL check failed\");\n            let mut hash_input: [Field; 1024] = [0; 1024];\n            for j in 0..1024 {\n                if j < allowed_url.len() {\n                    hash_input[j] = allowed_url.storage()[j] as Field;\n                }\n            }\n            // TODO can we hash without the padding of zeroes?\n            allowed_url_matches[i] = poseidon2_hash::<1024>(hash_input);\n        }\n\n        // 3. Hash plain_json_responses and check with input hashes\n        for i in 0..2 {\n            let hash = sha256_var(\n                plain_json_response_contents[i].storage(),\n                plain_json_response_contents[i].len() as u64,\n            );\n            assert(hash == data_hashes[i]);\n        }\n\n        let result = BusinessProgram::at(business_logic_address)\n            .verify(plain_json_response_contents, allowed_url_matches)\n            .call(&mut context);\n\n        if result {\n            AttVerifier::at(context.this_address())\n                ._emit_success_event(\n                    context.msg_sender().unwrap(),\n                    context.this_address(),\n                    business_logic_address,\n                    id,\n                )\n                .enqueue(&mut context);\n        }\n\n        result\n    }\n\n    #[public]\n    #[internal]\n    fn _emit_success_event(\n        sender: AztecAddress,\n        att_verifier_address: AztecAddress,\n        business_logic_address: AztecAddress,\n        id: Field,\n    ) {\n        emit_event_in_public(\n            SuccessEvent { sender, att_verifier_address, business_logic_address, id },\n            &mut context,\n        );\n    }\n\n    #[contract_library_method]\n    unconstrained fn get_allowed_url_index(\n        request_url: BoundedVec<u8, MAX_URL_LEN>,\n        allowed_urls: [BoundedVec<u8, MAX_URL_LEN>; 3], // TODO this probably shouldn't have a fixed len\n    ) -> (bool, u32) {\n        let mut found = false;\n        let mut index: u32 = 3050913689; // max u32 value to indicate \"not found\"\n        for i in 0..allowed_urls.len() {\n            let allowed_url = allowed_urls[i];\n            if (allowed_url.len() <= request_url.len()) {\n                let (result, match_position) = search(request_url, allowed_url);\n                // If a valid result was already found we don't have to store again\n                // (A valid result being that the match position is 0)\n                if result & (match_position == 0) & !found {\n                    found = true;\n                    index = i;\n                }\n            }\n        }\n        (found, index)\n    }\n\n    // Adapted version of library function, which doesn't assert found to be true\n    // https://github.com/noir-lang/noir_string_search/blob/v0.3.3/src/utils.nr#L1-L29\n    #[contract_library_method]\n    unconstrained fn search(\n        haystack: BoundedVec<u8, MAX_URL_LEN>,\n        needle: BoundedVec<u8, MAX_URL_LEN>,\n    ) -> (bool, u32) {\n        let haystack_length: u32 = haystack.len();\n        let needle_length: u32 = needle.len();\n        assert(needle_length > 0, \"needle length of size 0 not supported\");\n        assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n        let mut found = false;\n        let mut found_index: u32 = 0;\n        for i in 0..haystack_length - needle_length + 1 {\n            if (found == true) {\n                break;\n            }\n            for j in 0..needle_length {\n                if haystack.get(i + j) != needle.get(j) {\n                    break;\n                } else if (j == needle_length - 1) {\n                    found = true;\n                }\n                if (found == true) {\n                    found_index = i;\n                    break;\n                }\n            }\n        }\n\n        (found, found_index)\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "61": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "68": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "69": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "70": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "71": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "72": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/event/event_emission.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext},\n    event::event_interface::EventInterface,\n    messages::{\n        logs::{event::to_encrypted_private_event_message, utils::prefix_with_tag},\n        message_delivery::MessageDelivery,\n        offchain_messages::emit_offchain_message,\n    },\n    utils::remove_constraints::remove_constraints_if,\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n};\n\n/// Emits an event that can be delivered either via private logs or offchain messages, with configurable encryption and\n/// tagging constraints.\n///\n/// # Arguments\n/// * `event` - The event to emit\n/// * `context` - The private context to emit the event in\n/// * `recipient` - The address that should receive this event\n/// * `delivery_mode` - Controls encryption, tagging, and delivery constraints. Must be a compile-time constant.\n///   See `MessageDeliveryEnum` for details on the available modes.\npub fn emit_event_in_private<Event>(\n    event: Event,\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    delivery_mode: u8,\n)\nwhere\n    Event: EventInterface + Serialize,\n{\n    // This function relies on `delivery_mode` being a constant in order to reduce circuit constraints when unconstrained\n    // usage is requested. If `delivery_mode` were a runtime value then performance would suffer.\n    assert_constant(delivery_mode);\n\n    // The following maps out the 3 dimensions across which we configure message delivery.\n    let constrained_encryption = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n    let emit_as_offchain_message = delivery_mode == MessageDelivery.UNCONSTRAINED_OFFCHAIN;\n    // TODO(#14565): Add constrained tagging\n    let _constrained_tagging = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n\n    let (ciphertext, randomness) = remove_constraints_if(\n        !constrained_encryption,\n        || to_encrypted_private_event_message(event, recipient),\n    );\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during offchain delivery.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = [randomness].concat(event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    if emit_as_offchain_message {\n        emit_offchain_message(ciphertext, recipient);\n    } else {\n        // Safety: Currently unsafe. See description of CONSTRAINED_ONCHAIN in MessageDeliveryEnum.\n        // TODO(#14565): Implement proper constrained tag prefixing to make this truly CONSTRAINED_ONCHAIN\n        let log_content = prefix_with_tag(ciphertext, recipient);\n\n        context.emit_private_log(log_content, log_content.len());\n    }\n}\n\npub fn emit_event_in_public<Event>(event: Event, context: &mut PublicContext)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n"
    },
    "74": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "97": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/root/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-nightly.20251016/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "11591029387631908977": {
            "error_kind": "string",
            "string": "Function _emit_success_event can only be called internally"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "att_verifier_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "business_logic_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABEgnAgUEBCcCBgQAHwoABQAGAEQtCEQBLQhFAi0IRgMtCEcEJQAAAE0lAAAAcycCAQRIJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAAJFHgIABgEKIgZDBxYKBwgcCggJAAQqCQYIJwIGAQAKKgcGCSQCAAkAAACrJwIKBAA8BgoBHgIABgAKKggGByQCAAcAAADCJQAAAmspAgAGALd8YNktCAEHJwIIBAYACAEIAScDBwQBACIHAggtCggJLQ4BCQAiCQIJLQ4CCQAiCQIJLQ4DCQAiCQIJLQ4ECQAiCQIJLQ4GCScCAQAALQgBAicCAwQGAAgBAwEnAwIEAQAiAgIDLQoDBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQAIgQCBC0OAQQtCAEBAAABAgEtDgIBJwICBAAnAgMEBScCBAQBLQoCBSMAAAF9DCoFAwIkAgACAAACASMAAAGPLQsBAicCBQQFBiIFAgEnAgcEAwAqBQcGLQgBBAAIAQYBJwMEBAEAIgQCBi0OBQYAIgYCBi0OBQYnAgcEAwAqBAcGACICAgctAgcDLQIGBC0CBQUlAAACfQAiBAIGLQsGBScCBwQCACoGBwI3DgAFAAImACIHAgYAKgYFCC0LCAItCwEGLQIGAycABAQGJQAAAq8tCAUIACIIAgkAKgkFCi0OAgotDggBACoFBAItCgIFIwAAAX0oAAAEBHhIDAAABAMkAAADAAACaioBAAEF2sX11rRKMm08BAIBJioBAAEFoNub0O7p2HE8BAIBJgAAAwUHLQADCC0ABAkKAAgHCiQAAAoAAAKuLQEIBi0EBgkAAAgCCAAACQIJIwAAAoomLQEDBgoABgIHJAAABwAAAsUjAAACzi0AAwUjAAADEi0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAMILQEKCC0ECAsAAAoCCgAACwILIwAAAuQnAQUEAQIABgIGJg==",
      "custom_attributes": [
        "public",
        "internal"
      ],
      "debug_symbols": "nZbdjuIwDIXfpde9iO388iqj0ahAGVWqCurASivEu68T4hRWSgVzg7849NQ5capcm32/vXx/DdPh+NNsPq7Ndh7Gcfj+Go+77jwcJ85eGxV/ADlQy9E0G8ORVI76nqdwj5rHLsZwjyaPLebo7tFBswEVwTIAgweBkCHws8CiqEjAZQAUkAxKBiVDIGAyaCUgyrHMBEZeYXwGK4JWBFPNNoLN4JWAyRAkE3KGlBLQAj4DkIDLkFaRIL+CCAREUIugFkEtgkYEk5nsM4W4QN82OnkYIvgMIBmQDEomeRiBUEAyWjLaZjAgYDJYJSAZJxmnBeSlXgQ9vwJ533VAAXsHo0BAMrF4xAg+A0omFo+8XyZZ5yOYDMm6BCWT/TGxUe8gGUsCce3+dmsbORhf57nv47l4OCl8fk7d3E/nZjNdxrFt/nTjJf3p59RNKZ67mWe56/tpz5EFD8PYR7q1y9Oq/iggUsiPMxtXJEDZJxFYEQlgvYgEPoBFxIYnDaxrEBprsgazVzWN9ToClDpQU01Dr9ShpQoNuCzE/NJQa6uG2rqIs5Ql3IOZGt8owuFSRMBqEX5FxCssIl4R1NwMa7uqg192FXRN43VHg64uZkWEgg9lX2lpDAPPzbXWobY0F7mH1nD4uoRzVCRCXWKlPzV5MVTzSqqnxKxIOFd63IVFgiy+ruGhaHiwv9MIJG7wh9nXNV61A7Fqx6pEOSssYarfrrXuIufLx4se/XhnW7xRxdKHD/F7ljoolvr/tuWTh91umJ9uY7coNg/dduzz8HCZdg+z578nmZHb3Gk+7vr9Ze6j0nKl458PINOCMZ98UYgj1C1f6HgEaZJL53tfHEKaBR7S5y2W9g8=",
      "is_unconstrained": true,
      "name": "_emit_success_event"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+29CZxdxXUnXLf7qdVPavVTaxcS8MQmdrGI1RiLXYAEYhHY2AaEkAEbDAbhja0lEFoQAoztLJ7v82Tx2F8mjseJk5ksk8WJv5nEcRLH43ji2OMln8d2HG8JsWcSZ/z5wj3qf//7X/Xq3luv9YB3fz+p77t1zv+cOnXq1HKr6mbuhatV/L3n3rs3b7nvvpvu+sl/m27bsvEnj7IiqVH8nVn8zZ+PucmX0bZd1JWVoJ3MVEJG5rovY8B1X8ag676Mhuu+jBmu+zKGXPdlzHTdlzHsui+j6bovY5brvozZrvsyRlz3Zcxx3Zcx6rovo+W6L2OuKy+jipwxNz1y5sXTPo+9RjwrI2++634ZLXDdl7HQdV/GItd9GYtd92Uscd2XsdR1X8ZBrvsylrnuy1juui/jYNd9GYe47ss41HVfRtt1X8YK130Zh7nuyzjcdV/GEa77Mo503ZdxlOu+jJWu+zKOdt2XcYzrvoxjXfdlHOe6L+N4130ZJ7juyzjRdV/GKtd9GSe57ss42XVfximu+zJOdd2Xsdp1X8ZprvsyTnfdl3GG676MM133ZZzlui/jbNd9Ga9w3Zdxjuu+jFe67ss413Vfxqtc92Wscd2XcZ7rvozzXfdlXOC6L+NC130ZF7nuy7jYdV/GJa77Mta67su41HVfxmWu+zIud92Xsc51X8Z6130ZV7juy7jSdV/GBtd9GVe57su42pWXUUXONW565FzrpkfORldBznUkMF/QkC84yBcE5C/s8xfq+Qvv/IV0/sI4f6Gbv3DNX4jmLyzzF4r5C7/8hVz+six/kZW/XMpf/uQvZ/KXJ/nLjfzlQ/5yIJ+8zyfX88nvfHI6nzy2yd0VP/mXT17mk4v55F8+OZdPnuWTW/nkUz45lE/e5JMr+eRHPjmRTx7kg/t88J0PjvPBaz64zAd/+eAsHzzlg5t88JEPDvLOe965zju/eec07zzmnbs1P/mXd47yzkveucgb/7xxzhvPvHHLG5+8cciDdx5c8+CXB6c8eOSVO698eeXInTd3rLzQNzr/ZYXrWX9zyEkvPB4ukgeArcR6kGyYxJXjH/+VYQYsxe+e5895hqvxX2f8zWr8z7tvfr0a+FEXwx0s/t4BvHeQTKP590Dz74nG9K1mb/fqmvkdG3GT82gYDnSbVQ17HubJrkF6hvhNV6vss4zwTB7nz+rGCNCYvIzSGkJPS5sBaWb/PPQdC3RctsOUZrrk1x2UNghpbyz+WpmgXiVs9Kaa/rKmi/5y3ovRXxqUlsJfEIP9xTDy699T2hCk/TKlzYS0D4Ps0+D+8uK+ZkzaH8MrtkHPdwlYPmKZvnYN0t/8MjuZ7YcFvaU1IQ1tn1+z4PmgwJpJfEa/uvg7WvzFsjH+lpA/RPKV3so3M4E1KJ4ZfW6fE0Bnw7wAaNsu6ho03gsV73P3fe7fffLJX/ujD2394AfeO/b5OT8z+/hZj+zY8d1l31n+s9/b8QvGexHkI3PRsoeM/2Il+9z/OHjD7R/957tnX/LoR972+b++4v45yzd9/NBdH7jhE88c+s2bHjfeSxTvN/a+75HWR971b9vHfeqfhi556u9v+sdLZ5z5+U89uPQPt//om9971njXKt6/vOFHX/xY69l3vv3J33zgzKPnb/rlZz/3/b/7L5/8ldY/fuXDb/ncacZ7KeS5zHpa47+sGv/+Pt7l1fgHjH8d8FfpY66vxj/X+K+Ah2272faLH/rieU9+6qS//dGsPes3Pfb2U5/4zPXffueSDx75tTd+ePkvjxnvlYr3q1sveGbr4rtO//bwnz958s8tO/hLz33wY1//wTu2nPn3X//Gb6z4R+PdIHiXnLLyrHt++i8WfOHow/5mze//8onvXvrcEed84T+t/bnv/fMf/y83UWZXVcvzfptfXY2/YfzXVOPfX8evhYftMM/+Ztx4N8bz2jXDeK8TvMee0/zeB/Y8vMN9+YPf2veDY39nzQljh5w3duJ/e99fLXvzva9d+j3jvR4UKpHn5XlczOP7F1a98CAfxh5RJN6/9Y4779j6jvPuu2/LvVsvuPuuezZtveOWO7dcee+mzXduuW7LvffdcfebGTCj3xd4nudylkyWc8mWrRtfuLvg7jdv3fL2rTMIl/tjTfo9i37Ppt/cR7Hnqq8Tc1m/Yw7hqb/OTe3n5Ze1VS3CwvxYX2MU0kq0HxuMv1WNf4vxz63Gf6/xj1Xjf4Pxz6vGf7fxz6/Gf5fxL6jGf4fxL6zG/2bjX1SN/zbjX1yNv238S6rx32f8S6vxbzL+g6rx32r8y6rxbzb+5dX432r8B1fjf4fFmUPgocUQwz4UnpeI/wfHxCnEb5IuZftFGeGZPM4fjkfRVsjbEmmhGDkong0EsFoJseYmxBpLiDUvIVbKPM5PiLUgIdbChFiLEmItToiV0vYp69CSHsVamhArpU+ktH1K/zooIVbKup3SJ5YlxEoZo5cnxOrV9tH6WdZ3wL5G5vlrcviZyWkSVuaq9XvaJI/1M3nDbmq+Ssjbb8cVQp7qZxn9YZH65WNrK/9i/H7hllvuv23d3bc5unhIfZFHxeVusvrtgGqMm9E/fs7Yg4IWrzx7FoqL7F28Zevm26/ddNttW279SSbvYw5GutDz3JxyheC1Qj+MNG27qGsgxqkRv0m6VHVq5TSYP3QaC2aFVdfdvenWCzbdc9/9d27B14TopiwlI1R8pso0A83w2Syiu5B+rxN8TmCjLx0OacoShjnqpubpcA8fV1l+NiDoDyOswwSf6T4Y4EcM5GOPCXl1jFdaPvKr5fz5H3ZT7dF2cZfpeJjQ0XAPh+clasKC2Jpn+E1Xq6ZnIX/D/HFzckQ1efMz4kd5iGn6mK2PFGmGdVTxe8iDZbwNov9E8bclZHDMsDTUF5/hq8LfJ93RtuwndeyIeKYXPkP8pqvll1mo3DB/7CdHVpM3L8buqI/Z+iiRZlgri99DHizjbRD9XxZ/W0IG+4mlob74DP3kU6Q72pb9pKIdo5eJGH7T1fLLLFRumD/2k6OqyVsTY3fUx2y9UqQZ1tHF7yEPlvE2iP5Lxd+WkMF+YmmoLz5DP/l8cT/s0bftoq47la1L8L9t2E3NVwn+rcZ/dDX+243/mGr8Dxj/sdX4TzL+46rxP2S+dzw85Hp+Ajwv8/o1tp4bfpN0qVrPTyB5nD+efj9R6NISaTz9fqKQc6KQo7DmJsSalxBrWUKsVkKsJT2KtSAh1sKEWIsSYi1OiHVkQqyUft+r9joqIVZKX12ZEOvohFgpbZ8yj0sTYvWqrx6TEOvYhFjWN7L2HvsHWfF3WPCVHRsinumJzxC/SbqUlJeF7IL54zHNqmryxjLiR3mIafqYrU8SaYZ1cvF7yINlvA2iP7EwaEvI4DGNpaG++AzHNMcUuKNC38MJt6w/Ij/bCPnYH+uUF+KZnvgM8Zuulv9nIf9QdrH8nVRN3tyY8kV9zNYnizTDOqX4PeTBMt4G0Z9L/ogy2B8tDfXFZ+iPZ2WTdUfbsp9UtONFsX5i+E1Xyy+zULlh/thPTq4m78IYu6M+ZutTRJphnVr8HvJgGW+D6C8nP0EZ7CeWhvriM/STiwvcYY++bRd3cR0xDMRGnePLIft+rJ8ZftPVKvcsZEdV3yx/p1aSl32PfQPlIabpY7ZeLdIMy7Z2DXmwjLdB9K8hP0MZ7BuWhvriM/SzaykeoW3ZT6rZ0Z0f6yeG33R1/HLCT1S5qfpm+VtdTd55MXZHfczWp4k0wzq9+D3kwTLeBtG/gfwEZXA8sjTUF5+hn2yieIT65lfbRV2ZsnUJ/im2QwzDPh2elyjHH8f6qeE33VQbV/HT00merxws72cIXVoiDW2MaSjnDCGnj9XH6mP1sfpYfaw+1osb69Q+1ksC6+XgX/061C/Hfpzo18cXK1bfv/q++nL01X5/om+vfh77tn+xYvV9te8TL0d79f2rX44vR6x+Her7xMvR9v242q9DfXv1sTph9cdW/Tz2Y3TfV1+sWH3/6uvVx+rXx+nMYx+rH3P67VA/j/089mNO3179cuz714sXqz/X0c9jP+b040Qfq+/3/TrUt32/DvWxetlX+/2Jvk/0bd+3/XRi9duhvr36daiP1Qmr133CzoXFM8P4ey7qfK7TA3KQ3+hGBF9W/B0W+uVy2i7qij63zPCbbmqeS8jLQvZXdrG8nyl0aYk0LuczhZwzhZw+Vn2s1T2K1c/jS8NeLwe9+lgvjfrYjxN9rL6v9uP9dOrVL8d+Hvv+1W87Xqx69X2ib6++f/XLsY/Vr0N9n3h52r4fV/t1qG+vPlYnrP7Yqp/Hfozu++qLFavvX329+lj9+jideexj9WNOvx3q57Gfx37M6durX459/3rxYvXnOvp57MecfpzoY/X9vl+H+rbv16E+Vi/7ar8/0feJvu37tp9OrH471LdXvw71sTph9X2ij9XH6mP1sfpYfaw+1ksdy84twzPDTic5Zc9HQ36jU2eT5f/aLuq6dljkoQT/TcZ/VjX+txj/2dX4325nl70CHmbFX8M+B54PxmOfnBGeK/jxGeI3SZeS8vaf23YOyeP8mV9Y3l8pdGmJNPaRVwo5rxRyFNbRCbFaCbEWJ8RalhDrSOf239fFWpoQa0FCrPkJsVL6xEEJsc5MiLUkIdZZCbHmJsRamRArZd0+JiFWyliYsj4uTIiVshyPS4iV0idS2j5l3U6Zx5Q+MS8hVq/GiZR6vRz6TP027cDZPmV9HEuIlTKPZ/eoXin7EynzaG2tGgvn/9ou6rqfx5qGgdjnwvMS495zM8JzTo+zDb/ppuazyjj7XJLns6vl/VVCl5ZI43H2q4ScVwk5CuvohFithFiLezSPCxJiLUyItTIhVkrbH5MQq1+O5bCOS4iV0icOSog1LyFWyvi1JCFWStun9NWUtu/V+JXSV1P61/yEWCnLMaV/paxDKf1rbkKspT2ax17ty6XMY8r+RK+WY6/25c5OiNWr/ZyUfcx+f+KlUYdSxomUeqX0r7MSYp2TECul7VP2AayttXmgs4AvK/6qdSwl5qRWZIRneuIzxG+6qWVZZQ7sbJLH+TO71Jzja2fEj/IQ0/RRc27cJq0pfg95sIy3QfRvGHrhryrrk0hGrN/M+Mm/TQXuqNCX65yy+9kCtyX42UbIx/5YsbwGY/2R52Qr+n9wTlbZpeycbMqYdxbpgDqz/ZGvhD0asfY3/KarVd5ZyC6YP7b/GqFLS6QdAveYhnLWCDnThcXllV9tF7ysOKbYwrAR9zx4XqJcZsT6geE33dQ8VvGD80iez6aW9/OFLi2RxmV3vpBzvpDzYsIyHzLboC3ZL5CvRDmNxfqF4TddLT/MQnbB/HF/4YJq8uZmxI/yENP0MVtfKNIM66Li95AHy3gbRP/T1F9AGdxfsDTUF59hf+FZ6i+oOlTVH5Hf6F5qckYEH9eviv4XHXcNv+lq1ecs5O/KLsrfjVf5Kds/1k9fjFjmfxcE5ITiipKD/Bf05SSXc25NOedGyllTU84aIWdE8HEcQj+NjwvZl2PjkOE3Xa24l4XqobKL5e+iSvKyL2XEj/IQ0/QxW18s0gzrkuL3kAfLeBtE/ylq51EGt/OWhvriM2zn/yu186gvj0vLxj/kZxshH/tjtfJyrVh/NPymq+P/E/6o/EPZxfJ3cTV5ozHli/qYrS8RaYa1tvg95MEy3gbRf5H8EWXweMXSUF98hv743wvcYY++bRd1XaFsXYL/K8Nuar5K8J9s/Gur8f9b47+0Gv8xxn9ZNf7/ZPyXV+O/yPjXVeP/DeNfX41/m/FfUY3/1cZ/ZTX+1xv/hmr8Rxv/VdX4TzX+q6vxf8P4r6nGv9b4r63G/5vGv7Ea/z3Gf101/meM//pq/BcY/6ur8f+T8b+mGv+zxn9DNf7vGf9rq/Fnxv964C/zTsb4b6rGP2j63ogPhU6Gb23l64A+8/w1LE4zWU3CKql7FtId9eP+1o0gD/Pow7qxJNawSKtSJq93/nwh/khAF6XnsXBfN88HJcS6KCHW3IRYFyfEuiQh1tqEWJcmxLosIdZoQqzLE2KtS4i1vkexrkiIdWVCrA0Jsa5KiHV1QqxrEmIdnBDr2oRYGxNiXZcQ6/qEWCnbjlcnxHpNQqwbEmKd1KNY1r+vOV9yac35jrNrznesrznfcU3N+Yrzas5XXFJzvuHCmvMN66yvfRU8zIq/ai6hRL//iozwnNPjJ8Nvki4l5e0fP11N8jh//L7yGqFLS6RxHblGyLlGyFFYCxNiLU+ItTQh1pEJsRYkxDooIdbihFjzE2K1EmIt6VGslL66KCFWStuvTYiV0ldT1seVPZrHlPXxnIRYKetQr9r+6IRYKeNEyrY2ZZxIafuU9upV/0rZN0lZjilt/3KIE8ckxLo0IdblCbEu61GsdQmx1ifESmn7M3tUrysSYo0mxErpExclxLoyIVbKckypV0pf7dVYeEZCrJS+mrIcU+rVq/ZK6asbEmKl9NWU8eu4hFgp+19jCbFSzimk7JOnHCuknHu0/r3NY18BfFnxt+Yc/mhGeKYnPkP8JulSUl5wDh/zx2urr6kmb05MOaA+ZutrRZph2bvbIQ+W8TaI/rmZL/xtCRmHkAxLQ33xGa6t/u7MybqjbdlPKtpxeayfGH7T1fLLLFRumD9+13Ot0EXZm/vEsfZWWHMTYs1LiLUsIVYrIdaSHsVakBBrYUKsRQmxFifE2pgQK2UdSlmOyxNiLU2ItTIhVsq6ndK/UtahlHH15WD7+QmxUsZoi4W2rxH7M4eSnLJ9b+Q3upr7Za6uuV/mupr7Xa6suV/lYutXvQYeZsVftRelRB9vW0Z4zuk+peE3SZeS8vb3KW8geZw/7lO+VujSEmm8fui1Qs5rhRyFtTAh1vKEWEsTYh2ZEGtBQqyDEmItToi1MSHW3IRYKW3fq766MiFWKyFWSv9KGXPmJcR6Odh+fo/mcUmPYqWs24sSYqW0/dqEWCl9tVf7ACmx+u12Oax+u33g/Kvfbh842/fb7QNXt3u13U5pr1711XMSYqW0V8qYk9L2RyfESlmHUrbbvRqje7U/kTKPKfu+Kcsxpe1fDnHimIRYowmxrkmIlXKe/NqEWOsSYp2REOvyhFhnJsS6KCHWdQmxXg62vzQh1mUJsdYnxEppr+sTYqX01ZR1qFf9vlfz+HKIhSn16rcdL42249UJsVL25VLaa0NCrCsTYqVsa1P6REp79WrbcVxCrJRjvrGEWCnf6aScB0g5P5FyfQ7vscG1YVnxV52ZnMtpu6hrTkZ4pic+Q/wm6VJSXhayC+bP7FLzTOeRjPhRHmKaPur8X7Rt/s/Obx7yYBlvg+jXNl/42xIyeI9N7Pl6+R6bC5qTdUfbsp9UtOMRsX5i+E1Xyy+zULmp+lP23OaUZ+GmPB95XkKsZQmxWgmxlvQo1oKEWAsTYi1KiLU4IVbKM2eXJsRKWR9XJsRK6V8p7XVkQqyU/pWyDqWMqyl9ImVc7dW6nbI+pqxDyxNipayPLwf/mp8QK2UfgPdwYX+Z93CFxhRKDvIb3Yjgy4q/Nb998kxGeKYnPkP8ppua5yp9dmV/ZRfL+01Cl5ZI4/m8m4Scm4QchbUwIdbyhFhLE2IdmRBrQUKsgxJiLU6ItTEh1tyEWClt36u+ujIhVishVkr/Shlz5iXEejnYfn6P5nFJj2KlrNuLEmKltP3ahFgpfbVX+wApsXq13U5p+5R9gJQxOmV/old9td9uH7i42u+Tl8Pq98kPnH/1+4UHzr96tV+Y0l696qvnJMRKaa+UMSel7Y9OiJWyDqVsO3o1Rvdqm5Yyjyn7vinLMaXtXw5x4piEWKMJsdYlxLomIdYZCbFSvh9Kaa8NCbHOTIh1UUKs6xJipfSJyxNipbR9yrqdsj6mrEPXJsRKWR9fDv51aUKsyxJirU+IldJe1yfEShkLU8boXvX7Xs3jy6GtTalXv2/y0mg7Xp0QK2V/IqW9UvbJr0yIlbKtTekTKe3Vq23HcQmxUs4pjCXESvneKuU8U8r5r5TrC3kPJq5tzYq/w4Ivl9N2UddIRnimJz5D/CbpUlJeFrKLWidt+bu5mrzZGfGjPMQ0fczWm0SaYd1S/B7yYBlvg+j/66wX/raEjENIhqWhvvjM7JPvwfzDWZN1R9uyn9wMz0vY8Q9i/eTm4r7pavllFio3VX8sf5uqyfv9GLujPibvlmryBq2sbhXYpsuW4veQRxfjbRD935A/bBY8LZHGPmhpDuTjs4EDhHWrwEI7WpnkdePThS2U/+f/2i7qOoXjgmEgdkVfuD62bhl+09Xy9YzjmMnzxRjlR8aryovny+qU/coexWolxJqfEGtjQqyU9lqQEGthQqxFCbEW92ge5/WoXssSYqWsjynL8aCEWCnr0JKEWCnLMaWvLk+IldK/5ibEOjghVkq/79WYkzKPxyTEOjYh1nEJsVLaK2XfJKV/9Wq/MKXf92pfbmlCrCMTYr0c+nK96vcp+yb9Nq0cVq/25Xo1Fqbsy6WMhSnLMaW9erX/dUlCrF7tf40lxEpZt1PWoZT2StkOpaxDvWr7lPEr5bxcr84NpfSvlH3fXu1j9mrbcXNCLGs7Rgjb0vOr5vumgzPCMz3xGeI33dR8lpAXfN90Mzyr+r6J17P3SjxMWY96da48ZQxLidV/31QOK+XcXMo6lLIcU74PSNnX6dV5mJT+lVKvXn2v06tzFCnLMeVahZTxns9Oxb7RoSRH9UNuCchBfqMbEXxZ8XdY6Feiv7QjIzzTE58hftNNzXOV/pmyv7KLWrtmvC2RxuvwQ+u3UI7CWpgQa3lCrKUJsY5MiLUgIdZBCbEWJ8TamBBrbkKslLbvVV9dmRCrlRArpX+l1CtlOabUK2VcTekTKctxfkKslLZf0qNYKePEooRYKW2/NiFWSl/t1f5ESqx+H+DAtR39PsCB06vfBzhw5djvAxy4ONGrfYCU9upVXz0nIVZKe/VqnDg6IVbKOtSrbUev9n171b9S9qNTlmNK278c4sQxCbFGE2JdkxAr5fz9tQmx1iXEOiMh1uUJsc7sUb1SlmNKvS5KiJXSJ1KW46UJsS5LiLU+IVZKe12fEOu6hFi96qv9+njg8tir/tVvh/p+z1ivToiVso+Zshw3JMS6MiFWynY7pU+ktFev1sfjEmKlHIuOJcRK+d4q5fxEynmTlOuZbK7D1h/iWP5ckjMq5IwG5CC/0Q0LvraLul5h6/fOhIcZ4WJ9GYzHbmSE5wp+fIb4TTc1BpWQt3/t4kUkj/NnNrW8Xyx0aYk0npO5WMi5WMhRWId0AWvYo2fbRV0bVXmX4H8T29MwUDdcY1GibJfE+pLhN91UO1XxpbUkz1culvdLhS4tkcZldKmQc6mQo7AWJsS6qEf1mpcQ66iEWCnzuDgh1vyEWEsSYi1KiJXSXisTYh2cEGtjQqxWQqyUtl+QEOugHs3jMQmxjk2IZeOX6eqrKjlraspZI+SMCL6s+FuzX3t8RnimJz5D/KabmudU/VplF8v7WqFLS6Tx3I3q86wVchTWvIRY5yTEWpgQ66CEWIsTYi1PiLU0IdaRCbEWJMTq1XJM6asp62NKvZYlxGolxFqSECulT4wlxErpE3MTYqW0V8r4lVKvlQmxUpZjSr16te1IWY4pbZ+ybqfM4zEJsY5NiHVcQqyXQ7udsm53o6218QqOb7Li77Dg68ZYzfCbpEtJecF5Y8xf1XnjK+Ee01DOgZh3STlHuCwhVsp54+UJsVLOxc3tUb36c3HlsI5LiJXSXr36HiflnH1Kv08ZC1OW41hCrJQxJ6VPpHzvldL2S3tUr5Tvl1L6RMq+Scp2O2U59mr86tX30L0ao1NipfSvlO/azfb2/g7HYzeQnLJjQuRfO81yRgRfVvy1sSfaocRY8JiM8ExPfIb4TTc1z1XGnqqclV0s75cJXVoijdeeXybkXCbkKKyjE2ItSIi1JCHW4oRYyxJizUuItTAh1sqEWHMTYi1NiJWyHFPaK6WvHpQQK6WvthJi9WqcSFkfU9q+V331nIRYKX0ipa+mtNfGhFgpY3TKPsDyhFgp246UdahX/evlEL+60Q7ZeAn76Lx+8wwh54yAHOQ/IyBnTU05ayLlXFFTzhWRcvp2myxH2W1Y8LXt5rn7PvfvPvnkr/3Rh7Z+8APvHfv8nJ+ZffysR3bs+O6y7yz/2e/t+MWa4+rrjf+yavzzjf/yavzzjH99Nf4x499Qjf9C47+mGv95xn9tJf5sf9lfB0/bUbwTed9cnjczXtxrWSLfa4x/SzX+Q43/DdX4/4/x31aJP/ue8d9eid/9q/HfAQ/bdnPufxy84faP/vPdsy959CNv+/xfX3H/nOWbPn7org/c8IlnDv3mTTuN943VZI8Y/5uq8c82/jur8S8z/rvgYTuK1Q0Y75tB9kA8/7Dx312N/3Tjv6ca/xnG/xbgL2G7tvHfW41/f/7vq8Sffcn4t6JSxd8j/uq3Zv7wl55q/Op//97db/unY5/9k0ue/N1/f867PnXCuePX/O17v7PeeO+vJNvNMf63Ctkd9N4fJ9+2/0kp2aPG/3Yl+xt73/dI6yPv+rft4z71T0OXPPX3N/3jpTPO/PynHlz6h9t/9M3vvdt436F4//KGH33xY61n3/n2J3/zgTOPnr/pl5/93Pf/7r988lda//iVD7/lc/v97Z3V9F4w4yf/3VFsTLH+yDBgrYD7/F+z+D3DTfRH2kBjvDZfPRuEZcVf03mkms4DGeE5p+fqDb9JupSUt3+ufoTkcf54rv4BoUtLpNme8IabbOMfHfbC39zWW0cnYw+DXLZrE56XyOfSWLsaftNN9Zcqdm2SPM4f23VE6NISacfAva/8RoQchXVcQqzFCbE2JsRqJcRamBDroIRYC3o0j4sSYvWqfy1NiDU3IdbKhFgp/SulvY5MiJXSv1LWoXkJsVL6RMq4yuvwkS8r/lo/YAU870b/yvCbQs8q/YAVJM9nl7zPZWV9/9Y77rxj6zvW3b3p1gs23XPf/XduGUBoN7k3xFZBVHyWucm5x7RBejaL6C6m3+sEnxPYgyD3MEhTljBM67Fjng7z8KEtnHg2IOhXENYKwWe6Dwb4nZvw2CbJz68D5bEVe8pBj8X8cc/1MKFLS6ShDX0RQ/WQy+o1201Ep6ImXbjllvtvW3f3bY6uBv2+yKPiEqJb51EtE7gZ/ePnS+jZoAtX1dBgKcZl8ouDMQ522iSnH4z7wfjFEYwHBR97zKh4zss6y3ZlbhDylJwba8q5UcgZFnxtu9n2ix/64nlPfuqkv/3RrD3rNz329lOf+Mz1337nkg8e+bU3fnj5L8/Lp2A+R9NkaP9h0tfKHafJVHk1iH4tTPn8TSEvr2HW5S5q2Pn33/mmq7dsvfeOLW/d8pNYfZ+jq1O1uIJ+Xyn41BXThk/3rF7dNly5lq+tjA907BBoFUTFZ5mrHuiupN9VAt0KSFOW4EAXCk5YKsNCrj0bcP5ApIIYzzWGAplz/aa5useiVRAVn9Xx2F5ummM8NrZp9nmsr2lmvhnO7+ENov1fRZNR07Mn7T5kHfttwAtXvw14sbQBg4KPPSbk1TFeafnIr5bz53/YTbVH226+uvWCZ7Yuvuv0bw//+ZMn/9yyg7/03Ac/9vUfvGPLmX//9W/8xornatau62pGhY15JBoppgus/HHWggd3xxe/fe+KjdewVkHabMJaBYoMimdse+Q3ugbp9SsHTeg3v8hXzmdz5UUNv27TnXfcumnrlove/Jb7t9y/5dYr7t665b7z3nzrRW/d8uatpbvel9DvtYJPXWYkNPIcSpsFaRxQZpGO/IwNmIk8MJavYA2rQfTLCiPP/Mm/r66ajKkqLFaudYG8hkaSbIeyI8ksUs6JNeWcKOSEOq9Vg5LSmefJsDzzMj66NfEc/Q7LHwOaLbZsEP2/gQp3HAUSlO2b/sTGChvPdU7rN+QmbII0Ax79TgL//Br55wDlGfOpdJ4DMlhufr/ao8NphQ4WrFuU97aLu1QXjjcGoz4nk/5oX2Vz9ivk52lvX0cH/5ocfsZylM4mZ05COXOApl3cm92wTLiT1yI5/Cw0n9yi/GRCh9z/LmhpmVgfVdxqEP2tUB8vDtTHAco/lgG3Qb6OGsexmJgYExNi2yCjv6JkG4RxjduggQj9Gm5qncrvT4I8+7CceGb02P7NIto5RDsSoPXFrfzeFo13u35tLu5V/TqN9Ctbv5A/tn69vmT9skXmXL+uhPp1M9UvXMDCdkXbMO1moh2DfMfiziDe/P4Qop1LuOiTGym/hvvJ1gT+bcX9CMkyfPU3v2J8B/Vm38FFIKfDPaaZHH7GcpDf6LgusO/c3dIy0XeQl33H6H8DbHlvy5/HMdIrhZ3t+Xx4znLnEe0CosXDZOaSjvOJV/3tpGNLyFlAuAsD+s8lnDHBN+J0XtXfWH3nCX1HnNZf/Y2Vg1i+OM6++xj57kJIU757Z3HfIPonwHd3ku8iP/su5nU1pWGbgHHsu6QzLqQ0O10veI1+MdEjRn7x2MLWIPjGFsbbIPqnxdjC8rZQyMvz9i5P3rA8cAHdYpJt9P8ByuM9VB5oLyuPUTfVNlwHloAuTLvZY4P/C/T42ZZfFtcLlccc4/0tP91mQccYA8IGhqHigvGNCnlcdxeRjIUBGQsEn5LB8RhthmtjzDeWdkhfIvLmxLMBQb/Ik18nZC/ugLtQ4Kj4vpjS5ok0jl2YX+wPWT1TMRHj3mOB+uKrE8qvFgV058MoFgndFwZ0V/bD+BHqN9jvmLY+E79Nv9vhGcdY8+8hp9sR420Q/e8E5mMWQD4HhV5v8GD+HmB+gzCVz5wOzwYoX6FyQn1Gnb+eK90xlvCzUF/GCR0wFiqf9fXj2B5Kh/kCR8VNXhSv+uGxdRP703e/TMcYn0k0xjgbxqd/9SIfY/CceS+MMUYIpz/G+EnMTTTGaIHvfqviGONUSus0xrA0s++A4GuRviZvwdwJvH8gvAxkod/k9/zx4fmA70Se+L2C0f8A2r1vFe3eqOB/JeGyT/Az9gnmd4F8qjaM7TZWJAy7qXWxxPuQ80L+b9gLK2LH1B9V59X4oSnSGhG6vPmHm07dNPTOP+Z6Zbrws5i+zCsFvdmKx81tF3W9Ehd2OJKNc+bOTbVZfs2ANNMh9+ljSb9FFfWLsR/it0TaXXBfpiwUVish1khFrDE32UexHqp4z3M3ap45L8dTirqt4tArSNdM6BqKQ8zvxG8Vh9R7m/xaRXEI59lL+NfqUP/EsBdUxI6NQ74+AerVFGkxcej2H513z8ev/szBmZsabwfFM45DyidfIehr1vOTVBziWINxaAGlYRwyHVQcqtimnBRjP8RXc0kch2LLQmG1EmKNVMSyOBR6t4BxiPt3YyI/GIf4fdZZ0GdbPXcyFtYnjneq/6b6mJw2V2DmstfCAB/j1VDxFw8n4/eBaozuIA/2DH0defg9utGfB7Y5l/TjOn2I0E+VF66xuWCun24sQIflwuWv3oOH+v6x5cJtxeXUVuC7+hIxQK7hMax8oaLFnWKh4iVbtl5z+6Z7t9x6zZbN927ZyisRM/rtWzWAfHwZBu/anEm/ecVai37PFTidZKoVJmfBPcuNWWFyltD5QMo5u6acs4WcEafLRP01OfwstIrwbMoP1iQ+nrPs6g3kbwXkrKkpZ02knBdzfkacrov5VbNXuyLGjxC/6abmucrGjbkkz2cXy99YNXntjPhRHmJyb0TNcBiWtbJDHixsmZH+LQWQmu07iWTEzkbnrdmd1JJiK94GuvvmTpahVgPjLO9VlA+jP2fJBN9baSSoVsOpld/nucm6lF3ljvyz+nKSyzm/ppzzhZwRwZd5/pocfsZylM6hdtPiCfZKS8STsdh4afipto7OIXmcP46XFePz3Jh2C/VRPW1+i2yxcciDxTPIRv9eipcog+Olak/wGcbLZyhmob6+VbWIO0fgqv4V2wj9ow36vC8iLqO/+eLydxdP8P3fgbg8KyKPapeGihNc1q0OWFcRFvKH+lWzIuSE+lWzIuXE5Cck50DmJ1QXsAyuCejFfZ2xDlhXExby86q0gYDOZXetIH9ol8PcmnLmRsqZrvwM15QTuztkpKacESFnRPBlnr8mh5+xHKVzp3j7RxRv1Y4UlLm++Ms7Ur4I8fa/ULwtm/+a45zofonhN91U+1Xpl3SKD9wvmVdN3v5+SWhchPrw2xq2bf5PrW5DLHxjj/SfpX4JyuB+yXyhLz7Dfslf0DiuW6uipqs+tkmOrz5+keqjWhUVqo9G/wmoj18O1Mcx0hltM+LJD8oNxUTVJw/VlbkBeuXrqk/QxTeT0XGFV0FUXO2xP66ot4mq3swG2cVs+nlb7jv5lDMv/MlU+jvu2ep7S8krLxcQLvuc/Wa+XDde0TMgZOQX+88Y0XG581x7GZ060XZKV32C+Z58OhfXJ1BvpxjLtyvUyqdB9P9QKBy7KxR9aF0gryPEN+LRfVDkYZaH716n9bM8o04qz0b/vwN5bnXIM4+/UL8W8WGflOcvOA/DbqoPIIay8QVusu5l/Qn5p6tNu4Dk+Nq0GWMTz9EOvp2odhwJ70T9VWjThgvM0E7vbuefxx/DIl/4CRoeR+AqS4XJqyCNfqzIe833HfLNLM/9Z0L/54+aoTJVeQ+VqdH/IpTpoogyDdWP0GHCKhbMCdCreQM1xxvqn9br52dfjvFRxG+SLiX9YX9/Q/XTMX9V+xuG+yXIEOrfqb/BfKH+BtP66h73AebS8079DaWTj7ZOf2PMk0/n4toHNebhY7xK+kvbdJkFeqixo+8EjQE3tW4petXHUKsdORY1nG6H25CO9McWRsr7Et8p+hKqLC706OdcXFkg/3S1VReSnG6fJq7mx18H95hmcnwxtiX4Q+/rxmrKGRNyYn39LcV9pz7ROdR+hubdUC73f6+F9vNV1H6i7jHzqKrd5fyj34TaXTU37+svdaqnqn9+FWGVXWOE/CMerNh+mdHfSP2yiu9VN3RxjcuGmDqO+OqdpunVFGkxq6u/2TznT771a+/7c273TBd+FjN3dJWgrznPuh7HvY5kKx+ZS2m4utp0UKurK/bX1sfYD/HVe5zNcF+mLFoibV1FLFsRrd49HqiYFHsil9HfCn2HmLkXbH/WBfIamnvBPHLMcc7vRz+my/DM/jOFLDwJEGnfBPn+/qrJus4RulqMGAzIcOJZ5vy2YRkDgnerm6xbK0I39f4aMYY9euYYB/K9/RU15Vwh5ITaJP5rcvhZ6D3vFSQHMdvFfV4nH6J+01xIU/2m+4v7BtGfD/2mceo3IT+/y+ZV8BgT8otjoPHHnuJp9DugXnU6xRPzGfKz2FM8jX7PNMwzcZ4abmpsza9Lnc6Tb76YbaD8pB2gV++b0Jc5ZofWvFrefnHBhA7PjJXL/2UezJ+ZP4H57pKYl3swPzA2gflTgbpxsZssj+s/P+P6z/z5NSL47H7YTfXdEn4YfTC/4Tfd1DxXmU9T8wPKLiMgg3VpiTRuG5Wci4WcjLA66ZXwA2sGyQc1rfOolgnczGmXs998UJPKGmI/f9Bj8S7U3BxD5c2Ej7oMimdcZMhvdErOoTXlHCrkhLBuFlhGP0PQHyroE7qGpS8HGo7SrBrjdnINxva5hl2DJDO/57d/XDSs46jAyAJ5GhTPuKgzIUvJuaWmnFuEHO4lfJJ6CSi/RLTcadFvCB5y5K84U70T7WWXivyGPyLkmV7qg/Exsx7H/u5DP/+Kw2+/MiN+04WfcZWcLehvEfQ1P7DxmJr1MNmhmTE162HP1KzH7Ir6xdgP8dUs9Wa4L1MWLZG2riKWzXoMAX+oLk9XzOiGnBCWmgkxerPNkNNvijgmGf1nYfT0HM1KKHs78WzATY1H1xZ/RwXWuR7dlWzDz6+W4De6LsbEGVhOqCc+Q/ymm5rnKr1hVT+UXSzvs4UuLZHGZ0ypeDlbyHkxYZlvjrip/pt5/pocfsZ2TvFGkMssBdZIAiy1w+ZMuMc0w+JnXC7IP4fSZgg5qh0aojS02zpKw/Z8NeVriPKC92XjUCb067Sb9l/GtEy1mxZjOMftU2A24/+M+fPo25nWELqjvXiX2GAxVWOxdBR4SsQ2OcNlWJ1sN2Pe5LyEbJdf11BejH4h2G64wFS247ZfzdKPuqn2mE1p3d4p1sW3oNFt33Ts9FcxpuabwYbJi101P9dpm/pmNZ3TsY7jmfoukGrXRikN6/epcO+LZ5gnnplV+k1X3FRybqgp5wYhJ9RPjPF1JUfp3CmWraRYpt6mIu8bi3uenR6EWHYsxTLk5/Ljvim2NfnlG6v53s7M8ui3qtBJvZ1ReX5jQGeU4dzUesNtl9Gvprar4nhatl043mcbcgyuKDd6Nt7wm6RL1Ris+t9qNVi9z+SiVRAVn2Vucu4xbZCeNYluLf1eJ/icwMYZz7LrEjBPIx4+tIUTzwYE/WzCUiM+030wwI8YvvUigx6+/Pc7BE+oBsR4cH51Y0RjWOprZjV7s/Nja6bhN0mXqjVzlORx/jjvLaGLWlvAn/Qt2ztFrEZCrEP6WH2sPlYf6wBgWZo6v4ZHYfnFeyV9a4kwDfULvbhGfqMbEXzcvlVsb0Zj2zc+t6pRTV7w3Cpll5rt95xQe4qYfCZTaEbHZgWGPFi4xgzptxVd6JR+nY+sHpw3WfdufdU1tGCjm36PureL+zzfu+dpmb71jzzCNvrn5k3w7Z03WWc1wvbZAH3IMDhPuM/D0srU13yU/cNVE3JYL37LqPweR922VrLlpvpxyBd4tsVXRj9FZaTWa2ZCH16H90Uoo5+lWRDk59nw0HozlMc+NOSh5zWqRv9+mAWxt6xKv1keeb5Zocs98n4B5H0D/MHy6Uh2Tb+br/wO6zP7nZrJU/U/1B6gn4Z8kWVnAiu0Ltn4h5wuA8NrEP2viDKP9XPfetOPRpZrongiyxVtFbNqAenZbsoP1AoLNdPKfjwosLCsuVw71WXD47r1O4FyNX4sV9STy9Xofy+yXLHfYziob9tFXbJc0VZcBqq9RvqYRZGsa36pNyMzKY1jIt6r+I1+EFPmyr5c5p8UZc59fxUXYtcz5/Nrtue/mEG9Zuvd924pplAdXaEpz8xNnhZENeYJfke8GT3jj4Gq8Bla5GWyh5yecuTwafR/KUweCr/5FbMkHou7G5Pw9izVkvhOYY2n+kLVLNQlPwCuml9rPWpkgt8RViae5Zdapo643AsMRTdlKutd+FoOw+M1FF8NtByhHo4TOoRmgFEflf9RSkO+WR452KKhG3GLZvTfjGzRTHY3WjS0EbdoagSN9Gzv0JcH0CYtokfbqxZtlOR0qoYWXtXICnuVPLJS/hLqmYXso/wLy61Fab6ZFMN2RNeNUTDmh30h9qsSRh86kRFt0yJ65SdqPU9MXMqvkC/gyHG3Z60B4oZGQLMBSzXhPCo3+plFO6G+vT3SIW8xI0C1w1u9geUd8siHMxWG7Yiupj/OUf6I+YmZlQmdwNWproZmuXntP46weNYT5eLajZXTvIaO22+1Y1W1dzzjuhzWzqyaPxlT1fFQGaj1Y+okKXXi+bwIrFBfQJ1CNi8gG/Xi01/5m3FqjVsX2/EZqq5gfOa6UvZ03NCJbaquhL55H7ueby6lxa7na0Ge2T/VzImK4aru4rrZGVR3VR8yFIND676Rn0/FMB3OgDaCTwPptDb6fg/m2YF2R+UhE3mIicWqbmHsC/WzOS5i7OO4qOK1iiMcF82v1ck7+T2vlzP6iwr71TwVSK6X41iHpweqvhev4Tb610LsXjtfY84oiXm58JsuxrpGt2NdpzbJbNJyU8vGt14UsdCm3GdUY+SWwOcx8nVQBjzThvbgmIrxlmPqbCFXxVv81uc7Cj24v5bft4Hu9eR7aryMMYd9z+gfBH++ubhPGTdGKA3jAI/ryp5shfy+09As3bnaa/aj9yTwVysq7oEIfrVCzRnUjJv79ySovooqB9yToPYhIBa+PTdco+lmXAvNxXSyK+/vwjxyfUZsjgMxfTIlz9cne0eX+mT/Qvu5sH5x/cc6zvUf/Z37DerrFdxuqBjGbTbSPwox7L1kG+XLoTkW9Y1w7IvzmB59fUEEVmiuT31FYkFANuqFvCzbVydVXTTbdGM8hf0CrouhsWR+xdhKlVOL6NE2Zesuj8Owfed6jb6N3xF/r6fdxnxgu811d47QFfsD5htYpq91k2WqVzv4jNtZ5Dc6JefQmnIOFXJCWK8VWEav5jC7fDyOqXg40OTP2wHVGDejf/ycsdVQEi9VTJlHb+fiiikj+QprBtzjQb58KDSGl9cTVtnFesjPr8JMl9+lIWbF8PZsaHu/YVc8huFZtK9dqpvp21qIeqkjIWKOwvmtD1015zMfP3P/US6xWyCNXk31v17Q19yi9rRqwvi4G7XlXB2Fs//1gZt6FE7FIzyejrEf4qvp8M1wX6YsWiLtqopYdhQO2osX3nY7xvC0yR+KKbzp1sWajv8amE7s9DqNF+6j7qHFzZyvsvEyi5RzY005Nwo5oc0DMfFPyVE6d9oO/Vnqjs2ANDX1+6binhddPgMHh/536oqpReSZ0+0PtpH5xfWVF4UyzSyPfl8E/+Tt0CrPbwrojFNozk2NCzy9a/Rfpba3YkyV07t8LFwXjmOKXol1oI5jKrcdmgdgaBVExWeZm5x7TBukZ7zg6mL6XWU7tPpMyJDADB1Jr1rfMoeMIa5alMCHK4Zae8RQL/UMQ/Hlv+8QPCkPmujG1mp18FTN7WLRn/3k7WIVe53B7WLqoDCejEReNZnNvZfQNjGUo7DGEmKNJMQ6pI/Vx+pj9RyWGoHyYi1sD+zFohq98KxA2ZEX8hvdiODjdqRiXJ8T247wgTeD1eQFD7xRdql5cPBIRvwoDzH5cKE5Io19bsiDxQtwjP64YsSkFqSyX8cuAMr7UEctmKx7ioMu1YS/0U+336Pu7eI+z/epC7RM31Y/Hska/XYYyZ6+YLLOaiTrswEfSM11JL+6scA1tP1T+T3Ktq3YoS1Wyhdit4afR2XUaTsmbw03+jdBGV1Y3I8Kft5U0Wnb8RuJ3sopdtux0V9a6NRp2/GQR56afcmv9R5560HeNGw7HlN+h/U5Zhujqv+h9kDtoVK+yNsYQ1tXMyEntCBfbWNk3Z2buo3xNcIfuC/BvuHTT9kt8TbGYY8acwW/I96Mns31YBlO/hunH2K2MaqdyhwibhYmDxVZfvW3Mb7otjFe7FEjE/yOsDLxLL86bWPkGhsysTKVRavYDfBGf49w6ZiI6YQOqifAPVtf/nlJo1rmyXLUxvz84hbN6N8W2aKZ7G60aGgjDjmhbVH5VXY5O1e10Dai0DHjqbYxck9N+UtoG2OnbWPsX1imoW1joV71S2XbmNlGbRtjP1Hb7WJDf8gXsCfKI6tOh4343rFjDEAb+raTvEfEAMMc7pC3mB6lemuhtpPwEk61BkD5o9HV9McR5Y+Yf/bHUF7zK6auol9x/FEHTqkuAncjO/lNaJkuvqP9LL1fRjlXk8yyn026Wuiv5BxaU86hQk4I62qBFYrNXV7qZyouA5r8eTugGuNm9I+fM7aq5nipYmp49HYurpiUOys5WU05WaSc19SU8xohh5fyfLIIuzWXCzyqulGWz5ovPB9Fe9mlRlO8kxrlmV7qbOiYJYLfaW38xJ3P/btfCoXRsjuXXyPozVa4uruErcZV02Sy1RJBPikCmxfTQS0RrLjrZjzGfoivmqHNcF+mLFoibV1FLFsiGDododsxg5cI/gV0oXiJYLd1UV0Vrv8VX+REv6jiOl4xlmWhplbZpWZ8G4mtE6YPn7bCtkWfGPJgGS/70JfpRRXKqHM+7t/QiyrVTsSUM+KqFxfsj76lkF+jYY76Sgry+r4Mc9LiCb5v0MsJNY3C8jKQF/oyjPHHfhnG6L8NMYGXQs4SecaXIsMeHRpCbn6/2qPDP1Afo2I9kUshefoA9eE2WC2oU19aUS8mZwXk3FRTzk1CTsrFaK2Azt2W0y7uld02wX0VuyF/qHwaNeUofx8UcnDI28X+cCOmXBC/6abGoCrtYew0qGqfeAEgpvEUe2y7orBSfluFFxMqv9kksMraK+FQ3VS8juiu8ag2KHAz+sfPr6NnvqG6YR/I0NyNqq/knFtTzrmRctbUlLMmUs7amnLWRsp5qdntxZyfTut5TlqoZfrW81hz2CD6jYsm+E6lN69Y3/gtSdmdWMgf2vF1U005N0XKmV1TjlqDFcIKHb6gZufVWv6ETZOlH0d06zyqZQK3U9N0HD3zNU32+0C6w0U15VwUKeel6t4XCay+e0/CVsU04NHbubhiUqtip8vtQvtobVDFO9LaLuqK/ggXnzVQ8T1vFnJVZZea5yzs/whXp735pg9PDLBtsUoNebB4UsroNxWtvpow4EnG2J5NrtvrFk6mQ31x4rZTT+fWhZP1tomt2xdO0LwB7m39WK6XmnDnOld2wn1A5EPJuammnJuEHMby9fZuLe55gvQthW1C6zoGnI5lPGpVax1uEvkx+k7r3tiW6IcjEbLRljEvkkK6dlozxutSUL/RkrpeNc26qmMj1VorjuW8S7Ttoq7o5beGP90fDC63d923BykjVHzGNQnTBukZr7K9hH5X2buupt3Ua1fzEMxTy8PHns3PBgT9KGGNCj7TfTDAjxi+VXiDHr7899sFT6gGxHhwfvmmXFNghQ4Vrfj6f2FszTT8VIeKquUX6pBPy3voQHJM4+lmdbDffCFHYY0lxJqVEOuQPlYfq4/Vx3qRY6mlZHyQKbaf1xR/X2rvr7r9yp9nhdRHujJKw/yEDkFHfj4EHWce2sV9Plr904VaJo5kkfeNxT0vjboY3lv8+UJ/HtHOli/WueYugdGUBw7n9/wJaqw/MygNyxqXlobK4K8j3h2pT2Lzu6NVUAZfoDJAfnyN76s3Sh77SOzMltF/BWY7eC+4+uhTyCfRzu/0yPuamF1Rfmeya/rdwrIf04jtd8f6qdlE+SnP2KiZzjJL7LgM+GMaRv89Ueaxfs7lavT/GFmuieKJLFe0VczZEqodCvkBlhfvLMIyj9kxo87FC5WrOp+Oy/X/BMpV7XJDPblc98tbNIEZKlezZTfKFW0VU66hk49V+62W47bc1HZykLBUjA7NsKpyVWcgcrmOQBk855mRjo3D+/MXWa7djMOhXYKxS9ljy5XjMJYrn8mhPkY43TF6mShz7vNzXPDpp+yW+EyOUY8aCwS/I96Mni3wYBlO5vR3WbhKDDk9BcomN/rDhMlVNUV9VIiy/NjUIxZ3N14KGH6qA21DXc/nFSv+8hFeqpqpl1dcTp3kJD6T4xKPGpngd4SViWeYplwVeUJ72rGFvpVGCuhCPFJQkU/1/I3eTOnrXfBnfIx+daAVKvt5mE6f8TF9VP4XUJr6rAzLwdYRIz+3jkb/isjW0WR3o3VEG3HrGPoUUX6xvRcJevzkDs8qLYI0rtJoYw7VnUIH+7/yUzX6Vr3xgUB+O43K2L/QJ+ZTmhrNhTatdmOmBPPDvhCqS/nFtun0GSse2YT8BOvlfJITikv5FfIFnF34U4qFmP+YZXT4LDQ7x2dsqHVjmZvqeyF/VLOaAx6s2HUqRn+jiFGDHhl2jYhndj8sdC3ht9GbfAw/1RFiap0e6sDdFXU+Skuk3QX3VXzLd2J8XSxLU37Kq/nL+um5kXLW1JSzRsgZEXyZ56/J4Weh+n0uyWkklIN1Zg3JmZFQDvpBm+Sk+KJAy03119UkZ1DokOv18KKJ5/m/mZA2SLz5ZW+rGkT/aZgx31bcq3O4uE7NBDwn6Fd75D1eyKh5oEjUd08wrV3c5/ncRbYbhDQV09h2Rv8xsN0TZDuUzXUb7cRvw2ZCGreRbCvMQ9m1nMhf5pCGJunQdlFX9OeCDT/VIQ1Nksf1gtdPV5w+2P+54NjztvBzwWhTlG9Y3G6q/oaKjTy7ivEsdDLuqcW98uW1JJvLk5+Fdv5lHizMw2qhV4PoP0YxBe1TogyP5ZhrGIhdsb92bKz/+/YyoF5qb0HMIUV/cMrYGZ8450//JiN+04WfxfT31wr6mnsRjg6dn6cOmWhQmuoLqkOKKu4FOTrGfoiv6iavYIktizHnpsTvUPvCadi+cNszLHS3NIxR3BfotNOT36AZ/W9D+/ln1CarODoTnpVdy59RfkJr+RXWYEB22fNN1Qph1sU5f3ug6ofZpuZ8yIyyb3pVOYXe9HY6X5LbM3XAkWoHBylNrWxS7SC3kejbTcjzn3n6jJiPDJ6F5p6xv8l90eEOuGxP1b9R/URV/5uUpvYkqfrPcUPtAStzHrRvm6jvwKAvUHvfjQOD2L8bTvs3jw2M/h8gtn3JE9tmlMT8auQ8uZVjzVjQULEA63vMW2S1rTY2bobmwmcS1kyBFXpTrF5bzhL4/Nry24E3xZg//koUlkGT0mL75VYfcvq5xcFiPGbL79tA9xz5HsY0NT5h3zP6+XCQ2Q9prJsibvA7AowDvItCtTnKz1qCn7/mFPoCY8UDkaLHunwgYd0vMKr6h+0D98/rHDCV/wvtfkJ5ONZFm6qdVNyXn664hnaKiWtIb7Gl5abmkeszxgiOA6od5Bih5Pne61mMCMXIQYGr5h5xfvFhqv9Yv7j+h1Z+o79zv0Gt/uN2w7e6DttspD8IYtgJZBvly6F+rNrBiMtyeO+wOlwzhNUMyFbv+loB2agX79rjHYGqTnZxBeKMbn9fQdlKlZNaqdaitNi6y4fZYR64Xqvvdyj/DPXz84vr7rDQVfUH1HhjQODG1j1emW/0q4v8qH3+yv+x7azr/2pHz6jg278CFLAd0dX09zkHeoV8aCcU+y3GYN5No86cUAfnqrLCsmX/GgMszm9+/7bivkH0Fwf8S9kwFNs72ZB9CMeRofUs5kMv5fUsVrZqPcsYpWHdM5lqvgTXpzw0Npkuxe54Nb48hPRpJZSD+eb3vVjn2sX982fXUHugdgQh71uKe94R9HboA91U3Ks+V4v4Le0WqGcjJ/n5+eBltC33EVXsDuUT6d/myeftoGer0FPVO9OrZr1rlY3rKsaE4nqnNZzcV8E6GTO/jf7ta/OHnC4DnMdD+vugDEJzJbzObbik7qo9UXEE+1fnFHFErUnkkxbK7kIdE3ljLHWmEdZbLvdBp9tDpjefwPlKFZ95vfE4lNW8kzSm8+gw4tF5yEM/n3Qw+seEv4TigDqFg+PATsD8aknM+zyYewJ9DVVPx+BZ2faU+xNox4WUpvpyjjAHBO1bST6moZ+zXBfQV7WpIX25vbG0n4P26j3F/TDhlYzVg6Gyep3QN7asRgL5Yyzjw7UMMXUE7fFvFmvMGSUx3y/adNVXORXwf87TH3Fuan8kvzguq7EF9nNU32CA9Ld24oOiPnZvDJd9uezuOmWb0O66MUHP7Yhzur05idLUOC0TOpRtS3HMN39sMm5oPJ//XU96dOrj3Vbccxz+jUAcVjYM2VyNEdGupo+Kw/MoTfnsdPsj5j9mTiHURnUaD7M/qvZD+SP3szrNA4X8sQV5nUF9u3lCporRZfvcGd1bjB/y0HPMN/pPBvo9ai8RxlXWebGgX0Q0mH9slxY7LRvrJdqEv9ds9J+OjMeJ5jzk95rRbuz/IRvlF9t0iaBHW5lNWkSP9lWxehGloVz2M1VnY+uG8eZ2+OLcybix4ymOq755B47VRv+VkvNzoVjdKR5xPyx2fi4Uq7vpq706P6f8sdO4+o/Iv1TfJ7SXMLbvo9paju3qXU5Ir9CYHvnnBuSM1JQTmnNXJ27yX5PDz1iO0lnVF86PKp+xyPyMUX7GEuZH6cxzxPl9u7h/Pn4tmXjOcVK9W+T2zugPXjLBN1Tcl333FPJd3lM+BjZQMfsqyL9zk+2X6ESgGSlPGLO8IH2nvhfHKoxxvIZPrTND38O202icSxr3Z5SdHw7FwfyKaROxTvC7vdDcMfobx15lS/S9UD8E3x2/b25n/VuB/HbyD37/gO186EwDjLmG7YiuG32A6Tx/gH0Bxwd8mjGWP/cjVL9NxUsuY4yvWC78zsroTyhiaux8a8hvOvWPeCyv5vBC48rp7jv2it/wvC/GnrJ+wzFEffgb228V7wboXvUlkX7Qg8Onk2b0fBY8R743U565j8TYdxO95XPIQ2943Be5EOrKc4FxlsK8h3SY30EHfudi9GuFDiH751eoTzjsptbFEvUm+qwEw2867R9tF3VlbD+Tp/wgv7guq/qEadwmqxio6rnCyhJi8UnFqCeflVB2XIT8ofHXmppy1gg53R5/8VkJ8xPKwTqzhuQsSCgH/aBNchYmlIPt0WqS4xvn3U7jPDWvie3PNcVfntf8D0sn+N5E4zyMFfyubxHgOUG/2iPvnkKGxT+ccywRj+Q+J8PqZLt7yXZq/i9kO6N/Fmx3f8B2XLdVH2PUTbUH9+lxDpbnv9V8Lj5jn0N+oxsRfNxeLYXnZcaKMXUD8Ztuap6rtFdLSR7mPb94/8hB1eTt3z+yTMhT5YD7R9CmKN+w+KwE1d9QsXEJpWE8W0xpWL9PhXuU4cuT9W1D645UPxT7bmq+hX1vuvtKFb/4E+wrqfmhsn0lfsfYq30l1JP7SmXnXJF/LCBnTU05a4Scbs/t9vtK8XKq9JX+n0R9pdXQ3v8ytfcYK2L6SvNEPljeR3ugr/RrJd8nsO2MfjHY7jcCtuO63e8rTeiJzxC/31fy95VUf6ObfaV5HfLEfSWln+rv5FfbxV0xfSnMX4myWxHrm4afqi+l+iWqL1VzHW0797VZBR/2Y6+Fe7QdyplPOtQtPzU3c6DKb241ecHyU3NWKcsP61aZ8lN1k9dalO1Xqvfi3e5XtkiOr43/KrXx6p1WaM2A0f8DrBn4WmDNQGhdAK5z4Dwnes8/eKDXllbdr8rjPvXeWu1zVvtb8b31fZ731hngvkXwct1G+vlCD6PnNaVMw2v6jf6H8A7ma6u0zmpdJ+rPPvvPgfew6l1jaH1Hp3eNoXf0iyhNrWFTdcLoataJFQd6vSn7PfZled0o16/8Wi+wQrrOraErlyOW1RLCUt+PwPywXxr9SNHR7bTe2GzejfIPvYdXNg29h+9kU57vil1vzHNZKvbGvofHGPLVaR6j8pzBUtBlUOhquA2iPwTG2ScvnYxp4yXn4uqsGp/hmIvXI+HYbFkEViiWLhf0ywKyUS/kZdmsp/F1sW7JdXI41ua6pcoJ6WNspcqpRfRom7Lj5aWUFjteXgJ5Zv9MtYaG56xUrAr5Xmxbper/EkpDPo4bqo1TdYnjBpYtxw2eB2F6nms0+lcVAm38hT5SwtflXONy0vEg0EH5N88hGv1GiG3ne2LbjJKYF0W2s1aO3TinDes7x4JQDM6vsnGT6y2WDc+Tqv4s2pT79WajIUGPeA2i3wBlwGcqoD8dRLrHzt/xniT1DuH5cVChx4ibWnfbQHc9+R7GNI4X+cW+Z/RvBX++obhPGTd4bSfGAe6nqjZH+Znqn2EbynwWByyuoC92Y07c8Jtuap6rzFvFzlHXjJv758QPFvJUOeCcONoU5RtW6PzJbsY1tFNMXFPz5C03NY9cnzFGcBzAGMHxY0FAHsYI7IvfR3VfxcjYPgu+h/x/aLyB9YvrP9Zxrv/o79xvQBtyv2E56KL6PNhmI/1DEMOeJtsoXw71Y1cI+oOBZjHlB319RQTWkoDswwT9ioBs1At5WbavTqq6aLbpxngD+wVcF1U5IX2MrVQ5tYgebVO27i6nNGzfuV6jby+DPD/tabcxH9huc91dLHTF/sB0rf1LNVfws1B3P9zjcwWh+fb+XMGEPp1ibMq5gth1iCnmCtg/1fu32HYX1/veGzFXEPK9bs0VcNzopbmC334RzBV8GmLb7yaaK/iD/lzB/rQDNVfwp4G5AoxH3Z4r+G7kXMFnEs0V/AP4818F5gqqxo3+XEF/ruB58OLvS3WuAGNEt+cKvtuluYLbA3MFXP97aa7gf0MMGzloMmZ/rsBfJ/tzBeXqboq5AvbPVHMFn/HEBCu3/LoenvnWsmROj8u5n2WyfWutuJ9l9AuK/ONaK7WfYx3kbdFBOm8YJ9TZfFP2WRw0wbe0uFfjJ54XRdvw2mcsA6bd7LQNVoAehxzkl7V/zU4gjznG4Qf56TYLOsYYEDYIrY3hOKTWojnCHBC0LEP1l5WM+YSp6kR+qf5/aI8G1z1+NiDoF3ny64TsxR1wFwocFYc4ts0TaZmbWqfK9g2MN/edbxSLflV98dUJ5VeLArrzeCC07lHpruyH8SO05sp+s2/NE/nMxG/T73Z45lvPimNTpDFeXrO3RsRMxvSdE/QGD+YFgBmzPvV0eFZ2fSqfE6TqudIdYwk/U+UzQrTcv9wsdPL9Vmv5fTqos/Wn82yfz1DdbAEdn20/l3RHWt6LgL+Vf2d0b3lF/0Ya9m+j3xjwb3WGAur1Bg/mqwP+rex+Gjwru+7e9Amdoap0x9jDz1T5sH9zPNosdPL99u2XVzqEvvM2x4PJMtkf8ov9OxNy8nJ/Pfk3yuFz2svunxkW+jdIhzvAl/i7GKinyuN6D+adAf9MfR676aPiw7wAH5bfsJDVtpsfhy/Ds7ow0/l9kPdRbAU7fX+V1iVjfTpcXTw/q40+bJeaIzxQ52fV3Od3KO6DQz/CfXDqHHcsL96HmIH857+ZSuM9VceQd0txz3XsMRhnbfNgOlcvNl3Qmoybek9X6BzcmPO5Q9+7MR067SXhc8qNfi/UzdB3w9Kc6Zh9/0Cf6ch7SXBc4+s7IVZo7xqeYajKwPD4/IOfgjIIfTeMz90v+43duUJ3VY+xbnA9VvsK1XdZQ/Ue9fa1rf820LaqM+6w3pc9Y53fw6v+3QHajzp2oPej8veCQ+coq/2oI4SD9s51P5pi70NAZ/rgPDH718PFb98cpvE2iP5XxXjF8oHf936I8vEw6GI+Z+3xI6R720VdA9gu2aX6G4bfJF1Kytvf33iE5HH+zFfybzibT9y/9Y4779j6jnV3b7r1gk333Hf/nVtwVzFanKVkhIrPuAZj2iA9m0V0V9LvdYLPCWyMHOOQpizBJ3NgnsY9fOy5/GxA0D9CWI8IPtN9MMCPGMjHHsO1CKP0Q0I216I/hFq08CS/3IfcVDtwTRoW8qzWjROtcxO1bhvlqe2irutja53hN0mXqrVuG8nj/FWrdegpKOU6QjUapMXrOtAM6WfRby69EcHHl1msQTp/Afr4n6J5XszXCaS38nZ8xvMEyG90Ss4RNeUcIeSYJx8PaXxG2apA2hmQdgKlXQppbUq7DNL4G88bRJ4t7YEA5oMCMy+7B5ZNPM//7XITl/J0jqo7ARd58fcMQbu5uG8Q7XfBr75CfjUO/OxX4y6sd8ivxp1fzhE15Rwh5FiZoP+y72xzU/NqadshrU1pj0Ia+85jIl+WtiOA+bjAfH6t7bLJdFz++WURfzc8LxGBr4uN+IbfJF2qRvzdJI/zx/M6e6rJ25gRP8pDTNPHbP2ESDOsvcXvIQ+W8TaI/kdFfWsJGYeQDEtDffGZ2Sf3kx/Se3K0beb5a7j8jOsX5t3Kx+RgvGmDPpkn5mFPCnlXFPccq047bIKvUWCquMhlp+pJ1fzvEnkcdVNtczjc+/x7d0DO4YH8dKs8Dyc545DWLu5z28+l8twDaYOC9/LivkH0h0B5zqfyVHVR2ZnbpbJ2PkHI6baduX15IqEcjCFtuM//PUlYbGcrJ7PzXkh7kvj2QRrS4ajrSXi+T8hW+IbRyQePWKbz5vNBk9Xg/IAPrqzog09QGpYBxgvUA+2A9Jc7na8hD70vXycWeVHffDF+tBWWxQrCNPqTAZPnG5Vv7YRnPKem/OFJkS9l032us2y08zqP7CEX9sUG0Z8pbKrahSdJd8Q+hXTZ20F3rt/Ib3Qjgq9uHFE6d6qT55Wsk7xXw+j/fsUE34VUJ0M+gjrzOKKsnY8QcrptZx4j7EsoB+tMG+7zf08TFtvZysns/BSkPU18z0Aa0mG78DQ8f0bIVvix7cLGZTpvPh80WQ2i//SKCb5Xkw8if8gH91Ea2pTbhU7x8BqiN72HXLi9bRD9TYF2QdVX9JsVhGn0twTaBZOL+Qq1C8oXnxL5UjZ9mrB2Ciy0M7cLyqaY/52Uf6O/I7JdMH41H3EqpW2DtD2UhvMR3Gd9FNKeoDScjxinNJyP4HiH8xHoIzwfcXwgPzhvx/N9OG+3jdJw3m47peG83aOUhvN2j1EaztvtoDSct3sc8mrzdg3K68PF85rvt+ReXt+8KNPhX+fi2gMsq1kk55GEchDrYpIznlDOuPPnZ7uQY+WF9aUb7yMNv+mm1t0q82SPkjzOX7U3I9vgnq2CqPgsc5Nzj2nT8T7yMUhTluCZc8zTYx4+tIUTzwYE/aOE9ajgM90HA/yIgXzsMRk9972PNIwG0f8UtFZLTpqg98lCe3CLabr7VhawDkb/PtCBV0I/CjwqX9s9mL+ybMIe//cyjekEpsrXY5Qv1uFR0sHof170BAaJhvVRz/Lf+K73MY9+qpxYV2zlfPnhcjL6DwXKaZvQAevkug46MM1jHh1+WeggotsFd9/zjiK6OboacM/RSFme39tuEzi+y6yRe6F5JPd7OVKpZ+wBxpvn3Na4FTm/cMudW7Zu8eSdI/csj8wBp6+YNrTiu5/oNtTwU7Wh6p2rakN5Hhh51bwuli/+7iQnL1NbM1aU6TVb777XV6SxjWsm1GJ+R1iZeJZf/IoH0w6UG+ysJi/oBmpoWq4rhc7JVkFUfBayfKfSvph+V+lKqZcmOwWmdaUwT7s9fJ2C3ICg30VYuwSf6T4Y4EcM5GOP4Rri60pxl8Po/wSaJlvaxTz2+w64P6y47+KL/LHYWnWgXuSXq1UcWk3KXEI1GqTFay5ohvS+ZtGu9YKPL7NYTJNZsVRHqpZq3SZTlapqymouz5idET/Km+7lGf+jqN2pl2f8NU0lmW//HQxgvhxY3sAtjOpmqHas5fwRkZdu5/ehJVK81OnRQNpjQvc6y6BOXT6ZLsVr+lA5YvTillD5EfudD+sqwlKvdbmbmV/2KiD0OsrqIb9Wb7uoa05snDH8JulSNc50epXLcWZfNXkjGfGjPMQ0fczWT4k0w7LXD77XB75XTf+H4gzK4DijXqfgM4wz/5um59G2VetJy03NO78u8C0DG1w+OS97MU3wvrG457j8Wysm+IYKzNCSFfWqiGOo8rsnA/nfLuR0284cO7cnlKOWuIZ8Du1s5WR2Vj6vXv1y3WV/RnrEUPiG0ckHFy/XefP5oO816vtXTPAdRD6I/KGlINspTb3WC/kn0r+R6NUSF+WzvMRlRZEX9XpYTTijXrxN0eiPAEx+PazirxothHxRxWtl06cIS40WMT88galsql7ps02PEzaNWU6LfbEyr4exLxZ6Bcx9v9hXwOgH1hfjTU+nF8+H3dRyKNFOy9eiXG/QTvgqGdOcmygztX2vJfgfDsjZUFPOBiFnRPBZvmvaMXqOzfBTbZ/cTvJ8dlFx23hbIm1bcW9+Z8sLfrvwu9w3L6JxwmGoYPHX7Ho8PC+Rz9Nj7Wr4TdKlql2PJ3mcP7brKqFLS6S9Gu4xDeWsEnIU1ryEWOckxFqYEOughFiLezSPKcsxZR6X9Wge5yfE2pgQ68iEWK2EWCsTYi1IiJXSJ1LWx5R1KKVPpLTXooRYSxJipbT9WEKslLafmxArpb1SxsKlCbFS2qtXY2FKe6WMOS+HPlNKn2glxEpp+6MSYqX0+5S2PzohVkrbp8xjyjiRsg+Q0l7HJMQ6rri3OSach3iY5Kgx//EBOch/fATWYQIrlEffMVgWY/YvT7zl/tvW3X2bo4tXU17kUfE0olvnUS0TuBn94+en0bNBQYvYz3/ZoshfF5fEnZIRnnN6WulALYkruzISv8iBaSgntEsfseYlxJqfEGtjQqwjE2K1EmKtTIi1ICFWSp9YmBBrcUKslD6R0l6LEmKltNdYQqyU9jonIVZKXz0oIdbLoRznJsRKaa+U7dDShFgp7dWr7VBKe6WM9yn9K2XMSVkfU/pEyj5TStsflRArpd+ntP3RCbFS2j5lHlPGiV7tfx2TEIunSXBczdMkagy7KyAH+XdFYIVOL1F57PI0ial4MtGt86iWCdyM/vHzk+lZp2kSXpVzXPHFUpsWqbiqSK4G41VaOB3E26bLztQh/6qAnDNqyjlDyBkRfJbvmnaMXt1v+E03Nc9VppfUKjllF8tfxems/av7QztjUB/eh6fCitWfIQ8Wr/40+nML328JGby6PzZ05dOQZx08WXe1ajCmnBFXhcQYf6wqB/2pXdyrVdRcj8vueFKrXhkLVzXjauodRI/lrDBXQzrSX16UV74KeBl8RCin2e6m2iHXZ/3BnXXdLnTlnWXbVkzwbSgwlZ2t3JUf7KS0VUKuwuTYWLbszhA6hLCwvC4leiuLIQ89H/Bl9DdA2fGqeOP3+c9Ojw7oP6iDz39urOA/Nx/cWVfkvZRkG/1m8J/N5D/IH/Kf7ZSG/mM2Um0rr7Qu27Yif6gNH6c0pXuoHQut9lY2ilntPQ7PS7R/fxATjxG/6abmuUr7Pk7yfHax/O2oJu/32Z9RHmKOk7yKr+MGraz2CGzTxXZa+GKL8fKhuuPUju8WPGpIxH2HOsOrbmJ12smNh8G/lWwxDryZ56/h8jPWcRxouA6Od0lOu7hXB4dugntf3RkPyEH+8YCcDTXlbBByBoWcBwCDdxQZTX7VrIuN2NjGr8Yrxprgq3HMX9VX4+NwX7furUqI9ShhjQusTQKrrL0SToWMF7+vI7prPKoNCtyM/vHz6+iZbyrEsFWV3O7R27m4Kon84wE53aj6oZBZs1mPrtqG33RT81ylaqtuxDg846q9S+iScng/XVhdDNMzXmph+sXS3aqD9ariXs2yryU5Zf0P+XcF5IzXlDMeKWdHTTk7Xgb5UWdwt4v7vLv+JwdrmTi9gLzWReSpjV3tCb5P0fQC8o9SHi3NCXkqj8hvdErOwzXlPBwpZ3ZNObOFnBDWqMAy+gcE/WxBn7C7ZioeR3TrPKplAjejf/z8OHrW6c3VgXSHbsixqmbnR3zo0Bf+Pv+5RxptowuYPawbgMfil2iWT80Iz/KCzxC/6aaWeZVuwIMkj/PH3YBxoYsKwVfCPaahnHEhR2EtSIi1JCHWsoRY8xJiLU+I1UqINbdH9TooIdbihFjHJMQ6NiHWcQmxUtprYUKslPVxZUKslH6fMhamLMexhFgpyzFl/Eppr40JsZYmxEppr5R1KGV/IqW9jkyI1Y+rBy6uprT9UQmxUvp9StsfnRArpe1T5jFlnFiUEKtX+6uXJMTiRdE4Rue5BDUefjAgB/mNbkTwZcXfmitWBjPCMz3xGeI33dQ8p1qxouyizsg0XjWFytPyoZUqKEdhbSOscYGl5jYy4u+Uxy68iT2F6K7yqDYgcDP6x89PoWe+qT3DtmqCU0uPEaaaBVWmVQtLHwjI2V5TzvZIOWfUlHNGpJwNNeVsiJTzcE05Dws5XZzuHI0NYwdqurNmmJ4T02ypJmObSOPQOOTBMt4G0d9fxNiWkMHh19JQX3yGC+vvOWQyHeqLC447vR17+yGT9baFvb96yATNO4t7tSDVzj9RR8M84tHB0vPLyhq/kluirKOPDDb8pptqjyq+fBnJ4/xhcxX/ASGOjGgVRMVnmZuce0wbpGe8LeJ44qvyWa4NkKYswR8jwTxt8PChLZx4NiDoLyOsywSf6T4Y4EcM5GOPyei577NchtEg+r1FrVJfOFWy0B788tF09321knUw+qdBB/5y5mXAo/LFtXkD/cZIsNkj/wMQZd59iJbvhHzOH7Ykvq+HXkY6GP1Pgw34a6gPCH7neYY2QF7fb6Q9jPKCv5Uv8pdTH+yQdy5/o39/oPzPEDqYXvm1roMOTHOYR4dfEDrU+3IqRzkuJS6JMwSO7zJr5B77AWqDsdQuFXxn0G/lAXW/nLrKI3PA6WvEad3ya9jVaiuj22bDbzrteW0XdWUcPU0e54+Hy5cJXVoizVdLO8mp+eVUX6OtggXzO+LNxLP8wiPjrKHeBjQ8BN3mJuvLz0JDUKNTcrbXlLM9Us4ZNeWcESlnQ005GyLlPFxTzsNCDmP5FszdWtw3iP6PILDzF3W2gR6q08iL4dUeSrVny+hDRyIoW6qFhSHZaEvfGQaxuqq9R7jglfcdon57Sup61TTruk3oGvoiYs0vc0Y3OYbfFHmo0uSE7PK8YsXfet+TRasgKj7L3OTcY1qoZcmvS+h3leGg+jblboEZ+jZlyLOceDYg6PcQ1h7BZ7oPBvgRA/nYYxRf/vvtgiflN0H527IpsPYKrJrf6lwYWzMP1Lc6Le/7hC4tkca72ELf6EQ5CuvRhFg7EmId0sfqY/Wx+lgvciy1jYy/XY3tp40+Rt3UmMoj1LLvzJF/R0DOAzXlPCDkhLZS8l+Tw89CawD4Jan6jmxGaZifvQE5yM/f/RyHtHZxn49WDz1Uy8SRLPL6vuX8M7Af5bBD/XlEO1u+WOdhkGFpZV7e5qPpH66akJPzYx9nBuD66g/24e4v7lX94T0mWNb8PelxSGuDLsdTGajTfcaFPvwidTuUwSoqA+Tn79uHtk2jPPYR34tePr3K6FcXOuFrBKXfbo88tAfa+Z0eeWeCvG+AP1g+Hcmu6XcLld9hfWW/i+13x/opb2FHP+UZm3GBhX7AMzadTtwyvAbRXyDKPNbPuVyN/uLIck0UT2S5oq24XGO3rof8QG09brmpZb6NsLYJrHF4FlOu4wKfy/WqQLkaP5Yr6snlavTXRpar2bIb5ToOBDHlivRcrqr9xnI1m7Tc1HbyMsJSMRrLOqZcsQw4Rhv9TYFyNf7YOGz0t/RAHEZbxZQr0pctV47DWK6PUxq2dVyXx4WcbsToN4sy5z4/xwWffspuiV/u7fGosUDwO+LN6FnMlgOcVmWTW3Z9h8kaHleJ+4XJVTUdB9ldPLEn+qXAgT6xZ6fQpSXSuCpti5ST0FXz6xKPGpngd4SViWeYNk565M/UojK1vNF4cXmjGmHzSEFFvnGg8c2s+noXhtcg+p2BVijUC84vjtZPCXrsGY87f/6fojTk2+2Rg60jRn5uHY1+X2TraLK70Tqijbh1fBrSBgU92/sZQf800PCs0jOQxlUabfwUyekUOtj/x4UcNfpWvfHtzp/fTqOy8eJezYbsozQ1mlO+YHTdmCnB/LAvhOpSfrFtQr6Dtmm5zn6C9XIfyQnFpfwK+QLOLths2DBgo5y2i7pWGv9ANf5bjH+wGv8Jls8GPLS8GDaWbQmf2Yw2sUt1FQy/SbqUlLe/qzCD5HH+uKswJHRpiTTu0g0JOUNCjsJanBBrY0KspQmx5ibEWpkQa0FCrJT2OjIhVkr/WpgQa15CrJQ+0UqIlSXEWpIQK6VPLEuIldIn5ifEShlXU9btlL7aq3E1pU+kjF8p61BKn0hpr0UJsVLa66CEWCl9NaVe/Xb7wNkrZX81ZYxO2Qc4JyFWyvjVqz6RMk70ajuUcgyTMo8HJ8Tqx9WXRvxKWY4DCbFS2qtXY06v9gvHEmKlrI8p29qU5dir/dXBHtUrZVw9OiFWyjjRqzE6pV4pbd+rcSJln/zlMK5N2W4v71G9Uo5rU5ZjyvqYcgyTct43JVZKn+A6lBW/8d3rarg/FdKR3j7ko95jl3h3e+sI8DjAQOyK76FvzQjPucl9DUf4Ix55+dUUaY0IXXZ/9A/ft+7bf/zNjPhNF34WMzZR77TNVjNJ97aLum5Ra0hMtqWhj8ygNLSL6ZD/ta82mH7c72u7qOuWGPshfkuk8a642LIYc5N9Af191E31/+0kZ0DIGRByWoI/JGdDTTkbhBzGij2vxOifab/wF9eqDQoZuA4xJgZUXBsS/aFJw2+6qWVdZS1Kg+Rx/ngtCseV/FI+fBfcl/FhhfVgQqyQn46TnLJ+Oh4pZ0dNOTuEnBHBl3n+mhx+xnKUbULrsarKwTrDu1dnJJSDftAmOUMJ5WDbsZrkZEKHXK+PtieeY9uEcQ1l2q7lBtE3VkzwfazANB9UbSbL4/jF+WB5v9l+4a/Fv2HiL5I7XjhH5girk+1+uz05L4OQFmM7o/96e4Lvd4v7USGb6zbaqUFp2M+ZQWlsK8yDpTnIAz5jn0N+thvycXvVJB3aLuqK/piu4TddLf/Y3141SR7mPb+4nzmrmryGyZst5KlymOu0TVG+YXG7yX0aTMP6OExpqi+rYpCNjZQvryXZXJ78jP2O+RVW2TGb1cOaY7Zju9hfOzbW/w1/xCMvv9S64pgx2x+cMnbGJ87507/JiN904WfsZ6oftVbQ1xwTHa3GbDwu47xjmho3qTFbxfH30TH2Q3xVN3nMFlsWMWO2UBq2L9z2DAvdLQ1jFPcFLGap9hNxG0T/nfYEX7ZiMqaKozPhGfvmiKDnjxNjfjDOjkRgDQZkzxH0IwHZqBfysmxfe6Dqh9mm5r6YGWpfzCwkAFxfOSF9jK1UObWIHm2j2sFBSsP8z6I0zAO3kejbTcgz++egyEcGz3jfTSZ0VX1R1Y8L+Z7q3wwTTX6p+t+kNOTjuIH1n+MG+ijHDSxbjhsqliM9jyH2l39RFhbH0UfqjiHmkI7YB1P+zWMDoz+y0DG3xzxPbJtREnNhgdNpv6SVY81Y0FCxAOs7x4JQDM6vsnGT6y2WzUzCmimw0Ka818lsMyToEa9B9G0oAz4xAPM3m3THMmhSWmy/3OpDTn9BoQeP2fL7NtCtJN/DmKbGJ+x7Rn8x+POxxX3KuDFEaRgHEIN9KuRnLcGPbSjzWRywuIK+2I2xruE33dQ8VxnrqvqH7QP3zyvGzf1j3VEhT5UDjnXRpijfsLgvP11xDe0UE9eQ3mJLy03NI9dnjBEcB1Q7yDFCycMYgX3xC6juqxiZCVzVZ8H5RZt7VHWc6z/Wca7/6O/cb0Abcr9hDuii+jzYZiP9eohhN5NtlC+H+rEtQT8KNMOUH/T1VgRWMyB7rqBvBWSjXsjLsn11UtVFs003xhvYL+C6qMoJ6WNspcqpRfRom7J1dw6lYR64XqNv4/zFzZ52G/OB7TbX3WGhK/YH1Jkfdra/pe2CtFVusj7q2wBIv53o7eiiIQ+94TWI/o5CX3VyIh6HdIZHHuqHz7iPgPx7PFgYbzB/6z263w268zcu1En46vMwRr9X0OMZNaaPss1ep2VjfvC8ET7p1OjvF/np4il1c1RsQLtxbAjZKL/YpqFTKNEmLaJH+1oafiPlCUrDusOnUe4QOmyHZ1yv0e/wLJebi80lVv47ga4X6/VO8KVQvX7MIw/1C9Vr5C9br9/k0f3JkvX6MaFfL9XrZyPrtflUv153rtfqWzux9dp4czusP3gy7lOQNuim1nUuY6P/+YDPqrOKQqfxdjrnir/z8xSkPUNpyPckpeH5WBx33uWm2gHpue4a/S+BHVrFhzWVr5teNX19RPn6u4CAff1ZSBsU9FwW7xb0zwKN2aRF9Fwu+BuxsKx5Ds1sNOR0GRheg+h/HcqA59CwLr6LdN9eUnd1fKU6ThHr1OJi0bs6s4zPvdsXkKnis8kZ8tAbHtfd3xP24tiI9QD14r6p0X88EA+ULfGkWPbBTmed8VlvaJenKQ3PN8NT5A2bMbvRFmH+u30moJV/y02tP3wOHNYN9n/VRsb6/yQfWq7zi/41Drw8X2z0/y3gX8omoXMs3yXo0U7jxb1qU95Facq+o0TLfogxFe2A9Le6yXYw+i+AHULtjelV05/PU/6MbQr7c6j9yC8ui/cIemxTOGa/B9KeJixVl7Csub0xGw05XQaG1yD6r4v4afphLHqWdN9XUvdxobs6dxHr1Mbi4Cl1Dib3KfcFZDKvr71Bel97831hr4xkqPYmv19BmEb/XMn2BmNX3fYG7RJqb8wXutjenH+g25vx4l61N/xFO6wb3N6oMdY4PAv5P/rQecs0rq+9uby4Z/8aOuyFv8q/VL1RcwYhfwydm6za5dC5yWpcxOdNq3YX6blft9+vwQ6h9iaRP89T/ow+y/4c8s/8Ktv2m01abmp7wPFQ+SyWNbc36gzvpwQ+n+G9FMqA2xscQzxNuj9RUvdxoXun+nYEtTc4n8TtzRMBmcyL8cLX3hgej0UOF/bKSAbWA7TTCsI0+qMC8aBTX7nsfJLpo2zKcxqoO37x1bAZs2b9nH+gv8w0XtyrPhXPtakv8LEfoJxxeBbyf/ShudTe8BdQEAv9IuSPWG9wTRvSnxXwx1A9y6+yc8amT2jOWL0LCPmj0dX0x+sO9Nwvj7dDc7/oj9w+7xJyYsfbuyCv2bLJdPgOMCv+2tqZS+F5CZtHf+LE8JukS0l5+9cjXUryOH9Wdvk78fjvnq+Ce7YKouKzzE3OPaYN0rNZRHcx/V4n+JzAxhU2l0GasoRhWq3EPF3m4UNbOPFsQNBfSliXCj7TfTDAjxjIxx6T0XOMmiuE7AbRvxqi5sKT/HJXuKl2WEG/7xDyuljrxl4etW4uoRoN0uI1FzRD+ln0m0t0veDjyyzWIJ23FF6Ue98txb2V/GHAy3tvj4c026+TY/wMYawiHdRf1B2fcfuVIlLw+8n84q8W41f2bojQ4TKhc0vwG92I4Ktqm1ZAZ5OzAtLaxX1eVvceNvE8/7cB0lQk4venRv818KH7i3uzJdZY01HZ+UY3WZeydr5RyOm2nW8kORsSysFzOtpwn/97kLDYzlZOZmf8ovWDxPcQpCEdtnJ4ZsRDQrbCN4xOPvj4YTpvPh80WQ2i/xPwwd3kg8jPsfoMkR/l8+yXQx76M0g/o98XGMevEHlGvXg+y+ifCYybVrip+VKxMpQv9KkVnny9JzCfo3ohqm05ldKwbbEYjm1LgzD+TXEz7KaWR4legtzz5NMb6Uzuqmpyo8cght90U21YpTe0iuRx/qr1htD6bBVExWeZm5x7TOs0BrmCflcZg6gocJjAtIii+vXMx7WQnw0I+lWEpWoQR2fFjxjIxx6j+PLfI4InpgZU7J8PxtYAw09VAzqVu/mq5f1SoUtLpOHODkxDOZcKOQrreMI6PlLnmh8t5UHHKo8aA4LfES9Xbe7YHyaytAKerfPI9jXChtcg+t8UjVWIP79i3B6LqBuB3/BTuX2sC/EgDnlDjXzmppbhNLlqfl3hUUO1KI6wMvEsv1RfkveST5cb/9dAn2tY8Od9p8+NTpbdqZ/NYz2j/1Sgz6nGBqF9Gw8LehyPmD6jpAPyjgo+HmfiOmU+P/ERN9UOSM9rZY3+s5Hvkk2vbqyVfQQI+N3AOKQNCnoui22CfhxozCYtoudywd+IhWXN9cBsNOR0GRheg+i/HKgHOE5/hHTfUFL3FUJ3Na7FOvU4jUFRJjelDwRkKp81Ob644Rsj/11gDKrmflAvHoMa/bcD8SA0T5Ff7IMqfjwo8qVs+hCl4ZwEzgcZNmN2Y60s5p/rZyiv+VU1VracP+apusH+v0HIifV/9CGeW9wGdIar9mga/fbit/k40/C5Sfv3jxz+wp+8PL5GMQF13Ub52M/vJtp86949Srq3XdQV3b0z/CbpUlLe/u7doySP81dtXM+9HbQKouKzzE3OPaZ16sVdSL+rjOsfgzRlCR7XY54e8/Cx5/KzAUH/KGE9KvhM98EAP2IgH3sM1yKM6tuEbK5FY1CL+N0iyt3mptqBa9IZQp7VuseI1rmJWreD8tR2UderY2ud4TdJl6q1Tu1WVbsby9U69BSUcj2hGg3S4nU9aIb0PMzn0rtU8PFlFmuQzscWXpR737LiftRN9djDSW/UIRS/WoLf6JScI2rKOULIMU/Gcz74XemIyKulYT+lTWnYNh9CaQ+JfFnawwHMRwKY4yItL7uPHD6ZDqNR5vmbX4PiGdv0UaGrOn8Bpzx8tW1HQA7y87nYOxLmR+nMfQzMa27f0w6feJ7/exzSVGtg/bcG0X9i1QTfmVTfHgd+01HZmetiWTsfLuR0285cp3YmlINr09pwn/9T5wGgnXkeQq0nND5ch4h02CPANXdqzafCN4xOPnjp4TpvPh80WQ2i/yXwwXUVfZD3SGMZcHsYWmuIZcD58u0z9eXrGugR8VzDo4Jf6c7j/p0B3fOLfRH5ja7bPs+rwXz+8zryH1zHqfzHxooNon8W/Ocm8h/soXUj/6F6jT05HjWoese2VHxYR0+J0GG30Lkl+HGtMvPV9Q2lcyffuIt8o9PZIrxv1ugfBN+4h3wD4yfvJUKduQ9Y1s5HCDndtjP3755IKAfXbrfhPv+n1oujnXnd3F5Ie5L41F5Cbt9wvbnaO6HwY9u3bYfrvPl80GTxXrpN4IOPBcY0IR8M7YnhPRVq/4Mqg4z0HvLQ+/YZPSHat1B9Rb/hWG70+wAzZp9R6CygFPuMQrLRzus8soeczr/PV94TsKk6jwjzwzY1+p8O2FTZKGTTTvuTeD8M5pnPAFAzbWjnGJti/h+j/Bv9+wP9sJ2CX/UdHiVdVD8M6fn9i6pjqm/CdewDkX1I7tvg3AKvlcO5hccpDecWeCyGcwu7KA3nFnieA+cWuP3DuYU9lDYOaej7NrfAZyr/avG85hy8XNP3KOmG50dmnr/OxbWn6ns13Z43YTmPJZSDWDYjr8Zsx8M9ppkcfsZykD80NhypKWdEyGEsjMltoOH3qkb/R1Cvv0ox+XGh3wg8WxfIK9dnxLIys/qBsa9E/Yh+R2X4TdKlpLwsFHMxf7wEaZfQpSXSfGWKco4XcsrqNdtNnIFbzOJfuOWW+29bd/dtjq4G/b7Io+IyolvnUS0TuBn94+fL6NmgoEXs6ap6B1LOCTXlnCDkdHuq8wSS4xvu/I+SU8q8vMPor4ThzlcCwx1ftUNfw+Uk7Nsmz/e6/wGPfv8TQu/XKPQ+IPK8PqDz4yCD5eb3qz06fIu6KhVDseyq8FQo6sOfqMGuB5YNpjk3YQt1jHpL8Dc9WL5m0uzKXbp/KNlMhl7Uo06PUxo2TWwHJUeFd2WHkJwTa8o5UcgJNftVY4nSWQ0l2sV9XsY/pliCR7CqLg3HEqN/JcSSgWJOS8US1JF/q7jsayd9sWSHR7+ZhU4qlnDXEPOpdMYhIMtVsWT/kK/QwWIJvwpqu7hLxRJ+NYH6nEz6l20LkX+62sKTSU63X/up6X6OL+p11K6AHPVKrVN9POgILVPVR27XJtFDfTw4UB/LvKrrduxlrNg2yOiPhDpetw3aEaFfw02tU/n9SZBnH5YTz4we2z+evthJtI8HaH1xK7+/rrjvdv3aXNyr+nUa6Ve2fiF/bP1aXbJ+vaG45/r1vRMn+M6g+oWvA9iu/AoAaTcT7R7IdyzuDOLN7w8h2t2Eiz650U3Or+H+/BET+OcW9yMky/DV3/yK8R3Um30Hp6hPh3tMMzn8jOUgv9FxXWDfufgILRN9B3nZd4z+SbDlpUf488jTrCnsbM/3wnOWy68gnyRanMrnaeK9xKv+dtKxJeQ8Sbj7Avrza/o9gq/br1ufJDlPJpSDWL44zr77WvLdfZCmfPfO4p6PeLwFfPdG8l3kZ9/FmMpLKNX0X47//5LOTwGd2el6wWv0TxM9YuQXjy34mGWmMd4G0d8mxhaWt31CXp63Ozx5w/JQxzA3iH4nlMedVB5oLysPdVQ414FnQBem3eyxwVbQ4y1H+GVxvVB5zDHeeoSfbrOgY4wBYQPDUHEh5jh+R5gDgpZlxB6Ry/EYbaaOjn1Xh/RnRN6ceDYg6J/y5NcJ2U93wN0ncFR8Dx0Jy0eQq1fbsUcQYtx7baC++OqE8qunAro/Q7o/JXTfF9Bd2Q/jR6jfYL9j2vpM/Db9bodnHGPVq36kMV5+1f9sYD5GLd9Bvd7gwXwvYMYchX06PONXRaFyQn1CR2Er3TGW8LNQX8YJHTAWKp/19ePYHkoHtfxGxU1efqP64bF1E/vTF79Mxxi/lGiM8TcwPv3wi3yMwXPmvTDGeJxw+mMM534v0RjjP4DvfrziGIOXUnUaY1ia2XdA8PH2AZP3Lej7/jHhjYAs9Jv8/hC4R19sCP78nt8rGP2noN37VtHujQr+V5I8fK+j3vWwT7xS6OXLp2rD2G7foPchWBdLvA85L+T/hr2vInZM/VF1Xo0fmiKtEaHLm3+46dRNQ+/8Y65Xpgs/i+nLvFLQm6143Nx2UdcrR0CGI9mWhr69j9JmQJrpkPv0saTfUxX1i7Ef4rdE2l1wX6YsFFbMZ45isR6viDXmJvso1kMV73nuRs0z5+XYPPKFexWHXkG6lo1DyF8mDvF7G6MdKnQ1/+LtdW0Xda0O9U8M+8mK2LFxyNcnQL2aIi0mDt3+o/Pu+fjVnzk4c1Pj7aB4FrMk/RWCvmY9P0nFIY41GIf4c4sYh0wHFYcqtiknxdgP8dVcEseh2LJQWLsSYj1eEcviUOjdAsYh7t+pLbYYh/h91twjJ2hmHzkZKzRXrfpvqo/JabsFZi770EK2pVm8Gir+4vYEfh+oxuj2G5+hryPPDkhH+iVgm4WkH6+rO0Top8oL19gcdKSfbk+ALtS/V+/BQ33/2HLhtuIwait4LWTbxV1qDY9hzf7Jv0XFfbH8+JItW6+5fdO9W269Zsvme7dsHQQk1I6R7LflGvn4Mk145fE4/eYVa7vo926B00mmWmFyFtyz3JgVJmcJnQ+knLNryjlbyBlxukzUX5PDz0KrCM8mObgypV3c57Xl5CMnnqO/4cgfV6dcVfzlqPzF4yf4Vgd6kGxnrIXnucm6lF3thvw7+nKSyzm/ppzzhZxur0Y8n/KDdYTtVrZeI//j0yynU72+8kgtM7ZeG/3TUK+vDtTrHRF5xLZunZuMFVq1t7MD1lWEhfyhQ0t2RMgJHfyxI1JOTH5Ccg5kfgxLrfDDMrgmoBePUnZ3wLqasNRBHsoHWeeysxPIPxKQs6umnF2RcqYrP9trytkeKee8mnLOE3JGBF/d9kPp3Cnevp3irTqoCePt+uIvH2j0MMTbByje4ojnpW7nbr01bpMcX3nupPJUb3ND5Wn0b4Dy3BNRnso2vlWRKDdU1urgnExghVZusx2QXrUpXZxRjf5MIb+9qfiWav/maDULivnDTcgLivtiFuC8LfedfMqZF/5kCuAd92z1za7ORaFu8pt1pHf0m/ly3RpEMyJk5Bf7zx6i43K354wfo1Mn2k7pKtbt9eTTubhYh/wjHizfbhb+mLrR/5uinqvdLKpPhj60LpDXncS306P7oMjDLA/fvU7rZ3lGnVSejf4XAnne1SHP3H9XfUeOTUw3KPIw7Kb6AGIoG1/gJute1p+Qf7razgtIjq9N+wi1aWoHDfLeV9zzDpproE37VWrTVF+w2/nn/ut2ka/7gMY3tml4MHn1htH/dpq3j3JGmd+gNIX+ef7+M5WpynuoTI3+IijT348o01D9wN153HapWPB4gF6NFdUcU6jfaOXDK2TbLubKvhzjo4jfJF1K+sP+/sZeksf5q9rfMNwvQYZQ/079DeYL9TeY1lf3uA+wm5536m8onXy0dfobezz5dC6ufUB+ozP/3E76t13U1TZddoAeagWzb+fvgJtatxS96mOoVRocixpOt8NtSEf6/wZ9ie8EVsVd6NHPubiyQP7paqsuJDnbE8rB8moX92p+9XVwj2kmxxdjW4I/9L5gT005e4ScWF9/S3HfqU/0P0vMk6Ncnif/p+Mm+L5J7SfqHjMPF9rtz3XLuXC7q+Z2ff2lTvVUza9fRVhl320gf2i3vtLdd/LP8FHFXze1zSkRVzfwKgTDQOyKfb4NMXUc8dWqB9OrKdJiVoV9s3nOn3zr19735xnxmy78LGbu6CpBX6//5daPgAxHsi0NfWQ3pc2ANNNBrQqr2F9bH2M/xG+JtM1wX6YsWiJtXUUsW8mlxtgHKib55l6w3CfFzqLux54kgu3PukBeHyc+daJKfnHMcc7vRz+my/DM/jOFLD7E1mgXQr6/v2qyrjuFrhYjBgMynHiWOb9tWMaA4N3qJuu2K0I3NR+EGNs9euYY6h0i+23Z00t2CH2UnCtqyrlCyAm1SfzX5PCz0PvIK0iOr9+08qiJ5xhPfP2m+4t7ft/1t9BvOrbAHBX8/M6VV+9hTMgvjoHGP+T0vCbHE6NfBfWKd7uq+eH7AdPnZ7G7hIx+NfVnujHPxHlqOPERRzf5E+ioo2++mG2g/KQdoFfvm/C9G8fs0KH6lrezj5nQ4RXkx7NdOP+XEabRn3X0BOa5JTEv92BeedQE5nmBunGxmyyv7KmSyM8rcNUh3MOkZ0k/jD7c2PCbbmqeq8ynzSZ5PrvwHADyqjE9t41KzsVCDte5TnolPNzYVFxMdOs8qmUCN6N//HwxPVNTcoidu/mni6qphsc3e3RzLm66B/lDw/BDa8o5VMgJYd0ssIxefY/4UEGf0DVMxeVAw1GaVWPcTq7B2D7XsGuQZOb3jxO/mrlAHUcFRjOQp0HxjIu6KWQpObfUlHOLkMO9hPupl4DyS0TLnRb98NPWHPkfqYgdG/kNf0TIM72aIi1m1uPY333o519x+O1XZsRvuvAzrpJqlHuLoDdbVTyS/zE162Gy1azHI5SGsx6mg5r1qPjW4bEY+yF+S6RthvsyZdESaesqYtmsB35CJVSXpytmdENOCEvNhBi92WbI6TdFHJOM/hEYPT1HsxLK3k48G3BT49G1xd9RgXWuR3cl2/DzqyX4ja6LMXFG2ZjYdFPzXKU3rOqHsgu/qUJe9eaJz8YoOyv4YsAy3xxxU/038/w1OfyM7fxIQqztCbFS7FRTK7zOhHtMMyx+xuWC/PwJmoeEHNUOPUxpaLd1lIbt+WrKF9ZJjt9l41BT6GdlgSPvdnGft/cfOErLxNkW5OW3mUb/lysn+D50lD+PMefrI73vfP0PU9+1G+frd7LdR0rYLr/4c6hG/+tgu18N2I7bfqwTj1CamiVXq8h9Z1Q7F/cWCfl9bx4tPb9qvjmLbvsMX73prNL2qTeXKsbUfHPZMHl7hTxVDnOdtqnvs5b5pWIdxzOMdbybANu1XZSG9ftUuPfFM/UWcjSg33TFTSXnhppybhByQv3EGF9XcpTOnWLZpymWPQJpqh14Y3HfIPpfgFj23yiWIT/qyL9jxhcmz/d2ZodHv78OvJ1ReX5jQGdcBePc1HrDbZfR/w9qu/jNVNvFXaFzJUL9uZpyo2fjDb/ppsaNKjFYrQZT/e/cz+YV98XU5rq7N916waZ77rv/zi0DCO0mlxhbBVHxWeYm5x7TBunZA0S3ln6vE3xOYOOMZ4ovnKh34Y8IufZsQNDvIKwdgs90HwzwI4aaCTIMxZf/fofg6dURjWHtFFg1e7PzY2smrwOruN5tf81U6xRCe/zUmjS1xgm/kodpKCdmjVPmpr5YqYN1SB+rj9XH6mMdACw1CuNZLGyneK+kWqOQURrqF3pxjfyhF+RX1JRzhZDT7X0XV1B+sI1ku5WdgUR+PqWuCWnt4j4fkRyzUsv0rZ/jEZrRvxtGaMevnKyzGqGhDXAEhOVgGMw7DDpYWon+xWg+Svvhqgk5bFd8Y5n/C/VD8ntba6fWMcas1+lURmdQGc2GtJg1jkb/EJTR2cW9WsfFs6mh9Uooj+vhkId+Nuln9K8qdMK3dEq/7R55vlmFyz3yLgB53wB/sHw6kl3T7+Yrv8M4w36nZoJUPAvFC6xb7Ivow/xmtimw0A945sT4h5wuA8NrEP0Vosxj/dy3XvGqyHLFfY+GY2l1yxVtxeWq3nojPZer8gP1hl7N1D1IWJ3W+HG5Gr+vLvN6ZaN/XaBcjR/LFeMil6vR3xRZrmbLbpQr2orL9UFIU7aNWVSH5WV5UzPr45SGMZFnrlX8Dq1RV2Wu+ndc5m8SZa5m8GdH6Odbdzq/uC9m4K7Zeve9W4opOEdXaMos/73Do8Y8we+IN6Nn8yhNhc/QIiGTPeT0lBWHT6O/V5g8FH7zS7my5cemirC4uzGJa/ipllTHLl22vIeqGab1gKvm11qPGpngd4SViWf5pZY5Iy73AkMmVqZSa7VCLYfRbw+0HKolVCMio1c9d/WOT+Wfd1Qh33aPnNgWzeh3R7ZoiUY+skVDG3GLpmYWQqeyqffZarZU7azn3ql6HxxbDS28qpEV9ip5ZKX8JdQzC9lH+Zda16DWVoRGwUbXjVEw5od9IVS2+cW2eULQY3lzrxXXFvDME9al3SRHjXpifQFnO3gmRK1LDI2AtgOWasJ5VG70HxQxwDAf75C3mBEgxnFez6Nm+9TpCriuwLAd0dX0xzkpZ2Xyq2xd5fiDfrad0rAt4FkcbEPw3f+np3kNFrff+F0M1UXEXaFI/zswa/TnVEdiT+E0+r2CHuv9bMoPxou9EVgPB2Sr78jsDchW30lkXZzQE7/TabIsDU8EzK+KdWWGqisYn7muhGJxfsXYSpVTi+jRNmXXg/GpFLHrwXZDntk/VX9RxXBVd3Hd5Ueo7mL95NF22Vl71R5xn/hz0EZ81dMn9tXr+z2Ynw+0O53a1Jh+tnqzoWIf97PVrKSKfRwXVbxWcYTjIu7OdoKe11sZ/dcK+9mQGWNJibos11txrNsDOqi+F68BNvp/gdj9jZUac0ZJzG9FjlkSxbpGt2NdpzaJ16li2fjWGyKWWovK9WzI6fGS4fHbth8EZtow3nJMxXjLMXW7kBvaa5DbfenRL9xzfy2/bwPdv3rGWeh7GHPY94x+OZxu4Ir7lHGDv56ivgnH9ce5sJ+pt4Ix38yuueY7ek176tNCVf1TcwY14+b+Ne2qr6LKAde0q3XsiGWxarrjWmguppNdeX8Q5pHrM8YIjgMxfTIlz9cnsxgRipFV+mQfoD4Z1i+u/1jHuf6jv3O/IXSq6F7QRfV5sM1G+sMhhp1OtlG+HJpj2SfosS/OY3r09X0RWKG5vqcE/b6AbNQLeVm2r06qumi26cZ4CvsFXBdDY8n8irGVKqcW0aNtytZdHodh+871Gn0bvzDC/tlpzoXrrjoxDfsDalXXa91kmWVXdSF/aPXYoTXllD1e5bUCy+jVm+NpOl7lcKDJn7cDqjFuRv/4OWMPClq8VDE1PXo7F1dM6pUTY1kIzy88CHYH6YVvBl9PWKoIHwzohfxGxwuUbiyq37CQXyK8PWvVUW0PN+yK2/ifzQjPOd3N9G1NQ72aIi3mKJXf+tBVcz7z8TP3HwUSu4XO6NVU/+sFfc2jSp5WTRgfl6K2LKOfOtIhb7r4KJWKR0A8HWM/xFfT4ZvhvkxZtETaVRWx7CgVbCqt7kxXjOEDJjcXdRmn8KZbF2uCbxe6hOIYTv2FFn6zjR8M5KtsvGxGyrmxppwbhZwRwZd5/pocfsZylM5qyNMu7vO6fz91xx6CNDX1+6binhddrjxmgu/tNI2C/Lx4kNsfbCPzi+srLwplmh0e/R4C/+TttCrPbwrojFNozk2NCzy9u38ZCrW9FWOqnN7lY8XUNu2acqNXYh2o43zKbafl5cloFUTFZ5mbnHtMG6RnvODqYvq9TvA5gY09XJwsUZYwTKt5aouqan3LHFKFuGpRAh/OF2rtEUO91DMMxZf/vkPwhGpAjAfnVzcPG9ohsPho9ZI1JfqzkYbfJF2q1kz1Uk999oQnI5FXTWbzqKrs8eJqYjwF1uMJsQ7pY/Wx+lg9h6VGoDsoDdsD/jy82taQURrqFxp5xW5bvaGmnBuEnBHBV7XtawV0Vkd/sN3U8Ruhz2upg+DUYs12cZ/3/P/4aC3Tt1WMR0JGvwRGQn969GSd1UgIbaD2EKgZHqMbBh0sre4CSbQrv6QIfWYmv7etvKEtOsoXYsvoc1RGnbbz8dbi/faHMvo8jVZD20I7bVt9I9FbHstuW/0SjFZD21Yf9sjzHey33iPvb0HeNGxbHSu7bVXNuKh4FooXag9Oy0314XFKU1vJTU7ZLa1qG1xoS6vRf1f4g3oJ14zQT9kt8Ta4RzxqzBX8jngzejbXg2U4+TMcvrLJ1TY4tdOVQ8QPhMlDRZZfI+KZ5ceGeOhC3Zh8Mfz+Nrj9UA5E+WZlMqEW8zvCysSz/Oq0Dc532IDJ87USoSgSs4F6qNBJbYNTEVb1sEI9ATU3H9oGqHo9D3vkqG1w+cUtmtHPgbyGWrREPSnZoqGNuEULbavJr7LLobmqhbahhI45TrUNjntqyl9C2+A6bTti/8IWPLTtKNSrfqlsO+JtcLhUjUey2BztJDmqFxXrCzh6+mPPOybERV/wvaPFGIBNuG87wnEiBhjmIx3yxjZXM+9q1ju0tVcdF4zvAw2bMWv644jyR8w/+2Mor/kVU1exjQsdEsPLSLEt4G5kJ78JLfPEd3z304gPdb2aZG4P5C2/eOYB+bncUc6hNeUcKuSEsK4WWKHY3OWlYqbiMqDJn7cDqjFuRv/4OWMPClq8VDE95NHbubhiQv6QOzRrymlGynlNTTmvEXJ4KcimIuzWXNr0qOpGWdnVfGH2aEZ4zrngCzO1+tT0aoq0mCVm32lt/MSdz/27XwqF0VA34AlB/xpBX3NXxLhqmnhHKjZNOykNmxfTQS0xq7grZTzGfoivmqHNcF+mLFoibV1FLFtipr6/PV0xg5eYvQG6ULzE7EDErxtqyrlByEn5kr8V0JknOrG9y+vIW46ZeI5+4DsBhie3jf7Tx03wbaVpCOT3dRuwrcQhAPu1yYv9soHRvwN8ipdiqZcubwzo/DjIYLn5/WqPDg9TG1WxHZFLsXj4ifrwBHLZF1vqpYmSc1NNOTcJOaEFLFXridK523Laxb2y2ya4r2I35A+Vz0M15Twk5KgXcrgIqov9qUZMuSB+k3QpKS+4AElNo5VdgIQ2xDSUE7uw4IGEWLyYSfnNJoFV1l4Jh3qm4nVEd41HtUGBm9E/fn4dPfMN9Qz7QIbmblT9Tu/NP3iMlul7b86HBBj9D46d4Psl6lqgXqOUx7IfeEX+0Idkb6op56ZIObNrylEzUSGsUYFl9J02O3ehCpuKxxHdOo9qmcDtVIWPo2e+Kmy/D6Q7XFRTzkWRcl6q7n2RwOq79yRs9d6UWyj1rk6ZSrVQswNybqop5yYhRy2dwAF3pxbsz4rWxlokG9g1oUX6C1jVxe/fEfdR58/7Y6QPL23Jr5p7Z6OXchh+k3QpKW9/Z1m948f8YdWK30fDXolWQVR8FvJ8XrHBi2lmE1+VfTQqKD0gMNUKhYc8fGgLJ54NCPoHCUstnjHdBwP8iIF87DEZPcf+3zYhu0H0fwtTN0tOmqD3yUJ7dFoLxzS+VSxfD0wf4a53lS+uzbx7HSPBZo/8H0GU+dYxWr4T8jl/2KIMefTlXfxG/12xkmeQaFgf9QxtgLy+30g7THnB38oXtxE9fxi1kw8a/Q8C5T8idDC98mtdBx2YZtijwz8LHUTUvODue97hWZfGfQeOclxKXBIjAsd3mTVyjzXvZetw7WA59lt5QJ7zBcX9/q7YnVu2+tbkcYvQ9MgccPoK7UwYdrXayui22fCbTnte20VdGUdPk8f5Cy2zNF61hsJXSzvJqbnM0tdoq2DB/I54M/Esv3J3vqMYKYe++8XB1uTxs1B3OfS17ZtqyrlJyGEs30TNrcU9NxDzim6xWvr0MOjBmPnFE3PqHdtNIj9Grya0tos8qk3KOyJkqw3PRv94SV07LTPkd5FqmWGsrldNs66hE8W78A4gOnQeqHcA5YY1/KYRrYKo+Cxzk3OPaRwhubG9hH5XGdaoNwuPC0x1vukuDx97Nj8bEPQ7CWun4DPdBwP8iIF87DGKL//9dsETqgExHpxfvrdKKbB2C6yaK2QWxtZMPrd1dzV5wXNb1dmTlve9QpeWSOM3anuFnL1CjsLakxDrkYRYh/Sx+lh9rD7WixxLbQXn8++x/eTjFDCmjpB+ahPHIwH9kP+RgJwrasq5QsgZEXyZ56/J4WcsR+mszqdmu6kNRLsDcpB/N+UHJ4TaxX0+Wr3rWC3Tt4mHVzMa/dfhBc89x/rzyIdeDgqda26kkd83wz7ODMD11R/sw/FXvrH+8KYZLGtcfR0qg3dSGeC3o1QZ8EYqo/8LKIOHqAzU2dGheqPksY/49mo/QvoZ/XaY7eDjEpD/cY88tAfa+Z0eeY+L2RXld4k2cC1Ufof1lf0utt8d66d8OCv6Kc/YqFdroc/UGr/vM7WGx0uRnhFlHuvnXK5G/+7Ick0UTxaW3ZinZtZCG/OUH6ilaC03tcx9M5GIFTp3QZWretXE5fr+QLmqgzpRTy5Xo//5yHI1W3ajXNFWMeWq1ttw3EJ6tepXbQDmw0w7Ha4ZU67qaEcu1w8HylXNcofisNH/hx6Iw2irmHINHRreqVw5DmO5jlOa+tbmdMfo3xFlzn1+jgs+/XwHviY8tmanR40Fgt8Rb0bPFniwDCd/htOqMSsDcAqUTW70fyhMrqop6qNClOXnQJ0Z/FA1ecEzg1VItbxvF7qozVxlm8UuuGp+XeJRIxP8jrAy8QzTlKvGHvuALfSf0RI89aW4UORTPX+jtx6or3dhePylpM8GWqFQLzi/OFp3+vorr7jFPDxJacj3uEcOto4Y+bl1NPovRLaOJrsbrSPaiFvHfZA2KOjZ3k8Jevw6FM8qPQVpXKXRxk+SnE6hg/1f+akafave+Ijz57fTqCz0RbK9lKZGc8oXjK4bMyWYH/aFsl+/CvkO2qblOvuJ+sJVTFzKr5Av4OzCXTRrgvnh2bkBIROfhWbnLE3JeaimnIeEHMaKXadi9D8WMWpQyFCn7HEbmV/WXan6BUVsC+1S3RXDb5IuJeXt7640SB7nj7srM4QuLZF2F9xjGsqZIeQorEcSYoX89FySU9ZPz42Us6amnDVCzojgyzx/TQ4/YznKNiankVAO1pk1JGdGQjnoB22SM5RQzhDQrCY5mdAh1+vQ4yae5/9mQtog8eYXf1XY6O+FMxgOK+7NB1F31BH5OX5xPljeykKGxT9ejN12cZc6z8CwOtnuGLLdIKTF2M7oN4LtjifboWyu22inBqXNhLQZlMa2wjyo5bL4jH0O+dluyMftVcVTWqO/yGz4TVfLP/a3V+oUXtVeWf5mVZO3/4vMaguaKgf8IjPaFOXjodv5peJsRmlYH4cpDePZTErD+n1qca98eS3J5vLkZ+x3zK+wMA+rhV4Not9IMQXtU6IMj+1if+3YWP/Hr28refnVFGkx53j9wSljZ3zinD/9m4z4TRd+xn6m+lFrBb3Zaoh0b7uo62g13jPZlsZ5xzT0c9NBneM1o6J+MfZDfFU3eQVLbFmMOTclfofaF07D9oXbnmGhu9qWyn0Bi1mq/UTcBtG/DtrPu6lNVnF0Jjxj3xwR9LyXA/ODcXYkAmswIHuOoB8JyEa9kJdl+9oDVT/MNjXnQ+TXwGchAeD6ygnpY2ylyqlF9Ggb1Q4OUhrmfxalYR64jUTfbkKe7/b0GTEfGTzj+ZZM6Kr6oqofF/I91b/hrVT5peo/H02NfBw3sP5z3EAf5biBZctxQ8VypOcxhNE/RO09+kjdMcQc0hH7YMq/eWxg9M9CbBv3xLYZJTEfLXA6zZNbOdaMBQ0VC7C+cywIxeD8Khs3ud5i2cwkrJkCC23Kry3NNkOCHvEaRL8PyoDfFGP+eFUclgEfex7bL7f6kNN/tNCDx2z5fRvo3kO+hzFNjU/Y94z+Y+DPP01j3RRxY4jS1JdLQm1O6JgPdfS/8meLAzW/gBI91jX8ppua5ypjXVX/1FHxNePm/rHuqJCnygHHumhTlG9Y3JefrriGdoqJa+o9s3rPwfVZvStQMYLjx4yAPIwR2Bf/qGeOEPORCVzVZ8H5xUOp/mP94vqPdZzrP/o79xvQhtxvmAO6qD4PttlI/9sQw/6MbKN8OdSPbQl6PAxumPKDvt6KwAp94mGuoG8FZKNeyMuyfXVS1UWzTTfGG9gv4LqoygnpY2ylyqlF9GibsnV3DqVhHrheo2/j/MWfedptzIc6MET1B7DN5/6A2ts9InCNfidgDRJGfs8r843+s6Lvapi7hA4h/1fvunGdDn+2CZfL7aY05Nte3Ct/N7pufHJnOlfI8xga1xHwObO4nIx302B8xvO/+WxwVVaq7TT6PYDF+c3v31bcN4j+6wH/Cq0uz6+yNmQfwp25ofUs5kMv5fUsHBdxPcseSsO6ZzK5P4b2znVfedRkOt5Jr/6arvyMxwkYJw4hfVLsnFf55ve9GEvbxX2e73+luK12BCHvW4p73hG09PgJPlfcq8+P7SJ+SxsseHI/GznJz89ny6NtRyhNxeBQPpH+bZ58NkHPVqGnqnemV8161yob11WMCcX1Tms4zSYtN7VO8jpN1eajf/va/CEXbm+5zV8AZcBzJdh+8Dq37SV1j13zi+3U/zzyhXu1JpFPWii7C3WPyBtjDQj9sd5yuQ863R4yvfkEzleq+MzrjVdAWc07SWM6jw6+dcBDHvq9pIPRHyn8JRQH0P+fIEyjPxowv1oS8z4P5nGAyX0NVU/3wLOy7Sn3J9CO+yhN9eUcYQ4I2reSfExDP2e5LqCvalND+nJ7Y2nnQ3t1enE/THglY/VgqKxeJ/SNLavHA/ljLOPDtQwxdQTt8crjNeaMkphrRJuu+iqnAv75JFvFSHWik+rnYD38V5pbQvkjpL+1E2tFfezeGC77smrrcYsUt/XKNkjPMWGPoMdy5D42tjcnURq2s9y32i7kxLal2yGv//nIybih8Xx+v5706NTHu6245zh8fSAOKxuGbK7GiGhX00fF4ScoTfnsdPsj5j9mTiHURnUaD7M/qvZD+SP3szrNA4X8cRfk9SPUt1PzHypGsz6d+tz8Xspi/JCHnmO+0d8Z6Pc8JXQIjROeFvRPCZ1HSQfkZdlYL9Em/Elzo783Mh4nmvOQnzRHu7H/h2yUX2zTZwQ92sps0iJ6tK/y/6coTc0jhepsbN0w3twOOylWp56f41ht9NsDsVrlLRSruzU/F4rV3fTVXp2fQ1+NnZ97e0RfYCSgf6e5fY5fsXP7vGW+7LfN1AmkSs55NeWcJ+R0ew7yPMrP7kB+ys6FID+/Q9idMD9K505zqr9IYxgV23AMw+2d0f8ujMk+GDGnWtZ3d7jJeobmkPLrKsi/c93oc+r3ttPZ5+R+JbaXMXOG6HvYdhqNIx27YS+szzFjRhU3QvZVc3QtN9WW/N4P/W0XyUk1/3rlkZ313xnIbyf/4LmYHnpHd8D7AOwLZd/RcbxEOSpechljfMVy4XdWRv9ngb6j8oOQ33Qa05k+yjf4LAw1z9/FGNLTfsOnYKt5x1i/Cc0VYhtt7Xdojixzk9tJ9Gek971f2UU4GT2fBc+R782UZ+4jMfbdRG/5HPLQGx73Rb4WmEvY00GHe0iHJzrosId0MPpvCh1C9s+vUJ9w2E2tiyXqTfRZCS+WU+W5TVYxUNVzhTWSEMv6DaoPy2cllB0XIX9o/LWmppw1Qk63x198VsITCeVgnVlDcvYmlIN+0CY5TyaUg+0Rr53ZKXTI24nmCRPPsd3Cfgj2GXgPhNFfdeIE30iBqcbMfE7TPsBzgn61R95YIcPiH87jlohHcp+TYXWy3XyynXpXE7Kd0a8G2y0K2I7rtupjjLqp9uA+Pc7P8rtXNf+Lz9jn1Bz5iODj9grngcuMFWPqBuI33dQ8V2mv1Dw39gl5/8i7qsnbv3/kWSFPlQPuH0GbonzD4rMSVH9DxcanKQ3jGc/TY/0+Fe5Rhi9P1rcdDein+qHYd1PzLex7091X2lNNXrCvpOaHyvaVeP1Vr/aVUE/uK5Wdc0X+3QE5a2rKWSPkdHtut99XipdTpa90WaK+0mdPmOBbT+09xoqYvtIekQ+Wd3UP9JWuJdup9wkh2xn9fwLbXR+wHdftfl9pQk98hvj9vpK/r6T6G93sK+3pkCfuKyn9VH8nv9ou7orpS2H+SpTdiljfNPxUfSnVL1F9Kcvfk9XktXNfm1XwYT/2WrhX65+wvFKVn5qbOVDlt6uavGD5qTmrlOWHdatM+am6eRbcYxrmJ9SvRP7p6leeRXJ8bfyj1Mard1rYxvOaAaN/Ftr4x6mNj10XgF+K5Twnes8/WHZfU2jtcn6VXXfbLO5j3lurNeWZm1omZd9b457nkz3vrTPAfYvg5bqN9E8IPYye99IwDe97MfqfLnwqL7+vedbb+fa9+N7Dvg8wp3vfC9qZ95EgX+g9rNHVrBMrVJ3A/HCdUGt4VV/R6Dut4WW/x77sE4TF9Su/1guskK67aujK5YhlxeuNjRb9EvPDfmn0HxZ+qcrfbN6N8g+9h1c2Db2H72RTnu8KrUUOvYfvtOaGY+JOoQO2idM1RuU5g2dAl0Ghq+E2iP73oA3+S2rXbbzkXFydVeMzHHPxfmgcmz0bgRWKpe8W9M8GZKNeyMuyWU/j62LdkuvkcKzNdUuVE9LH2EqVU4vo0TZlx8vPUFrsePlpyPNfeuaWMB+xdRfnpXjOSsWqkO/FtlWh/Saq/nPcUG2cqkscN7BsOW7wPAjT81yj0X+Z5hrRR0r4upxrfDfp+C7QQfk3zyEa/Q8gtv2tJ7bNKIn5PyPbWSvHbpzThvWdY0EoBudX2bjJ9RbLJmZvMNqU+/VmoyFBj3i8t+r7UAZ8pgLGo3eR7rHzd7xfSb1DyO2+4MQX7kfc1LrbBrr/Rb6HMY3jRX6x7xn9Ylg/8C/U30gRN3htJ8YB7qeqNkf5meqfYRvKfBYHLK6gL3ZjTtzwm25qnqvMW8XOUdeMm/vnxN8j5KlywDlxtCnKN6zQ+ZPdjGtop5i4pubJW25qHrk+Y4zgOIAxguPH3oA8jBHYF7cYEYqRsX0WfA95GdV/rF9c/7GOc/1Hf+d+A9qQ+w3vBl1UnwfbbKQ/BGLYyWQb5cuhfux7Bf17gOYpyg/6+nsjsJ4OyP4pQf/egGzUC3lZtq9OqrpotunGeAP7BVwXVTkhfYytVDm1iB5tU7buvpvSsH3neo2+/Szkmf2z055prrtPCV2xPzBda/9SzRW8AuruFWSbXpsrCM239+cKJvTpFGNTzhXErkNMMVfA/qnev8W2u7jed37EXEGdsymqzhVw3OiluYLXFWXRy3MF90Jsu8kT28rOFdxS4PTnCg7cXMFdUAY8V4DxqNtzBU9HzhVs9fQ5ys4VPAv+/LbiPmXc6M8V9OcKngcv/r5U5wowRnR7ruDpLs0VNANzBVz/e2mu4Gchhn24P1cwRbavTvbnCsrV3RRzBR/u0lwB9weQzsr3enjGa1l4jbdPD6M3P/GttfLNDfw69LO+FlgXZFh53v6jJ28YJ9T4h/t4n4U48VuBvg6fa6H6Os5NjctMu9lpG3wc9Pi9E/2yzIdGAnnMMf7oRD/dZkHHGAPCBty+7RF8auzJe3KeIhn7AjKeFHxKxl7CRJupvQbv6pD+jMibE88GBP1Tnvw6IfvpDrj7BI6KNaEYxX3qVH2D3zvihXtVX3x1QvnVUwHdnyHd1ZzJvoDuyn4YP0aFTN7LwL71hMhnJn6bfrfDM46x6qx3pDFeXp/6FREzGdO3DvANHsz/T8w5hHzmdHjGbXGonFCfUeev50p3jCX8TJXP40TLcwmbhU6+308KHJ8Oof21of17qdYU/hLVTXWWo/3eTbojLZ+Vwnsz2L9HiB7P4RkUNOzfRv+DgH+rfYGo1xs8mP874N/K7qfBs7Lnp/HYSJ2fpnTH2MPPVPmwf3M82ix08v3eI3B8Oqj3TubfOz2YLJP9Ib/Yv0eEnLzcV5N/o5ztJFOt9VNr8lqCn89o2n9uVeE/6rsYqKfK43oP5hzA7PZ57KaPig9PBPiw/IaFrLbd/Dh8GZ7VhZnO74O8Xn0h2On7q7QuGevT4eriPsZ2RnjO6TnCF+k+xkNT7GPkvVEZyM/r0aERdQx5txT3XMeOXDXBd5gH07l6semgIybjduvsVlV3Q/t+dlAalomvX+rb43Rbcc99yBOgboa+G5bmLNDs+2pOCfuIPKek+rFIX7YfazZpET2Xi8+/1Fwv+43vewiGx/vMzoQy4PdWO4Cf97rsLKm77wxgrotYN7geq32Fqs6F6j3q7Wtbzwu0rer9fp3vy/B7eNW/U+t3QvtRja7mHOzYgT532vKm5jC4H6nOLVWxF/eX/vjwyfqo85axbNm/EGtQ6HF5cc/f6rsm4F+d2pWyZ/hX/T6v1X3lX4n2O8870PudrWzVXFLonG7eJ49jADx3+3+Qf6l2Enn5HbvR3xrwl32BPOZX2TbK9AnNtag5VfYlNb9nOoTWGuT3t7rJdjD6OyP7C4nWvJ1X9n1w6Ns1+cVlEVojhzZpET2XC/5GrND7F7PRkNNl4Pt+0tsC/YXYNbMxuqu4q+ob1qltRX1T43zus4a+g8O82PYMeeh9489twl4cz3xzrxsI0+gfC8QD1aY+Bs/KntHOc69qPlKNH0JnA6Tpz7vzD/QZ7dx+YDzkPaplz2iP9X/0obvI/7E9f5RkhvqxzItyfP7vOyP9pwP+32lcfilhGv37Ss59hfy/Ux8h1EcKnctj8aaL/fOLDnT/nP0/1D8vO88b6//oQ6+j/pY6Pxl5Lyvu+fzkD5f0Lxw3VO2DKh8KxV6en1F9Vy5HXzvD4xSj//XI/laib27MP9DxnN+9qf5tKH6GzhZS8VO1lxw/fz9yfobnlnaW1D22vmGdupTaGxz7cnuzMyCTebFe+9obw+O24U8C7Q2OzdR8ELc3Rv+pkuP1UHvTabzO80HqnC01lg+N142uZv1coOon5p/rZyiv+VV2rozbG4yH/L0crBvcl4md5+k0vj+t8P96dn37r2Sgi2EPCsoG/TWarxRl0gT59rcRocfnP/FPf/Wxy065i/e95JeV0awa+HM+8Z+u/Mr/uueobuEv+50tf/GqL/zdF7qF//8Nb7ho4Nf3Htot/J1f/fF/3/vA0u90C/+V73/b7pHTPvLRbuF/ePZfnv+f3z98Y7fw/2Lmt5775P9729Od8EeL+yFIHySemcXfBqQNCbwG0f8LvAv8V4iB9ozl5c9mn+Snyzx/lc6ojz1rCvpBQW+yZwl6S5sNaRjDkQbthVhNSEf6ZpF3K5Nh4DH+lpA/TPKV3vhsgOhnC/rZgj7P58BJk/OAeS/7Dj2/hogfn6HsOnXhFUfuW7Lsj98y0q269munHX/2nFcfNd4t/BmNZT/T/sjN67qFv/uUxti+16xf2y38n37uitMeXXL4d7uF/54/OmHtd6/69iGd8P9/ZQo8JCgvBwA=",
      "custom_attributes": [
        "utility"
      ],
      "debug_symbols": "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eck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJeu8ZJ2XrPOSdV6yzkvWeck6L1nnJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzq1bqXu39ZVUkl4a4zLSpJrUknrSSJpJa5M1Lm0qSZKkSTWpJfWkkTSTUqOkRkmNkholNUpqlNQoqVFSo6RGSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1JDU0NTQ1NDU0NTQ1NDU0NTQ1NDU2Nmho1NWpq1NSoqVFTo6ZGTY2aGjU1Wmq01Gip0VKjpUZLjZYaLTVaarTU6KnRU6OnRk+Nnho9NXpq9NToqdFTY6TGSI2RGiM1RmqM1BipMVJjpMZIjZkaMzVmaszUmKkxU2OmxkyNmRozNVZqrNTIOq9Z5zXrvGad16xz64waYjST1iZrjtpUkiRJk2pSS+pJI2kmpUZJjZIaJTVKapTUKKlRUqOkRkmNkhqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoamhqaGpoaNTVqatTUqKlRU6OmRk2Nmho1NWpqtNRoqdFSo6VGS42WGi01Wmq01Gip0VOjp0ZPjZ4aPTV6avTU6KnRU6OnxkiNkRojNUZqjNQYqTFSY6TGSI2RGjM1ZmrM1JipMVNjpsZMjZkaMzVmaqzUWKmxUmOlxkqNlRorNbLOW9Z5yzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWefWmTWaUU8aSTNpBVmdO5UkSdKkmpQamhqaGpoamho1NWpq1NSoqVFTo6ZGTY2aGjU1amrY43PFqCRJkibVpJbUk0bSTFpBPTXuOp+2x+8636RJNakl9aSRNJNW0F3nm1JjpMZIjZEad53PatSTRtJMWkF3nW8qSZKkSTUpNWZqzNSYqTFTY6XGSo2VGis1Vmqs1FipsVJjpcYKDWvy2lSSJEmTalJL6kkjaSalhj3Wao8o2oOtTpJ0a3SjmtSSbo1pNJJm0ktj3bPJGr82laSXxhpGmlSTXhrLstx1vmkkzft5T38scyXelR5YgAJUYAU2YAcOINQUahVq1dRsq6oAFWhqtrtrA3bgAE7gSmwXsAAFqECoNag1qDVTs+PrD9U6rkR/sNaxAAWowApswA6EWodah9qA2oDagNqA2oDagNqA2oDagNqA2oTahNqE2oTahNqE2oTahNqE2oTagtqC2oLagtqC2oLagtqC2oLaSjVrSAssQAEqsAIbsAMHcAKhVqBWoFagVqBWoFagVqBWoFagVqAmUBOoCdQEagI1gZpATaAmUBOoKdQUago1hZpCTaGmUFOoKdQUahVqFWoVahVqFWoVahVqFWoVahVqDWoNag1qDWoNag1q7iX2zLp7ieMErkT3EscCFKACK7ABodah1qHWoTagNqA2oDagNqA2oDagNqA2oDagNqE2oTahNqE2oTahNqE2oTahNqG2oLagtqC2oLagtqC2oLagtqC2Um1dF7AABajACmzADhzACYRagVqBWoFagVqBWoFagVqBWoFagZpATaAmUBOoCdQEagI1gZpATaCmUFOoKdQUago1hZpCTaGmUFOoVahVqFWoVahVqFWoVahVqFWoVag1qDWoNag1qDWoNajBSxa8ZMFLFrxkwUsWvGTB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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "11591029387631908977": {
            "error_kind": "string",
            "string": "Function _emit_success_event can only be called internally"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "public"
      ],
      "debug_symbols": "nZjRTiM7DIbfZa65SOIkdvoqK4QKlFWlqqAuHOkI8e5rJ7ZbVsqo9AZ/4zK/HceTZOZzed49fvx+2B9fXv8sm1+fy+Npfzjsfz8cXp+27/vXI3s/lyB/YoJlE++WCGnYUpYNiG3D1qxWr1GvUa8Jl01m26La2m0KQW1W24aNeh1p2VS2Er9bHBai2jJsDmrtug1b+L4mloatafir6qDqoN6Heh9ltXrdNH7DrgMhqa3dDzGqLWrHfaB5QxrjANBrGPEhx6GT67BljAOK6hTVqXqf5g2Y1Oo1aXzi+2JgaMGARxKzAEtF/p8stR5A46ccwUA8xNDnW0AKPaAqSKlTFOBYKTFI0gNIQdJNIih5DqgKkukA8zTzNPUU6YoB2aApRDAghZQMUAGigQn2nFGgGDSFkg3MU81TzYNggAqUDKpCH0UHDVFDMMgGKlgjGKhgTSpYe6pc59qLyT1RpWchCKACmgfNQ+aRfDpIPgPUgyEaFIUYDLJBU0jmSeaR1h2gQTGboHQv8LxjiQZFoQYD88gjByBQFcg8ZB7p3gFlAIVg4J6m0JPvQArSvQPEUxh68h1QIScD80jBgbuFpHsHmAfNg+Yh85B5mnmaeloAA/NE80TzJPMk88gSOwAVsnmyeYp5SlXode5QDJpCX4s7WAhLvpEJNhNsKhhDb5dBxSgGp+zUjGwsTGRko2FCo+zK2aMVVy4erbhy9WjVldGjoSuTRyNXbh6tmXIMwSk7WbRos8Rk0WJKThYtQnSyaDG7cvZo2ZWLRyuuXD1adWX0aOjK5NHIlZtHk2UesFNT6pvqoJic0ChFp2oE7pONdVAmI9lMldxX3VddGV0FXYWCk/ua+zz75NlDACeLBn0c1AmNkvv6OJoQhLF2MmWnZpTdl8lIxqbkPll4lapS3xhz6CRHGjkL9T1SqRpJDCU50iQhmX0l90n9MnRCI5l9JfeR+8h9/TA1iGuapQ/61qnkPulnJTKSquX89XW32Gnv4f2028lh7+L4x4fCt+1pd3xfNsePw+Fu+W97+Oj/9Odte+z2fXviX7kiu+MzWxZ82R92Ql9357vD/FY+j4DenflBd4FG1yok7lFV4A5uM4U0V+DzV7AkmPM5i9quzgJKtixyumkcFC2JRBBnCmWuQM0mooXi9wPB1QJILkBTAZwLyCoWVULWsXQWSd9LSSvTwU+DzQa/apwlaro2j2slwlpTYDKJkmg2HTGuVINfXJpVI6WCLsI72XeVle7kt6Zq08KMddad0j7T0aRSiw2HF/AwFVnPpPnstpRhKlLW6mp5ZN41XKHcWtVa51Vd6RCs9rDhRUVz+kka3iDMLc3TaCsqFJKrULh47P8paVprVX7hpfPkxun69YOytjwfz4oKNGo+vXBukBK/j2atVas3Gb/onucG0/USiL6eY5tLrLRpBrKSZh7JdFrqigSitzo2mC5CqxoUXYNivU2jgW+xrdJc49pyXCzr/5ZjVcKfF5YoMwlY6y5A8lUMLutx/UYNCMF7A9INGzXw+/ZZAWYKcjKfSpRQm+8uod1y4sh8arV68gefaRorneETguetKcMPmrMEb86L3e1nzekHBl7E6i07dfU61JKnp5Y1AV9wMNSbBOgsgDcJeDdUpFsEUL4ejQwutuUucM+X26f96duH3S+ROu23j4edXr58HJ8ufn3//81+sQ/Db6fXp93zx2knSuevw/znF3B4PjDd84dGueLvi/w6di9v3XzJp9m7RCSXUX4t8Y5b9/5LUvsL",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    },
    {
      "abi": {
        "error_types": {
          "11019205087382408538": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "12087256528359734805": {
            "error_kind": "string",
            "string": "needle length of size 0 not supported"
          },
          "12480987221041334580": {
            "error_kind": "string",
            "string": "URL check failed"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17568106868988118403": {
            "error_kind": "string",
            "string": "substring not present in main text (match found if a padding text included. is main text correctly formatted?)"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "5899151545213940874": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 31 limbs"
          },
          "7499498444266164243": {
            "error_kind": "string",
            "string": "No allowed URL matches the request URL"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7688826323084302732": {
            "error_kind": "string",
            "string": "utils::search could not find needle in haystack"
          },
          "9752593157046867219": {
            "error_kind": "string",
            "string": "haystack length of size 0 not supported"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "public_key_x",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "public_key_y",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "signature",
            "type": {
              "kind": "array",
              "length": 64,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "request_urls",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 1024,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "allowed_urls",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 1024,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "data_hashes",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            "visibility": "private"
          },
          {
            "name": "plain_json_response_contents",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 1000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              }
            },
            "visibility": "private"
          },
          {
            "name": "business_logic_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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8+g89N7P23Gl40l7ffN9F9/7N5CESCLPv7/J7nCG2OF//678D/92SOyxueNZgt+7me9b//iTeGz4zxH83nv7vvWPP6lH56H3ft5OIp1UOpHn/79LhndyJAWS0vPvb7I7nCd28P5d37f+7ZDKY3PHCwS/dzPft/7xp/bY8F8k+L339n3rH38aj85D7/28nVo6jbTXN993afFOh6RHMnj+/U12h0vEDt6/6/vWvx0yemzueJng927m+9Y//kweG/4rBL/33r5v/ePP7NF56L2ftzNJZ5b2+ub7LgvefkhWJJvn399kd7hK7OD9u75v/dshu8fmjtcIfu9mvm/948/hseG/TvB77+371j/+nB6dh977eTuHdE5pr2++73LhnRvJg+T1/Pub7A43iB28f9f3rX875PPY3PEmwe/dzPetf/wejw3/LYLfe2/ft/7x5/foPPTez9se6fzSXt983xXAuyBSCCns+fc32R1uEzt4/67vW/92KOKxueMdgt+7me9b//iLemz47xL83nv7vvWPv5hH56H3ft4uKl1M2uub77vieJdASiKlPP/+JrvDPWIH79/1fevfDqU9Nne8T/B7N/N96x9/GY8N/wOC33tv37f+8Zf16Dz03s/bZaTLSnt9831XDu/ySAWkouff32R3eEjs4P27vm/926GSx+aOjwh+72a+b/3jr+yx4X9M8Hvv7fvWP/4qHp2H3vt5u7J0FWmvb77vquJdDamO1PD8+5vsDk+IHbx/1/etfzvU9Njc8SnB793M961//LU8NvzPCH7vvX3f+sdf26Pz0Hs/b9eSri3t9c33XR286yL1kPqef3+T3eE5sYP37/q+9W+HBh6bO74g+L2b+b71j7+hx4b/JcHvvbfvW//4G3l0Hjbw/F83lG4k7fXN911jvJsgTZFmnn9/k93hFbGD9+/6vvVvh+Yemzu+Jvi9m/m+9Y+/hceG/w3B772371v/+Ft6dB567+ftFtItpb2++b5rhXdrpA3S1vPvb7I7vCV28P5d37f+7dDOY3PHdwS/dzPft/7xt/fY8L8n+L339n3rH38Hj85D7/283V66g7TXN993HfHuhHRGunj+/U12hw/EDt6/6/vWvx26emzu+JHg927m+9Y//m4eG/5PBL/33r5v/ePv7tF56L2ft7tJd5f2+ub7rgfePZFeSG/Pv7/J7vCZ2MH7d33f+rdDH4/NHb8Q/N7NfN/6x9/XY8P/leD33tv3rX/8/Tw6D73383Zf6X7SXt983/XHewAyEBnk+fc32R2+ETt4/67vW/92GOyxueN3gn+A57/zD/HY8P8g+L339n3rH/9Qj85D7/28PUR6qLTXN993w/AejoxARnr+/U12h5/EDt6/6/vWvx1GeWzu+Ivg927m+9Y//tEeG/7fBL/33r5v/eMf49F56L2ft0dLj5H2+ub7bize45DxyATPv7/J7vCH2MH7d33f+rfDRI/NHf8S/N7NfN/6xz/JY8MfINx//9Z7b9+3/vFP9ug89N7P25OkJ0t7ffN9NwXvqcg0ZLrn399kdwhI7OD9u75v/dthhsfmjoEIfu9mvm/945/pseEPTPB77+371j/+WR6dh977eXum9Cxpr2++72bjPQeZi8zz/Pub7A5BiB28f9f3rX87zPfY3DEowe/dzPetf/wLPDb8wQh+77193/rHv9Cj89B7P28vkF4o7fXN990ivBcjS5Clnn9/k90hOLGD9+/6vvVvh2UemzuGIPi9m/m+9Y9/uceGPyTB772371v/+Fd4dB567+ft5dIrpL2++b5bifcqZDWyxvPvb7I7hCJ28P5d37f+7bDWY3PH0AS/dzPft/7xr/PY8Ich+L339n3rH/96j85D7/28vU56vbTXN993G/DeiGxCNnv+/U12h7DEDt6/6/vWvx22eGzuGI7g927m+9Y//q0eG/7wBL/33r5v/ePf5tF56L2ft7dKb5P2+ub7bjveO5CdyC7Pv7/J7hCB2MH7d33f+rfDbo/NHSMS/N7NfN/6x7/HY8MfieD33tv3rX/8ez06D7338/Ye6b3SXt983+3Dez9yADno+fc32R0iEzt4/67vW/92OOSxuWMUgt+7me9b//gPe2z4oxL8Bzz/nf+IR+eh937ePix9RNrrm++7o3gfQ44jJzz//ia7QzRiB+/f9X3r3w4nPTZ3jE7wezfzfesf/ymPDX8Mgt97b9+3/vGf9ug89N7P26ekT0t7ffsfXssxRs92i8K1bdu2Me0UM1NMp5hObdu2bdu2bdu2beusN9lN7u/X6cpO9o+Vdaffk3eurH3l5Pz97jTeZ5CzyDmv//4mu0N8YgfP3/377f/b4byXzR0TEPyezf5++//4L3jZ8Cck+D33/vvt/+O/6KXz0HM/T1+Q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cQWgcRWgcR2gcQOgcROgcQugcRugYbQIv0YcgEY8gEYCgEYigEYSgEYygEYKgEYqgEYagEY6gEYGgEYmgEYWgEY2gEYOgIYJ0MgF0MgD0MgH0CgA0CgE0CgC0CgG0CgB0CgF0CgD0CgL0CgP0KgA0KgE0KgM0KgC0KgG0KgO0KgB0KgJ0KgF0KgN0KgD0KgL0KgH0KgP0GgA0GgI0GgE0GgM0GgC0GgK0GgG0GgB0GgF0GgN0GgD0IgGaLQDaHQAaHQCaHQBaHQDaPQAaPQEaPQCaPQBaPQDaAwAaAwCaAwBaAwDaIwAaIwCaIwBaIwDaEwAaEwCaEwBaEwDaMwAaMwCaMwBaMwDaCwAaCwCaCwBaCwDaKwAaKwCaKwBaKwDaGwAaGwCaGwBaGwDaOwAaOwEaOwCaOwGaOwBaOwFaOwDaOwHaBwAaBwEaBwCaBwGaBwBaBwFaBwDaBwHaJwAaJwEaJwCaJwGaJwBaJwFaJwDaJwHaFwAaFwEaFwCaFwGaFwBaFwFaFwHaNwAaNwEaNwCaNwGaBgtw68RB6ARD6CRAKCRCKCRBKCRDKCRAqCRCqCRBqCRDqCRAaCRCaCRBaCRDaCRA6BhAjRyATTyADTyATQKADQKATSKADSKATRKADRKATTKADTKAjTKAzQqADQqATQqAzSqADSqATSqAzRqADRqAjRqATRqAzTqADTqAjTqATTqAzQaADQaAjQaATQaAzSaADSaAjSaATRaADRaATRaAzTaADSiARrtABodABqdABpdABrdABo9ABo9ARq9ABp9ABr9ABoDABqDABpDABrDABojABqjABpjABrjABoTABqTABpTABrTABozABqzABpzABrzABoLABqLABpLABrLABorABqrABprABrrABobABqbABpbABrbABo7ABo7ARq7ABq7ARp7ABp7ARr7ABr7ARoHABoHARqHABqHARpHABpHARrHABrHARonABonARqnABqnARpnABpnARrnABrnARoXABoXARqXABqXARpXABpXARrXARo3ABo3ARq3ABq3ARpGq/BrxAFoxANoJABoJAJoJAFoJANopABopAJopAFopANoZABoZAJoZAFoZANo5ABomACNXACNPACNfACNAgCNQgCNIgCNYgCNEgCNUgCNMgCNsgCN8gCNCgCNSgCNygCNKgCNagCN6gCNGgCN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cXrNrMdR2glb2nFC2onA0o4LpJ3gS/s9krRV1IVWnF4z60mUdsqWdpKQdiqwtJMCaaf40lZFkvYHdaEVp9fK2gUvuihTUPrClpb+I239F31KU134/10qGz2ALH9EkraautCK02tmzYLSzrKlZSGknRVYWhaBtLP40lZHkraGutCK02tmzYrSzralZSWknR1YWlaBtLP50tZEkraWutCK02tmzYbSzrGlZSOknRNYWjaBtHP40tZGkvYndaEVp9fMmh2lnWtLy05IOzewtOwCaefypf0ZSdo66kIrTq+ZNQdKO8+WloOQdl5gaTkE0s7jS1sXSdpf1IVWnF4za06Udr4tLSch7fzA0nIKpJ3Pl/ZXJGnrqQutOL1m1lwo7QJbWi5C2gWBpeUSSLuAL219JGl/UxdacXrNrLlR2oW2tNyEtAsDS8stkHYhX9rfkaRtoC604vSaWfOgtItsaXkIaRcFlpZHIO0ivrQNkaRtpC604vSaWfOitIttaXkJaRcHlpZXIO1ivrSNkaRtoi604vSaWfOhtEtsafkIaZcElpZPIO0SvrRNkaT9Q11oxek1s+ZHaZfa0vIT0i4NLC2/QNqlfGn/RJK2mbrQitNrZi2A0i6zpRUgpF0WWFoBgbTL+NI2R5L2L3WhFafXzFoQpV1uSytISLs8sLSCAmmX86X9G0naFupCK06vmbUQSrvCllaIkHZFYGmFBNKu4EvbEknaVupCK06vmVWjtCttaZqQdmVgaVog7Uq+tK2RpG2jLrTi9JpZC6O0q2xphQlpVwWWVlgg7Sq+tG2RpP1HXWjF6TWzFkFpV9vSihDSrg4srYhA2tV8af9FkradutCK02tmLYrSrrGlFSWkXRNYWlGBtGv40rZHkraDutCK02tmLYbSrrWlFSOkXRtYWjGBtGv50nZEkraTutCK02tmLY7SrrOlFSekXRdYWnGBtOv40nZGkraLutCK02tmLYHSrrellSCkXR9YWgmBtOv50nZFkrabutCK02tmLYnSbrCllSSk3RBYWkmBtBv40nZHkraHutCK02tmLYXSbrSllSKk3RhYWimBtBv50vZEkraXutCK02tmLY3SbrKllSak3RRYWmmBtJv40vZGkraPutCK02tmLYPSbrallSGk3RxYWhmBtJv50vZFkrafutCK02tmLYvSbrGllSWk3RJYWlmBtFv4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G2haHe9N25dITfvW7YQV8HJvaK11uWmPhTetrkvTHlNuWl2gaY95b9q3idS0/W4nrICXe0NrrcdNezy8afVcmva4ctPqAU173HvT9idS075zO2EFvNwbWmt9btoT4U2r79K0J5SbVh9o2hPem/ZdIjXtgNsJK+Dl3tBaG3DTngxvWgOXpj2p3LQGQNOe9N60A4nUtO/dTlgBL/eG1tqQm9YovGkNXZrWSLlpDYGmNfLetO8TqWkH3U5YAS/3htbamJvWJLxpjV2a1kS5aY2BpjXx3rSDidS0Q24nrICXe0NrbcpNeyq8aU1dmvaUctOaAk17ynvTDiVS0w67nbACXu4NrbUZN615eNOauTStuXLTmgFNa+69aYcTqWk/uJ2wAl7uDa21BTetZXjTWrg0raVy01oATWvpvWk/JFLTjridsAJe7g2ttRU3rXV401q5NK21ctNaAU1r7b1pRxKpaT+6nbACXu4NrbUNN+3p8Ka1cWna08pNawM07WnvTfsxkZp21O2EFfByb2itbblp7cKb1talae2Um9YWaFo77007mkhNO+Z2wgp4uTe01vbctA7hTWvv0rQOyk1rDzStg/emHUukph13O2EFvNwbWmtHblqn8KZ1dGlaJ+WmdQSa1sl7044nUtNOuJ2wAl7uDa21MzetS3jTOrs0rYty0zoDTevivWknEqlpJ91OWAEv94bW2pWb1i28aV1dmtZNuWldgaZ18960k4nUtFNuJ6yAl3tDa+3OTesR3rTuLk3rody07kDTenhv2qlEatpptxNWwMu9obX25KY9E960ni5Ne0a5aT2Bpj3jvWmnE6lpP7mdsAJe7g2ttRc3rXd403q5NK23ctN6AU3r7b1pPyVS0864nbACXu4NrbUPN+3Z8Kb1cWnas8pN6wM07VnvTTuTSE372e2EFfByb2itfblp/cKb1telaf2Um9YXaFo/7037OZGadtbthBXwcm9orf25ac+FN62/S9OeU25af6Bpz3lv2tlEatovbiesgJd7Q2sdwE0bGN60AS5NG6jctAFA0wZ6b9ovidS0c24nrICXe0NrHcRNez68aYNcmva8ctMGAU173nvTziVS0351O2EFvNwbWutgbtoL4U0b7NK0F5SbNhho2gvem/ZrIjXtvNsJK+Dl3tBah3DTXgxv2hCXpr2o3LQhQNNe9N6084nUtN/c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QcZfgowKgoyKgoxKgozKgowqgoyqgoxqgozqgowagoyagoxagozagow6goy6gox6goz6gowGgoyGgoxGgozGgowmgoymgoxmgozmgowWgoyWgoxWgozWgow2goy2gox2goz2gowOgoyOgoxOgozOgowugoyugoxugozugowegoyegoxegozegow+goy+gox+goz+gowBgoyBgoxBgozBgowhgoyhgoxhgozhgowRgoyRgoxRgozRgowxgoyxgoxxgozxgowJgoyJgoxJgozJgowpgoypgoxpgozpgowZgoyZgoxZgozZgow5goy5gox5goz5gowFgoyFgoxFgozFgowlgoylgoxlgozlgowVgoyVgoxVgozVgow1goy1gox1goz1gowNgoyNgoxNgozNgowtgoytgoxtgoztgowdgoydgoxdgozdgow9goy9gox9goz9gowDgoyDgoxDgozDgowjgoyjgoxjgozjgowTgoyTgoxTgozTgowzgoyzgoxzgozzgowLgoyLgoxLgozLgowrgoyrgoxrgozrgowbgoybgoxbgozbgow7goy7gox7goz7gowHgoyHgoxHgozHgowngoyngoxngozngowXgoyXgoxXgozXgow3goy3gox3goz3gowPgoyPgoxPgozPgoxA8b59RmBBRhBBRlBBRjBBRnBBRghBRkhBRihBRmhBRhhBRlhBRjhBRnhBRgRBRkRBRiRBRmRBRhRBRlRBRjRBRnRBRgxBRkxBRixBRmxBRhxBRlxBRjxBRnxBRgJBRkJBRoAgI5EgI7EgI4kgI6kgI5kgI7kgI4UgI6UgI5UgI7UgI40gI60gI50gI70gI4MgI6MgI5MgI7MgI4sgI6sgI5sgI7sgI4cgI6cgI5cgI7cgI48gI68gI58gI78go4Ago6Ago5Ago7Ago4ggo6ggo5gg4ztBRnFBRglBxveCjB8EGSUFGaUEGaUFGWUEGWUFGeUEGT8KMn4SZPwsyPhFkPGrIOM3Qcbvgozygow/BBl/CjL+EmRUEGRUFGRUEmRUFmRUEWRUFWRUE2RUF2TUEGTUFGTUEmTUFmTUEWTUFWTUE2TUF2Q0EGQ0FGQ0EmQ0FmQ0EWQ0FWQ0E2Q0F2S0EGS0FGS0EmS0FmS0EWS0FWS0E2S0F2R0EGR0FGR0EmR0FmR0EWR0FWR0E2R0F2T0EGT0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5bwT5bwX5XwQ5XwU5XwS5XwW5QSKr8kJLMoJIsoJKsoJJsoJLsoJIcoJKcoJJcoJLcoJI8oJK8oJJ8oJL8qJIMqJKMqJJMqJLMqJIsqJKsqJJsqJLsqJIcqJKcqJJcqJLcqJI8qJK8qJJ8qJL8pJIMpJKMoJEOUkEuUkFuUkEeUkFeUkE+UkF+WkEOWkFOWkEuWkFuWkEeWkFeWkE+WkF+VkEOVkFOVkEuVkFuVkEeVkFeVkE+VkF+XkEOXkFOXkEuXkFuXkEeXkFeXkE+XkF+UUEOUUFOUUEuUUFuUUEeUUFeUUE+V8J8opLsopIcr5XpTzgyinpCinlCintCinjCinrCinnCjnR1HOT6Kcn0U5v4hyfhXl/CbK+V2UU16U84co509Rzl+inAqinIqinEqinMqinCqinKqinGqinOqinBqinJqinFqinNqinDqinLqinHqinPqinAainIainEainMainCainKainGainOainBainJainFainNainDainLainHainPainA6inI6inE6inM6inC6inK6inG6inO6inB6inJ6inF6inN6inD6inL6inH6inP6inAGinIGinEGinMGinCGinKGinGGinOGinBGinJGinFGinNGinDGinLGinHGinPGinAminIminEminMminCminKminGminOminBminJminFminNminDminLminHminPminAWinIWinEWinMWinCWinKWinGWinOWinBWinJWinFWinNWinDWinLWinHWinPWinA2inI2inE2inM2inC2inK2inG2inO2inB2inJ2inF2inN2inD2inL2inH2inP1fmfMtv57CAVEnw5cgCnxQdB+H4n9Z/+0BI4f4/8Bv+XUbDv833cd/yjkS/8v7b3mt6XTU0GmnqNMxQ6dSoq9vcdzQaYfoC9mcEP03e1KUc0qUc1qUc0aUc1aUc06Uc16Uc0GUc1GUc0mUc1mUc0WUc1WUc02Uc12Uc0OUc1OUc0uUc1uUc0eUc1eUc0+Uc1+U80CU81CU80iU81iU80SU81SU80yU81yU80KU81KU80qU81qU80aU81aU806U816U80GU81GU80mU81mUEyiBJiewKCeIKCeoKCeYKCe4KCeEKCekKCeUKCe0KCeMKCesKCecX86XfA31f/78X/Jvcr4vKm/tFf4rf/3W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nTbbFbPdNdszs703W6DKegtttihmi2u2ZGZLa7ZsZstrtmJmK2+2GmZraLZWZutstu5/b5kOVI+zvXbmZbydbvGf77/1s3fQjvqYIf/evvWzd5y/t299v0369/atn72Tm9tLabbUZiv39/atn6/bm62ruQ99zDbEbGPMNtlss8222GyrzbbRbDvNdtBsJ812wWw3zPbAbC/M9sFsgTrpLZTZIpktltkSmS2l2TKYLYfZ8pmtmNnKma2a2eqZrZnZuv69fet1299so802zWyLzLbWbDvMdsRs581222zPzfbJbCE76y2q2RKaLY3ZsputoNnKmq2m2ZqaraPZepttuNkmmW2e2VaZbYvZDpjttNlumy1CL73FNFsis6UyWyaz5TRbIbOVNlsVs9U1WzOztTfbT2brb7YRZptgtplmW2S21WbbZLbdZjtitjNmu2q2e2Z7brYPZgvcW29hzBbVbPHMltxsqf7evvWz9/Lx+nobzLbbbCfNdtls98z20myBJugtrNlimC2x2VKbLZvZ8putlNmqmq2+2VqbrZvZ+pttlNkmm22+2VaZbbPZ9pnthNkum+2e2V6a7U+zhZiotyhmi2+2lGbLbLbcZitutkpmq2u2FmbrZLY+Zhtutolmm2O2ZWbbYLbdZjtmtgtmu2W2Z2b7w2zBJuktotlimy252TKYLafZipitnNlqma2p2TqY7WezDTbbOLPNNNsSs60z23azHTbbWbPdMNtjs701W8LJektttqxmK2i2MmarbrZGZutotl5mG2q28WabYbYlZltnth1mO2y2M2a7YbbHZntntsBT9BbWbDHNlsRsac2Ww2wFzFbGbNXN1shsbc3W3WwDzTbGbNPMttBsq8221WwHzPa72a6a7b7ZXpstwFS9hTZbNLMlMFtqs2U1Wz6zlTRbZbPVN1srs3U1Wz+zjTDbZLPNM9tKs20y2x6znTDbJbPdNdsLs300W4hpeotstnhmS2G2jGbLbbZiZqtotjpma2a2YWabYLbZZltptk1m22u2E2a7ZraHZntjtoDT9RbKbNHMltBsqc2W1Wx5zVbSbFXMVt9srczWxWz9zDbSbJPNNs9sK8y2yWx7zXbCbJfMdsdsL8z2yWwhZugtstnimi2F2TKZLbfZipmtgtnqmK252TqZrbfZhpptgtlmm22Z2dabbafZjprtvNlume2p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wWy3zfbMbH+YLeg1vSU3Wwaz5TRbcbNVMltds7UwW3ezDTDbaLNNNds8s60y22az7TPbSbNdMts9s700259mC3ldb5HNFt9sKc2W2Wx5zFbMbJXMVtdsLczW2Wy9zTbcbBPNNsdsy8223my7zXbMbBfMdttsT832h9mC3dBbRLPFMVsys2UwW06zFTFbebPVNFtTs3Uw289mG2K2sWababYlZltnth1mO2S2s2a7YbbHZntntkA39RbObDHNlsRsac2W3WwFzVbGbNXN1shsbcw2xmzTzLbQbOvMtsNsh8121mx3zPbcbB/NFvyW3iKYLY7Zkpstg9lymq2w2cqbrZbZmpqtg9l6mm2I2caZbabZlphtrdl2mO2w2c6a7YbZHpntndkC39ZbOLPFNFtis6U1Ww6zFTRbGbNVM1sjs7U1209mG2i20WabZraFZvvVbFvNtt9sv5vtqtkemO212T6bLfQdvUUzW0KzpTZbFrPlM1tJs1UxW32ztTRbV7P1M9tIs00221yzrTTbJrPtNdsJs1002yezhbirt8hmS2i21GbLarZ8Zitrthpma2y2dmbrbraBZhtjtmlmW2i21WbbarYDZvvdbFfNdt9sr80W4J7eQpstmtkSmC212bKaLZ/ZSpqtstnqm62V2bqarZ/ZRphtstnmmW2l2TaZbY/ZTpjtktnumu2F2T6aLcR9vUU2WzyzpTBbRrPlNlsxs1U0Wx2zNTNbJ7P1Ntsws00w2yyzLTPberPtMttRs50z2y2zPTXbB7MFfaC38GaLbbZkZktvth/NVshsTczW3mw9zTbMbBPMNttsy8y22Wz7zHbSbJfNdsdsL8z2yWwhHuotstnimi2F2TKZLbfZipmtgtnqmK252TqZrbfZhpptgtlmm22Z2dabbafZjprtvNlume2p2d6bLegjvUUwW2yzJTNbOrP9aLbCZitntppma2y29mbrabbBZhtrtulmW2y2tWbbbrZDZjtttutme2S2t2YL9FhvYcwWw2yJzfa92bKbLb/ZSputmtkamq2N2bqZbYDZRpttqtkWmG2V2U6Z7YrZ7pvtrdkCPdFbWLPFMFtys2UwW06zFTFbWbPVNFsTs7U3W0+zDTLbWLPNMNtis6012zazHTLbGbNdN9sjs70xW6CnegtrthhmS2y2NGbLbrYCZitttmpma2C2NmbrbrYB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",
      "custom_attributes": [
        "private"
      ],
      "debug_symbols": "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S1ItSbUk1ZJUS1ItSbUk1ZJUS1ItSbUk1ZJUS1ItSbUk1ZJUS1ItSbUk1ZJUS1ItSbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1JJSS0otKbWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLRi0ZtWTUklFLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVklVLVi1ZtWTVkn225HpactHStHQtQ8vUsrRsLY+Wo6WmmaaZppmmmaaZppmmmaaZppmmmaa5prmmuaa5prmmuaa5prmmuaa5poWmhaaFpoWmhaaFpoWmhaaFpoWmpaalpqWmpaalpqWmpaalpqWmpaaVppWmlaaVppWmlaaVppWmlaaVprWmtaa1prWmtaa1prWmtaa1prWmHU07mnY07Wja0bSjaUfTjqYdTTuaNpo2mjaaNpo2mjaaNpo2mjaaNpq2mraatpq2mraatpq2mraatpqmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWuloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhlsi9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryL2O3OvIvY7c68i9jtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr1el5qmlsi9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q9rtzryr2u3OvKva7c68q92kXw9bY2rB3rwDqxLqwb64P1YI25hrmGuYa5hrmGuYa5hrmGuYa5hrmOuY65jrmOuY65jrmOuY65jrmOuYG5gbmBuYG5gbmBuYG5gbmBuYG5ibmJuYm5ibmJuYm5ibmJuYm5ibmFuYW5hbmFuYW5hbmFuYW5hbmFuY25jbmNuY25jbmNuY25jbmNuY25B3MP5h7MPZh7MPdg7sHcg7kHcw/mDuYO5g7mDuYO5g7mDuYO5g7mDuYu5i7mLuYu5i7mLuYu5i7mLuaiV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4FeBXoV6FWgV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4leJXqV6FWiV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV4VeFXpV6FWhV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjVwe9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVQa8OejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NerXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi17Btxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8+3WNuegVfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvBtxt8u8G3G3y7wbcbfLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDt1/XmItewbc7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7c7fLvDtzt8u8O3O3y7w7cHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfPt1jbnoFXx7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wLcHfHvAtwd8e8C3B3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrdf15iLXsG3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3J3x7wrcnfHvCtyd8e8K3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3z7dY256BV8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8G3F3x7wbcXfHvBtxd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3z7dY256BV8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3z7dY256BV8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8e8O3N3x7w7c3fHvDtzd8+4FvP/DtB779wLcf+PYD337g2w98+4FvP/DtB779wLcf+PYD337g2w98+4FvP/DtB779wLcf+PYD337g2w98+4FvP/DtB779wLcf+PYD337g2w98+4FvP/DtB779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1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXg14NejXo1aBXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1apXc1Gv5qJezUW9mot6NRf1ai7q1VzUq7moV3NRr+ZywVzDXMNcw1zDXMNcw1zDXMNcw1zDXMdcx1zHXMdcx1zHXMdcx1zHXMfcwNzA3MDcwNzA3MDcwNzA3MDcwNzE3MTcxNzE3MTcxNzE3MTcxNzE3MLcwtzC3MLcwtzC3MLcwtzC3MLcxtzG3MbcxtzG3MbcxtzG3MbcxtyDuQdzD+YezD2YezD3YO7B3IO5B3MHcwdzB3MHcwdzB3MHcwdzB3MHcxdzF3MXcxdzF3MXcxdzF3MXc9ErQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArQ68MvTL0ytArR68cvXL0ytErR68cvXL0ytErR68cvXL0ytErR68cvXL0ytErR68cvXL0ytEr+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW8f+PaBbx/49oFvH/j2gW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PbrGnPRK/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVvX/j2hW9f+PaFb1/49oVv30/fHvf1R68+14a1Y32fux/r29y9fKwL69vc/dj/3qvHerBere+9Wv9YG9aOdWCdWN/nfjy2e68e64P1YL3P9Ydvf6zvc/NjfZ9bH+vAOrEurO9z+2N9sB6s73PPfX3v1WNtWDvWgXViXVjf587H+mB9n7sf69X61qtrpD/WhrVjHbe1fawT67qt/WPdWB+s57b+eD5vvXqs4z7343kIw9qxDqwT68K6sT5YD9ardWJuYm5ibmJuYm5ibmJuYm5ibmJuYW5hbmFuYW5hbmFuYW5hbmFuYW5jbmNuY27f534cD51YF9aN9cF6sF6tzwVrw9qxxtyDuQdzD+YezD2YezB3MHcwdzB3MHcwdzB3MHcwdzB3MHcxdzF3MXcxdzF3MffWq+vJy8f6YD1Y73N99+3XE5mPtWF9m2v1sQ6sE+vCPo31wXqwXu1vmGumPQ1zLfTfWmKNuYa5drDnYL3a896rx9r039579VhjrmPuvVefe9579Vgf7DlY43m+9+qxxtzA3HuvPve89+qxLu1579Vjjec58DwH5ibmJl7fe68ea7y+idc38TwnnufE3MTcxOtbeH0Lr2/h9S08z4XnuTC3MLfw+hZe38Lr23h9G89z43luzG3Mbby+jde38fo2Xt/G83zwPB/MPZh78PoevL4Hr+/B63vwPB88zwdzB3MHr+/g9R28voPXd/A8D57nwdzB3MHru3h9F6/v4vVdPM+L53kxF73Kxeu7eH1Xr29dLljrea6LYx1YJ9Z6fevSWB/sOVjreS67YI25hrmm17cssdbrW9ZYH/y3gzXmOua6Xt9yx1qvb3liXfhvG2vMdcx1vb4VF6z1+lY41nieA89zYG5gbhzsOVjj9U28vonnOfE8J+Ym5iZe38Trm3h9E69v4nkuPM+FuYW5hde38PoWXt/C61t4ngvPc2FuY27j9W28vo3Xt/H6Np7nxvPcmNuY23h9D17fg9f34PU9eJ4PnueDuQdzD17fg9f34PUdvL6D53nwPA/mDuYOXt/B6zt4fQev7+B5XjzPi7mLuYvXd/H6Ll7fxeuL86vC+VXh/KovF6z1+vbFsdbr2zi/apxfNc6vGudXjfOrxvlV4/yqcX7VOL9qnF81zq8a51eN86vG+VXj/KpxftU4v2qcXzXOrxrnV43zq8b5VeP8qnF+1Ti/apxfNc6vGudXjfOrxvlV4/yqcX7VOL9qnF81zq8a51eN86vG+VXj/KpxftU4v7r79uuNvY91Y32wHqxvc/1+P+Hu25/r21zvj7VjfZsbH4/t3qv4eDz3XsX5WN/mxn6sD9aYe+/V5/req8fasMbce68e69RjuPfq8zHce/X5GO69eqxHj+Heq8/1wdyDufdePdaBdeox3Hv1WLcez71Xn4/n3qvPx3Dv1ef63qvPx3Dv1WONuYO591491nh97736fAz3Xj3Wo8dz79Xn47n36vMx3Hv1WLsew71XjzXmLuYujqvFcXXv1edjuPfqY3337Z+P5+7bPx/P3bd/Poa7b3+u8/kY7r79udbcu29/rgdrHVd33/54DGZYux7PvVefj+feq8/HYIW1jue7b3+uMdcw1y9YG9Y6nu++/bnW8Xz37Y/H4zqe7779udbxfPftj3VgbmBuONaBtY7nu29/rnU833374/GEjue7b3+sU8fz3bc/15ibmJuJdWGt4/nkwVrH8923Px5P6Xi++/bnWsfzqcAacwtzC8dV4bgqHc+ncDw3jufG8dw4nhvHc+N4bhzPjbmNuY3jqnFcHRzPB8fzwfF8cDwfHM8Hx/PB8XxwPB/MPZg7OK4Gx9XgeB4cz4PjeXA8D47nwfE8OJ4Hx/Ni7mLu4rhaHFeL43lxPC+O58XxvDieV8fzXHQ8z8Ww1ty7b3+uE+vCWsfzXA7WOp7vvv3z8dx9++MxmGGt43kssMZcw1xrrA/WOp7HdDzfffvj8biO57tvfzwGD6x1PI8X1pjrmOuDtY6rCR3PE4a1jue7b388ntDxfPftz7WO54mDNeYG5uYFa8Nax/NkYK3j+e7bH48ndTzffftzreN5UsfzFOYW5haOq8JxVTqepwprHc9TOp7vvv3xGArHc+N4bhzPjbmNuY3jqnFcNY7nxvHcOJ4bx/PB8XxwPB8czwfH88Hcg7kHx9XBcXVwPB8cz4PjeXA8D47nwfE8OJ4Hx/Ng7mDu4LgaHFeL43lxPC+O58XxvDieF8fz4nheHM+Luau5d9/+XBvWOp73EljreN6Ljue7b/98DHff/lzreN6Ljuc1zDXMNcc6sNbxvFZY63he0/F89+2Px2A6ntd1PK8b1pjrmOuJdWGt43n9YK3jeV3H8923Px5DGNY6njcCa8wNzI3G+mCt43lDx/OmjudNHc933/54DBlY63jeLKwxF9eDi+vBTRxXpeN5cT24peN5S8fzlo7nxfXg4npwcT24uB5cXA8urgcX14OL68HF9eDienBxPbi4HlxcDy6uBxfXg4vrwcX14OJ6cHE9uLgeXFwPLq4HF9eDi+vBxfXg4npwcT24uB5cXA8urgcX14OL68HF9eDienBxPbi4HlxcDy6uBxfXg4vrwcX14OJ6cHE9uLge3Of14PUH+M/rwdv6cTzf1o/j+bYOrB/H821dWD/m3tYH68F6tX5eD97WhrXr8TyvB2/r1GN4Xg/e1re5mR/r29ysj/Vtbn48tnuv6mPPe6/KPtaG9W1ufcy696o+Hs+9V4+/L/x94+8P/n7w96u/v/fq8+/vvXr8PeYG5gbmBuYG5gbmBuYG5ibmJuYm5ibmJuYm5ibmJuYm5ibmFuYW5hbmFuYW5hbmFuYW5hbmFuY25jbmNuY25jbmNuY25jbmNuY25h7MPZh7MPdg7sHcg7kHcw/mHsw9mDuYO5g7mHvvVc3H+j73431x79Xjf9P4bw/+fvD3q7+/9+rz7++9evy94+8Df5/4e8xdzF3MXcxdzb379s+/v/v25987/j7w94m/L/x94+8P/n7w95hrmGuYa5hrmGuYa5hrmGuYa5hrmOuY65jrmOuY65jrmOuY65jrmOuYG5gbmBuYG5gbmBuYG5gbmBuYG5ibmJuYm5ibmJuYm5j70av5WJ/nMW/olaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl4ZemXolaFXhl7ZYO5g7mDuYO5g7mDuYO5i7mLuYu5i7mLuYu5i7mLuYu5qrl801y+Gv3f8feDvE39f+PvG3x/8/eDv93nM+0ev9mOt95GjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eeWJuYm5ibmJuYW5hbmFuYW5hbmFuYW5hbmFuYW5jbmNuY25jbmNuY25jbmNuY25j7sHcg7kfvfo45j969XHMo1eOXjl65eiVo1eOXjl65eiVo1eOXjl65eiVo1eOXjl65eiVo1eOXjl65eiVo1eOXjl65eiVo1eOXgV6FehVoFeBXgV6FehVoFeBXgV6FRfMNcw1zDXMNcw1zDXMNcw1zDXMNcx1zHXMxfVg4HowcD0YuB4MXA8GrgcD14OB68HA9WDgejBwPRi4HgxcD3749o9j/sO3fxzzgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXoVaBXgV4FehXo1Ydvf/w95h7MPZh7MPdg7sHcg7mDuYO5g7mDuYO5uB4MXA8GrgcD14OB68HA9WDgejBwPRi4HgxcDwauBwPXg4HrwQ/f/nnMf/TqfswnepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiV4lepXoVaJXiftXiftXiftXiftXiftXiftXiftXiftXiftXiftXiftXiftXiftXievBxPVg4nowcT2YuB5MXA8mrgcT14OJ68HE9WDiejBxPZi4Hvzw7R/H/Idv/zzm0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9SvQq0atErxK9Sty/Sty/Kty/Kty/Kty/Kty/Kty/Kty/Kty/Kty/Kty/Kty/Kty/KlwPFq4HC9eDhevBwvVg4XqwcD1YuB4sXA8WrgcL14OF68HC9eCHb/845j98+8cxX+hVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhV6VehVoVeFXhXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxXuXxWuBwvXg4XrwcL1YOF6sHA9WLgeLFwPFq4HC9eDhevBwvVg4Xrww7d/HvMfvfo45tGrQq8KvSr0qtCrQq8KvSr0qtCrQq8KvWr0qtGrRq8avWr0qtGrRq8avWr0qtGrRq8avWr0qtGrRq8avWr0qtGrRq8avWr0qtGrRq8avWrcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2rcv2pcDzauBxvXg43rwcb1YON6sHE92LgebFwPNq4HG9eDjevBxvXgh2//OOY/fPvHMd/oVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV417l817l817l817l817l817l817l817l817l817l817l817l817l8dXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA8eXA9++PaPY/7Dt38c8we9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVQa8OenXQq4NeHfTqoFcHvTro1UGvDu5fHdy/Orh/dXD/6uD+1cH9q4P7Vwf3rw7uXx3cvzq4f3Vw/+rg/tXB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eDB9eCHb/885o9+DnvQq4NeHfTqoFcHvTro1UGvDnp10KuDXh306qBXB7066NVBrw56ddCrg14d9OqgVwe9OujVoFeDXg16NejVoFeDXg16NejVoFeDXg16NejVoFeD+1eD+1eD+1eD+1f/H1P3lhtJjmVRdEq6L5J3/hPrLrkiff0RgSo7Qsi0IXosIB+fXz0+v3p8fvX4/Orx+dXj86vH51ePz68en1897oOP++DjPvi4Dz7ug4/74OM++LgPPu6Dj/vg4z74uA8+7oMf3/555z++/fPOP3r16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV49ePXr16NWjV4/Prx6fXz0+v3p8fvX4/Orx+dXj86vH51ePz68en189Pr96fH71+PzqcR983Acf98HHffBxH3zcBx/3wcd98HEffNwHH/fB5T643Ac/vv3zzn98++edX3q19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnV8vnVch9c7oPLfXC5Dy73weU+uNwHl/vgch9c7oPLfXC5Dy73wY9v/3vnz/ffYZdeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uv9tur+Pn2Kn6+vYqf7+dX8fP9/Cp+vp9f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dovdYrfYLXaL3WK32C12m91mt9ltdpvdZrfZbXab3WZ32B12h91hd9gddofdYXfYHXYPu4fdw+5h97B72D3sHnYPu4fdy+5l97J72b3sXnYvu5fdy+5l97H72H3sPnYfu4/dx+5j97H72F12l91ld9lddpddetX0qulV06uhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68Ovbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dV+e1U/317Vz7dX9fPtVf18e1U/317Vz7dX9fPtVf18e1U/317Vzw+7wW6wG+wGu8FusBvsBrvBbrCb7Ca7yW6ym+wmu8luspvsJrvFbrFb7Ba7xW6xW+wWu8VusdvsNrvNbrPb7Da7zW6z2+w2u8PusDvsDrvD7rA77A67w+6we9g97B52D7uH3cPuYfewe9g97F52L7uX3cvuZfeye9m97F52L7uP3cfuY/ex+9h97D52H7uP3cfusrvsLrvL7rK77C67y+6yS6+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr/DthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2wvfXvj2wrcXvr3w7YVvL3x74dsL31749sK3F7698O2Fby98e+HbC99e+PbCtxe+vfDthW8vfHvh2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1v76RX+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2///zC69wrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74Nsn6RW+ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3g2w++/eDbD7794NsPvv3//4mYXXqFbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j28/Ht7+9cnJvzcD6cL+fHef87f3z7v3NwTs7FuTkP58P5cn6c2Q12g91gN9gNdoPdYDfYDXaD3WQ32U12k91kN9lNdpPdZDfZLXaL3WK32C12i91it9gtdovdZrfZbXab3Wa32W12m91mt9kddofdYXfYHXaH3WF32B12h93D7mH3sHvYPewedg+7h93D7mH3snvZvexedi+7l93L7mX3snvZfew+dh+7j93H7mP3sfvYfew+dpfdZZdeDb0aejX0aujV0KuhV0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvDr069OrQq0OvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvLr269OrSq0uvHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evHr169OrRq0evll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6td9e3Z9vr+7Pt1f359ur+/Pt1f359ur+fHt1f769uj/fXt2fb6/uzw+7wW6wG+wGu8FusBvsBrvBbrCb7Ca7yW6ym+wmu8luspvsJrvFbrFb7Ba7xW6xW+wWu8VusdvsNrvNbrPb7Da7zW6z2+w2u8PusDvsDrvD7rA77A67w+6we9g97B52D7uH3cPuYfewe9g97F52L7uX3cvuZfeye9m97F52L7uP3cfuY/ex+9h97D52H7uP3cfusrvsLrvL7rK77C67y+6yS6+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr/DtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7RfffvHtF99+8e0X337x7ffj2zc/58f5/3fjxu/5f7367xz/O3/+N//rVdz+nItzcx7O53/n/Zwv58d5v+f7wzk4J+fi3JyHM7uX3cvuZfex+9h97D52H7uP3cfuY/ex+9hddpfdZXfZXXaX3WV32V12/9ereL/f01/f/t85OCfn4tych/PhfDk/zuwGu8FusBvsBrvBbrAb7Aa7wW6ym+wmu8luspvsJrvJbrKb7Ba7xW6xW+wWu8VusVvsFrvFbrPb7Da7zW6z2+w2u81us9vsDrvD7rA77A67w+6wO+wOu8PuYfewe9g97B52D7uH3cPuYfewe9m97F52L7uX3cvuZfeye9m97D52H7uP3cfuY/ex+9h97D52H7vL7rK77C67y+6yu+wuu8vut1fv59ur9/Pt1fv59ur9fHv1fr69ej/fXr2fb6/ez7dX7+fbq/fzw26wG+wGu8FusBvsBrvBbrAb7Ca7yW6ym+wmu8luspvsJrvJbrFb7Ba7xW6xW+wWu8VusVvsNrvNbrPb7Da7zW6z2+w2u83usDvsDrvD7rA77A67w+6wO+wedg+7h93D7mH3sHvYPewedg+7l93L7mX3snvZvexedi+7l93L7mP3sfvYfew+dh+7j93H7mP3sbvsLrvL7rK77C67y+6yu+zSq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06uhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68OvTr06tCrQ68Ovbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvbr06tKrS68uvXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR68evXr06tGrR6/w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O0P3/7w7Q/f/vDtD9/+8O2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2/z+zS6/w7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++ffHti29ffPvi2xffvvj2xbcvvn3x7YtvX3z74tsX37749sW3L7598e2Lb198++LbF9+++PbFty++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v77939dQwfn7Pk8VZ3aL3TqcL+fv+zz1fZ+nv+/z9Pd9/vXt/76GLs7f93l6OLPb7PbjzHs13/d5Jjh/3+eZ7/v869v/fQ0znL/v88zlzO6we3ivDu/V4X0+vM+H9/nwPh/e58P7fHifD+/zZfeye3mvLu/V5X2+vM+X9/nyPl/e58v7/HifH+/zY/ex+3ivHu/V431+vM+P9/nxPi/v8/I+L+/z8j4vu8vu8l4t79XyPu/3fT4/3/f5/Hzf51/f/vc1/Pr2/87f9/n8DOfv7vm5nB/n73t14vs+nwjO3/f5xPd9/vXt/76GGM7f9/nE5cwu98HDffBkcP6+z4f74Mnv+3zy+z6f/L7Ph/vg4T54uA8e7oOH++DhPni4Dx7ug4f74OE+eLgPHu6Dh/vg4T54uA8e7oOH++DhPni4Dx7ug4f74OE+eLgPHu6Dh/vg4T54uA8e7oOH++DhPni4Dx7ug4f74OE+eLgPHu6Dh/vg4T54uA8e7oOH++DhPni4Dx7ug4f74OE+eLgPHu6Dh/vg4T54uA8e7oOH++DhPni4Dx7ug4f74OE+eLgPHu6Dh/vgr2///w81P+f/7fbvZy+/vv3/P7D8nP+3O59n/vZq4nMuzv/bnc/Wb6/m8/X89urfn1/+/PHn+9+f//r2vz//9e3//Xny58WfN38+/Pnhzy9//vhzdoPdYDfYDXaD3WA32A12g91gN9lNdpPdZDfZTXaT3WQ32U12i91it9gtdovdYrfYLXaL3WK32W12m91mt9ltdpvdZrfZbXaH3WF32B12h93fXs37nH9393O+/G8e/9/9/vlvr/7+/LdX//48+fPiz5s/H/788OfsHnYPu5fdy+5l97J72b3sXnYvu5fdy+5j97H72H3sPnYfu4/dx+5j97G77C67y+6yu+wuu8vusrvs7nf3/Xx330/w58mfF3/e/Pnw54c/v/z548/ZDXaD3WA32A12g91gN9j99Op9zvvfO//o1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj169YXfYHXaH3WH3sHvYPewedg+7h93D7mH3sHvYvexedi+7l93L7mX3snvZvexedh+7n1593vlPrz7vPL169OrRq0evHr169OrRq0ev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PljcB4v7YHEf/PPtn3d+//t32MS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098ezb3weY+2NwHm/tgcx9s7oPNfbC5D/759vc5//fvsIlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749hzug8N9cLgPDvfB4T443AeH++BwH/zz7b/v/J9v38/5+3OEb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+ew31wuA8O98HhPjjcB4f74HAfHO6Df779886///4dNvHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnof74OE+eLgPHu6Dh/vg4T54uA8e7oN/vv19zt9/h8W3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e17ug5f74OU+eLkPXu6Dl/vg5T54uQ/++fb3OX//HRbfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7YlvT3x74tsT35749sS3J7498e2Jb098e+LbE9+e+PbEtye+PfHtiW9PfHvi2xPfnvj2xLcnvj3x7Xm5D17ug5f74OU+eLkPXu6Dl/vg5T7459s/7/xvr87P51ycm/Nw/t/u+XvO5fy/3XM/5/3+73979e8cnNn97dX5fD2/vfp3nu/zH7u/vfrb+u3Vv+ewu+wuu7+9+nv+svvbq7/nL7u/vfrb+u3Vv+ewu9/dj2//d47/nv/x7f/O9d/zP77933n+2/r49n/PuZwfZ3Z/e/X3/GD3t1d/zw92f3v1txXDc9gNdoPd3179PT/Z/e3V3/OT3d9e/W3l9736+PZ/Z3aT3d9e/Xs+u7+9+nt+sfvbq7+t+r7PH9/+78xusfvbq3/PZ/e3V3/Pb3Z/e/W31d/3+ePb/53ZbXZ/e/X3/Gb3t1f/ns/ub6/+tub7Pn98+78zu8Pub6/+nj/szuX57P726m/r8D4fdg+7h93z/fn9+PZ/5+/P78e3/zs/tnifL7uXXXr18e1/z7/s3u/P76NXH9/+t3V5n+nVo1ePXn18+9/z6dXHt/89n159fPvf1uN9plePXj169fHtf8+nVx/f/vd8evXx7X9by/tMrx69evTq49s/z1969fHtn+cvvfr49s/Wx7f/e87hfDk/zt+f36VXH9/+93x69fHtf1vxfZ+XXi29Wnr18e3/ns9ufn9+l159fPvfVn7f56VXS6+WXn18+7/ns5vfn9+lVx/f/rdV3/d56dXSq6VXH9/+93x69fHt/57Pbn+78fHtf8+hV0uvll59fPvf8+nVx7f/ez67/e3Gx7f/PYdeLb1aevXx7X/Pp1cf3/73fHr18e3/tnif6dXSq6VXH9/+93x69fHtf8+nVx/f/rd1eJ/p1dKrpVcf3/73fHr18e1/z6dXH9/+t3V5n+nV0qulVx/f/vd8evXx7X/Pp1cf3/639Xif6dXSq6VXH9/+93x69fHtf8+nVx/f/re1vM/0aunV0quPb/99fv18e1Uf3/77/Pr59qo+vv13qz6+/fc59fPtVf18e1U/317Vx7f/ez678fN9frAb+d2K+j4n2A12g924PJ/d2O/zk92M71bm9znJbrKb7Ob5Pj/Zzcfz2a2f71bF9znFbrFb7NZ8n1/s1uX57NZ+t/rn+5xmt9ltdru/z292+3yf3+z2Y2u/zxl2h91hd+r7/GF35vv8YXfud2sez2H3sHvYPfl9/mH39Pf5h91zvlufXu3n/L/d+/fM/Z5/e/XvHJyTc3FuzsP5cL6c2b3sPnYfu4/dx+5j97H72H3sPnYfu8vusrvsLrvL7rK77C67y+5+dz++/d85OCfn4tych/PhfDk/zuwGu8FusBvsBrvBbrAb7Aa7wW6ym+wmu8luspvsJrvJbrKb7Ba7xW6xW+wWu8VusVvsFrvFbrPb7Da7zW6z2+w2u81us9vsDrvD7rA77A67w+6wO+wOu8PuYfewe9g97B52D7uH3cMuvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qulV06umV02vml41vWp61fSq6VXTq6ZXTa+aXjW9anrV9KrpVdOrpldNr5peNb1qetX0qunV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4NvRp6NfRq6NXQq6FXQ6+GXg29Gno19Gro1dCroVdDr4ZeDb0aejX0aujV0KuhV0Ovhl4denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh14denXo1aFXh15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl15denXp1aVXl149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj149evXo1aNXj14tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRq6dXSq6VXS6+WXi29Wnq19Grp1dKrpVdLr5ZeLb1aerX0aunV0qulV0uvll4tvVp6tfRqv73qn2+v+ufbq/759qp/vr3qn2+v+ufbq/759qp/vr3qn2+v+ueH3WA32A12g91gN9gNdoPdYDfYTXaT3WQ32U12k91kN9lNdpPdYrfYLXaL3WK32C12i91it9htdpvdZrfZbXab3Wa32W12m91hd9gddofdYXfYHXaH3WF32D3sHnYPu4fdw+5h97B72D3sHnYvu5fdy+5l97J72b3sXnYvu5fdx+5j97H72H3sPnYfu4/dx+5jd9lddpfdZXfZXXaX3WV32aVX+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGt3fSK3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298e+PbG9/e+PbGtze+vfHtjW9vfHvj2xvf3vj2xrc3vr3x7Y1vb3x749sb39749sa3N7698e2Nb298++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtk/QK3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O3/x9SdZNmxHEsWnZJbpcX8J0bGQwC6e7rYoHxP3DipZiIUC/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/LtQb49yLcH+fYg3x7k24N8e5BvD/Lt/7eI0YVX5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN8e5NuDfHuQbw/y7UG+Pci3B/n2IN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7Um+Pcm3J/n2JN+e5NuTfHuSb0/y7fkn316/82MO5mQu5p75P179nRfzZj7M6Ca6iW6im+gmuoVuoVvoFrqFbqFb6Ba6hW6h2+g2uo1uo9voNrqNbqPb6Pbo/sm3/50X82Y+zJf5MQdzMhczugvdhe5Cd6G70F3oLnQXugvdhe5Gd6O70d3obnQ3uhvdje5Gd6N70D3oHnQPugfdg+5B96B70D3oXnQvuhfdi+5F96J70b3oXnQvug/dh+5D96H70H3oPnQfug/dh26gG+gGuoEuvNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa82vNrwasOrDa8OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68OvDrw6sCrA68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68uvLrw6sKrC68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68evHrw6sGrB68CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrgVcCrgFcBrwJeBbwKeBXwKuBVwKuAVwGvAl4FvAp4FfAq4FXAq4BXAa8CXgW8CngV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrxJeJbxKeJXwKuFVwquEVwmvEl4lvEp4lfAq4VXCq4RXCa8SXiW8SniV8CrhVcKrhFcJrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquBVwauCVwWvCl4VvCp4VfCq4FXBq4JXBa8KXhW8KnhV8KrgVcGrglcFrwpeFbwqeFXwquFVw6uGVw2vGl41vGp41fCq4VXDq4ZXDa8aXjW8anjV8KrhVcOrhlcNrxpeNbxqeNXwquFVw6uGVw2vGl41vGp41fCq4VXDq4ZXDa8aXjW8anjV8KrhVcOrhlcNrxpeNbxqeNXwquFVw6uGVw2vGl41vGp41fCq4VXDq4ZXDa8aXjW8anjV8KrhVcOrhlcNrxpeNbxqeNXwquFVw6uGVw2vGl41vGp41fCq4VXDq4ZXDa8aXjW8anjV8KrhVcOrhlcNrxpeNbxqeNXwquFVw6uGVz28qm94Vd/wqr7hVX3Dq/qGV/UNr+obXtU3vKpveFXfh+5Cd6G70F3oLnQXugvdhe5Cd6G70d3obnQ3uhvdje5Gd6O70d3oHnQPugfdg+5B96B70D3oHnQPuhfdi+5F96J70b3oXnQvuhfdi+5D96H70H3oPnQfug/dh+5D96Eb6Aa6gW6gG+gGuoFuoBvoBrqJbqKb6Ca6iW6im+gmuoluolvoFrqFbqFb6Ba6hW6hW+gWuo1uo9voNrqNbqPb6Da6jS68WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8WvBqwasFrxa8It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRb///dSm68Ip8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8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/uBZ4w+e1XwvvKK//dDffhb71YZX9Lcf+tvPZr/a8Ir+9rPZrza8or/90N9+NvvVhlf0tx/6289mv9rwiv72s9mvNryiv/3Q3342+9WGV/S3H/rbz2a/2vCK/vazN7ob3YMu+9U+6B50D7rsV/uge9Adf/Ds8QfPHn/w7PEHzx5/8OzxB88ef/Ds8QfPHn/w7PEHzx5/8OzxB89+fC+82vBqw6v9+F54teHVhlf78b3wasOrHejCqw2vNrzagS682vBqw6sd6MKrDa92oguvNrza8GonuvBqw6sNr3ahC682vKK//dDffjb71Wa/or/90N9+NvvVZr+iv/3sRpf9ao8/ePb4g2ePP3j2+INnjz949viD54w/eM74g+eMP3jO+IP/ny/zfO+BVwdeHXhFf/s58OrAqwOv6G8/B14deEV/+6G//Rx4deAV/e2H/vZz4NWBV/S3nwOvDrw6G114deDVgVfnoAuvDrw68OocdOHVgVf0t59z0GW/OuxX9Lefc9FlvzrsV+eie9FlvzrjD54z/uA54w+eM/7gOeMPnjP+4DnjD54z/uA54w+eM/7gOeMPHvrbz4FXB14deEV/+znw6sCrA69O8L3w6sAr+tvPgVcHXh14RX/7OfDqwKsDr06iC68OvDqFLrw68OrAq1PowqsDrw68Oo0uvDrwiv72cxpd9qvDfkV/+zmNLvvVZb+6c99+LvdXl/3qjj947viD544/eO74g+eOP3ju+IPnjj947viD544/eO74g+eOP3jobz8XXl14deEV/e3nwqsLry68upvvhVcXXtHffi68uvDqwiv628+FVxdeXXh1D7rw6sKre9CFVxdeXXh1L7rw6sKrC6/uRRdeXXhFf/u5F132q8t+RX/7uQ9d9qvLfnUfug9d9qs7/uC54w+eO/7gueMPnjv+4LnjD547/uC54w+eO/7gueMPnjv+4KG//Vx4deHVhVf0t58Lry68uvDqJt8Lry68or/9XHh14dWFV/S3nwuvLry68OoWuvDqwqvb6MKrC68uvLqNLry68OrCqzf+4Hnw6sEr+tvPG3/wPParx35Ff/t54w+ex3712K/eQnehy371xh88b/zB88YfPG/8wfPGHzxv/MHzxh88b/zB88YfPG/8wfMn3/535nvh1YNXD17R334evHrw6sGrd/heePXgFf3t58GrB68evKK/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3eMP3j3+4N3jD1762++GVxtebXhFf/vd8GrDqw2v9uV74dWGV/S33w2vNrza8Ir+9rvh1YZXG17thy682vBqP3Th1YZXG17tQBdebXi14dUOdOHVhlf0t98d6LJfbfYr+tvvTnTZrzb71U50E132qz3+4N3jD949/uDd4w/ePf7g3eMP3j3+4N3jD949/uDd4w/ePf7gpb/9bni14dWGV/S33w2vNrza8Go33wuvDryiv/0eeHXg1YFXZ/zBn//xJ3MyFzO68OrAq7PQhVcHXh14dRa68OrAqwOvzkYXXh14RX/7PRtd9qvDfkV/+z0bXfarw351DroHXfarM/7gPeMP3jP+4D3jD94z/uA94w/eM/7gPeMP3jP+4D3jD94z/uClv/0eeHXg1YFX9LffA68OvDrw6jy+F14deEV/+z3w6sCrA6/ob78HXh14deDVCXTh1YFXJ9CFVwdeHXh1El14deDVgVcn0YVXB17R335Post+ddiv6G+/p9BlvzrsV6fQLXTZr874g/eMP3jP+IP3jD94z/iD94w/eM/4g/eMP3jP+IP3jD94/+Tb/8z0t98Lry68uvCK/vZ74dWFVxde3Xlv4l54deEV/e33wqsLry68or/9Xnh14dWFV3ehC68uvLobXXh14dWFV3ejC68uvLrw6h504dWFV/S333vQZb+67Ff0t9970GW/uuxX96J70WW/+s2355/5MQdzMhfzcPI33/47Dyf/5Nv/zof5MvO98OrCqwuv6G+/F15deHXh1Q2+F15deEV/+73w6sKrC6/ob78XXl14deHVTXTh1YVXN9GFVxdeXXh1C114deHVhVe30IVXF17R335voct+ddmv6G+/t9Flv7rsV7fRbXTZr37z7f/9xt6853XfvOd13/iD940/eN/4g/eNP3jfvOd137zndd+853XfvOd16W+/D149ePXgFf3t98GrB68evHrz3sR98OrBK/rb74NXD149eEV/+33w6sGrB6/eRhdePXj1Drrw6sGrB6/eQRdePXj14NW76MKrB6/ob7/vost+9div6G+/76LLfvXYr95D96HLfvXmPa/75j2v++Y9r/vmPa/75j2v++Y9r/vmPa/75j2v++Y9r/vmPa/75j2vS3/7ffDqwasHr+hvvw9ePXj14NVLvhdePXhFf/t98OrBqwev6G+/D149ePXg1St04dWDV6/QhVcPXj149RpdePXg1YNXr9GFVw9e0d9+3/TJ3GC/CvYr+ttvTJ/MDfarYL+K6ZO5Me/j3GC/innP68a853Vj3vO6Me953Zj3vG7Me1435j2vG/Oe1415z+vGvOd1Y97zuvS334BXAa8CXtHffgNeBbwKeBWb74VXAa/ob78BrwJeBbyiv/0GvAp4FfAqDrrwKuBVXHThVcCrgFdx0YVXAa8CXsVDF14FvKK//cZDl/0q2K/ob7/x0GW/CvarCHQDXfarmPe8bsx7XjfmPa8b857XjXnP68a853Vj3vO6Me953Zj3vG7Me173T779vwzk/c23//7nwZzMxdwz18e8mDfzYb7M6Ba6hW6hW+g2uo1uo/uHV/vPfJkfczAPJwNeBbxKeJXTJ3MTXiW8SniV0ydzE14lvKK//eaHLvtVsl/R335zoct+lexXudBd6LJf0d9+E14lvEp4RX/7TXiV8CrhVW504VXCq+S+/Tff/jtv5vn7TXiV7FfJeTDhVcKrZL9KzoMJr5L9KjkPJrwi337Jt1/y7TfhFfn2S779km+/Ca/It1/y7TfhFfn2S779km+/Ca/It1/y7Zd8+014Rb79km+/yX5Fvv2Sb7/k22+yX5Fvv+TbL/n2m+xX5Nsv+fab09d3c/r6bk5f383id8X9Ff3tl/72S3/7Jd9+6W+/9Ldf+ttv4g/S337pb7/JfTv97Zf+9kt/+03u2+lvv/S3X/rbb3HfTn/7pb/9FvdXxX174Q8WeYbi/qq4by/8wSLPUNy3F/5gkWco7q/ob7/0t1/6229xf0V/+6W//dLffov7dvrbL/3tt/AHC3+w8AcLf7DwBwteFf5g4Q8W/mDhD5Jvv+TbL/3tl/72S779km+/9Ldf+tsv+fZb+IP0t1/y7Zd8+6W//dLffsm3X/Ltl/72S3/7Jd9+i/t2+ttvwSvy7Zd8+yXffgtekW+/5Nsv+fZb8Ip8+yXffgtekW+/5Nsv+fZb8Ip8+yXffsm334JX5Nsv+fZb+IOFP1j4g4U/WPiDhT9Y+IOFP1j4g4U/WPiDxXmQfPsl337Jt9/iPEi+/ZJvv+Tbb3F/Rb79km+/zXmwuW+nv/3S336b82Bz305/+6W//Tb37c19O/3tt7m/au6vGl41vGrur5r7q4ZXDa+a+6vmvr3hVXMebO6vmvv2xh9szoPN/VVz3974g839VXPf3viDjT/Y+IONP9j4g40/2PiDjT/Y+IONP9j4g40/2OxXDa/ob7/0t99mv2p4RX/7pb/9NvtVwyv622+zXzW8or/90t9+m/2q4RX97Zf+9tvsVw2v6G+/zX7V8Ir+9kt/+232q4ZX9Ldf+ttvs181vKK//Tb3V839VXPf3uxXzf1Vc3/V3Lc3+1Vzf9Xctzf+YOMPNv5g4w82/mDjDzb+YOMPNv5g4w82/mCPP/i+OQ++b3j1vuHV+4ZX75vz4PuGV+8bXr1vePW+ub963/DqfcOr9y10F7oL3eHV+xa6C92F7vDqfQvdje7w6n0b3Y3uRnd49b6N7kZ3ozu8et9B96A7vHr0tz/629930J396tHf/uhvf99Bd/arR3/7+y66s1+9b/zB940/+L7xB983/uD7xh983/iD7xt/8H3jD75v/MH3jT/4vvEHH/3tj/729w2v3je8evS3P/rb3ze8et/w6tHf/r7h1fuGV4/+9kd/+/sC3eHVo7/90d/+vkR3ePXob39foju8el+im+gmusXfb6Fb6Ba6xd9voVvoDq8e/e3vK3Qb3ebvt9FtdBvd5u+30W10G26MP/jW+INvjT/41viDb40/+Nb4g2+NP/jW+INvjT/41viDb40/+OhvfwteLXi14BX97W/BqwWvFrxac3/1Frxa8Ir+9rfg1YJXC17R3/4WvFrwasGrtdGFVwterYMuvFrwasGrddCFVwteLXi1LrrwasEr+tvfuuhedGe/evS3v3XRvejOfvXWQ/ehO/vVW+MPvjX+4FvjD741/uBb4w++Nf7gW+MPvjX+4FvjD741/uBb4w8++tvfglcLXi14RX/7W/BqwasFr1byvfBqwSv629+CVwteLXhFf/tb8GrBqwWvVqELrxa8WoUuvFrwasGr1ejCqwWvFrxajS68WvCK/va35r79bfarzX5Ff/vbc9/+NvvVZr/ac9/+9ty3v81+tccffHv8wbfHH3x7/MG3xx98e/zBt8cffHv8wbfHH3x7/MG3xx989Le/Da82vNrwiv72t+HVhlcbXu3N98KrDa/ob38bXm14teEV/e1vw6sNrza82gddeLXh1b7owqsNrza82hddeLXh1YZX+6ELrza8or/97Ycu+9Vmv6K//e2HLvvVZr/agW6gy361xx98e/zBt8cffHv8wbfHH3x7/MG3xx98e/zBt8cffHv8wfcn3/535nvh1YZXG17R3/42vNrwasOrXXwvvNrwiv72t+HVhlcbXtHf/ja82vBqw6vd6MKrDa92owuvNrw68OqMP/gOvDrw6sCrM/7g/+dgTubivx9d9qvDfkV/+zsLXfarw351FroLXfar33z7f7+x33z777yYN/NhHk7+5tt/5+Hkn3z737mYh5P0t78Drw68OvCK/vZ34NWBVwdencP3wqsDr+hvfwdeHXh14BX97e/AqwOvDrw6F114deDVeejCqwOvDrw6D114deDVgVcn0IVXB17R3/5OoMt+ddiv6G9/J9BlvzrsVyfRTXTZr37z7X9+Y/Oe1zvzntc74w++M/7gO+MPvjP+4Dvzntc7857XO/Oe1zvzntejv/0deHXg1YFX9Le/A68OvDrw6jTfC68OvKK//R14deDVgVf0t78Lry68uvDqzvs478KrC6/u9Mm8C68uvLrw6i504dWFVxde3YUuvLrwiv72dxe67FeX/Yr+9nc3uuxXl/3qbnQ3uuxXd97zenfe83p33vN6d97zenfe83p33vN6d97zenfe83p33vN6d97zenfe83r0t78Lry68uvCK/vZ34dWFVxde3cv3wqsLr+hvfxdeXXh14RX97e/CqwuvLry6D114deHVDXTh1YVXF17dQBdeXXh14dVNdOHVhVf0t7+b6LJfXfYr+tvfTXTZry771S10C132qzvveb0773m9O+95vTvveb0773m9O+95vTvveb0773m9O+95vTvveb0773k9+tvfhVcXXl14RX/7e/DqwasHr970ybwHrx68or/9PXj14NWDV/S3vwevHrx68OotdOHVg1dvoQuvHrx68OptdOHVg1cPXr2NLrx68Ir+9vc2uuxXj/2K/vb3DrrsV4/96h10D7rsV2/e83pv3vN6b97zem/e83pv3vN6b97zem/e83pv3vN6b97zem/e83p/8u3/ZSDfb779z3/+FvNmPsyX+TEHczIXc88c6Aa6gW6gG+gGuoFuoPuHV/vP3DP/4dXvvJiHkw9ePXj14NWbPpn34NWDVw9evemTeQ9ePXhFf/t7hS771WO/or/9vUKX/eqxX71Gt9Flv6K//T149eDVg1f0t78HrwJeBbyKyV+9gFcBr4L79t98+++czPP3G/Aq2K+C82DAq4BXwX4VnAcDXgX7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d+Z7N987vMpveJX0t+d3+N7hVX7Dq/wO3zu8ym94lfS353fQPegOr5L+9vwuuhfd4VV+F92L7vAqv4vuRfeiO7zK76H70H3oDq/ye+g+dIdXSX97fg/dQHf2q6S/Pb9AN9Cd/Sq/QDfQnf0qf/Ptf35j+TEv5s18mP9xMn/z7b/zP07mn3z737mYe+bie4vvHV7lV/z9Ft9bfO/wKr/i77f43uFVfg03Gt1Gt9FtuNHoNrqNbsON6WfIBa8WvFrz3kQueLXg1YJXa96byAWvFrxa8GotdOHVglf0t+da6C50Z79K+ttzLXQXurNf5drobnRnv8rffHv+mR9zMCdzMQ8n1/iDueY9r1zznleuec8r17znlfS354JXC14teEV/ey54teDVglfr8r3wasEr+ttzwasFrxa8or89F7xa8GrBq/XQhVcLXq2HLrxa8GrBqxXowqsFrxa8WoEuvFrwiv72XIFuojv7VdLfnivRTXRnv8qV6Ca6s1/lmve8cs17XrnmPa9c855XrnnPK9e855Vr3vPKNe955Zr3vHLNe1655j2vpL89F7xa8GrBK/rbc8GrBa8WvFrN98KrDa/ob88Nrza82vCK/vbc8GrDqw2v9ocuvNrwai904dWGVxte7YUuvNrwasOrvdGFVxte0d+ee6PLfrXZr+hvz73RZb/a7Ff7oHvQZb/a855X7nnPK/e855V73vPKPe955Z73vHLPe1655z2v3POeV+55zyv3vOeV9LfnhlcbXm14RX97bni14dWGV/vxvfBqwyv623PDqw2vNryivz03vNrwasOrHejCqw2vdqALrza82vBqJ7rwasOrDa92oguvNryivz13ost+tdmv6G/PXeiyX232q13oFrrsV3ve88o973nlnve8cs97XrnnPa/c855X7nnPK/e855V73vPKPe955Z98+38ZyPzNt39/5sW8mQ/zZX7MwZzMxdwzL3QXugvdhe5Cd6G70F3o/uHV/jP3zH949Tsv5uHkgVcHXh14daZPJg+8OvDqwKszfTJ54NWBV/S35znosl8d9iv62/McdNmvDvvVuehedNmv6G/PA68OvDrwiv72PPDqwKsDr85DF14deHXmvj1/8+2/czLP3++BV4f96nAePPDqwKvDfnU4Dx54ddivDufBA6/Ityf59iTfngdekW9P8u1Jvj0PvCLfnuTb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7z7DV+M78B34/vHqp/Ed+L68+mp8J74T3zcf/Gp8J74T3/c+r6/Gd+L73uf16j9ezfHqgZ7o6P8N73n7Vyd6o0//b3j7r766Wv/x6qdH/+95z6++OtD4LnwXvuug8V34Jr7Je5X4Jr7v9+BX45v4Jr7Je5X4bnw3vpv3auO78d28zxvfje/Gd/NeHXwPvgffw3t18D34Ht7nP17N59UXXf3OXN6ry/t8eZ8v79Xl93t5ny/v8+W9uvx+L+/zy6uv5r0qfAvfwrf4/Ra+hW/hW/37fffbX693v/2nJ7p93/32n070Rh9+/kXjOx40vgPfEWh8B74D33HQ+A58J75zoPGd+M6Fzn/vzLvf/tMHfdH9Xl149e63z3j1RAd6oXleePXut//0RfO88Ordb//pieZ5F8+7Eo0vvHr323+6/34vvLrw6t1v/+lA45v45kbjC6/e/fav3g8aX3j17rf/9ELju/HdB40vvHr32396oPGFV+9++08nGt+D77no6nfs5dVXD/REB3r1e/jHq5/e/b798eqnL7paF89bPC+8uvDq3W//PmPxvPDqwqt3v/37vNWcLHj17re/P//db//pQC90+7777T990BeN78AXXr377d+fP/CFVwWv3v32788f+MKrglfvfvvXa+ILr7797e/Pn/hOfOdG4zvxnfjGg8Y38I1Ar3/v2Lvf/tMbfdAX3Zx899t/ujn57rf/dKAXmueFVwWvCl4V81XBq4JXBa+K+argVcGrYr4qeFXwquBVMV8VvCp4VfCqmK8KXhW8KuarglcFrwpeFfNVwauCVwWvivmq4FXBq3e//ffz8b34Ml+9++3fn3/xvfgyX7377V+vi++96Obku9/+0wM90YFuTr777T/dnHz323/6ov9xcj79PTif5tV8mlfzaV7Np78H59O8mk/zaj7Nq/nut/8973yaV/NpXs1n4DvwHfg2r+Yz8B34DnybV/Pdb/96TXybV/OZ+E58J77Nq/lMfCe+E9/m1Xz3279egW/zaj6Bb+Ab+PZ8NZ/AN/ANfHu+ms/Cd+Hb89V899v/3rH57rf/9EYf9EX/4+R899t/+h8n57vf/tOBXmieN3ne5tV8mlfzSZ5387zNq/k0r+azed7m1XyaV/PZ+G58N77Nq/kcfA++B9/m1XwOvgff5tV899t/Px/fg+/l7/fie/G9+F7+fi++F9/m1Xz3238/H9/Ct/j7LXwL38K3+PstfAvfghv1j5Pz3W//6YGe6ED/4+R899t/+h8n57vf/tMX3ZwcfX41B7wa8GrAq9HnV3PAqwGvBrwafX41B7wa8GpMfOHVgFcDXo2JL7wa8GrAqzHxhVcDXr377d+fD68GvBrw6tvf/v58eDXg1YBX73771wteDXj17rd/f/7Cd+Hb89V899t/Px/fhW/PV/Pdb/96Jb49X813v/37jmWiN/qgL7o5+e63/3Rz8t1v/+lALzTPC68GvBrw6t1v/z4jvBrwasCrd7/9+7zwasCr7377+/Ph1YBXA169++3fnw+vBrwa8Ordb/96wasBr9799t/PxxdeDXj17W9/fz68GvBqwKt3v/3rBa8GvBqFb5+3z8l8NZmvZp+3z9nn7XMyX03mq9nn7XP2efuczFfvfvv7jr377T890BMd6Obku9/+083Jd7/9py/6zzf/9B+vfnqgJzrQC53ojT7oi8Y38A18A9/AN/ANfAPfwDfwDXwXvgvfhe/Cd+G78F34LnwXvgvfxDfxfeer/epAL3Si/3zfd/Ll1VdfdLV+efW+ky+vvnqiA/3xjfcd++PVT2/0xzfmqy+6Wv/xKt737Y9XPz3Rgf7zWq/e6IP+83r/3f4Y9dV/jPrpgZ7oQC90ojf6oPG9+Ba+hW/hW/j+MSre3+Mfo+LlwB+jfvrP9/3d/THqp+uffnfaf3qgJ/rju55XL/57ojf6oC//f/Ed+A58B74D34HvwHfgO/Ad+A58J74T34nvxHfiO/Gd+E58J74T38A38A18A9/AN/ANfAPfwDfwXfgufBe+C9+F78J34bvwXfgufBPfxDfxTXwT38Q38U18E9/Ed+O78d34bnw3vhvfje/Gd+O78T34HnwPvgffg+/B9+B78D34/vFq/f3f6Hen/acHeqIDvdCJ3uiDvmh8C9/Ct/AtfAvfwvePVytefdAX/ef7x713p/2nB/rPd7/6z/e+eqETvdEf35yvvuhq/cerjFcP9EQHeqET/fHN9eqDvuhq/cernx7oiQ70Qica34nvH6/yvLpa//Hqpwf647vHqwO90B/f/f67/fHqpz+++/13+OPVT3989/u/549XP/3x3e/v949X+/39/vHqp/983/9tf7z66Y0+6D/f9/f+x6uv/uPVTw/0RAd6oRO90QeNb+K78d34bnw3vhvfje/Gd+O78d34HnwPvgffg+/B9+B78D34Hnz/eHX+2PXutP/0QE90oBc60Rt90BeNb+Fb+Ba+hW/hW/gWvn+8Ou87/Mern65/+t1p/+k/3/XqiQ70Qv/55qs3+qD/fM+rq/Ufr376z/e+eqIDvdB/XvXqg/543efV1fqPUT890BMd6IVO9EYfNL4T38A38A18A9/A949Rd7z6z3e++qD/fN/f3R+jvvqPUT890BMd6D/f9/f1x6jff9/og8b3j1Hf/7+Jb+Kb+Ca+iW/im/gmvolv4rvx3fhufDe+G9+N78Z347vx3fgefA++B9+D78H34HvwPfgefA++F9+L78X34nvxvfhefC++F9+Lb+Fb+Ba+hW/hW/gWvoVv4Vvt++6xv//93WP/6YkO9OL/b/LfN/qgLxrfP0bd8+qB/vO9rw70Qif6z7defdAXXa3/eFXj1QM90YH++NZ6daI3+qAv+uNb7/P+8eqnB3qi/3z3qxc60Rt90Bddrf949dMDPdH4/vGq3t/FH69+eqMP+s/3/bf949VX//Hqpwf6f9/11/U6//bY/+mFTjS/3+T3m/x+k9/v5ve7+f1ufr+b3+8fr3460fx+N7/fze/3j1df/cern+b3e/j9/vHqpxea3+/h93v4/R5+v4ff7+X3e/n9Xn6/l9/v5b26+F5+v5ff7x+vfrpa//Gq3r/BP1799ERH/97/ePXTid7og779Dnx49dV/e+z/9EDPf+/Au8f+0wud6P3vd/3usf/0RVfr8aAHev77vb977D+90Ine6PPvHXj32H+6ufHusf90/37fPfafDvRCJ3qjD/qi+71699h/Gt+XV+fVgV7oRO9/78O7x/7TF93cePfYf3qgJzrQzY2/PfZ/eqMPurnx7rF/9TtfffVANzfePfafXuhE814l71U2N9499q/eD3qgea92c+PdY//pRG80v9/N73fz+z38fg+/38N7dXivDu8VvDrw6sCrd4/9+w6c5sa7x/7TA93cePfYf3qhmxvvHvtPH/QfN95/81ut648b8eqBnuhA/71X779//b1X779tbf7fHPRF1z99X16tV49/P+dvj/3f/5tAL3SiNz/n8HMu/2/wHQ96oGf/nBH9cwa+A9+x0Qd9+TnVP2fiO/GdPO/keWf/O//tsf/7OfhOfCfPO3ne4N85+HcOfAPf4HmD5w3+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73G8++0/zfPCK3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz0y8U18ma+S+SoT38SX+SqZr3Lju/FlvsruPY7s3uPI7j2O7N7jyL5nMLJ7j+Pb0/7Vzcns3uN499t/OtE8L7yipz3oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3raY5MPbvLBzXy1ma82+eAmH9zMV5v5apMPbvLBzXz17Wk/rx7oiQ70Qjcnvz3tX92cfPfbf7o5+e63/zTPC6/oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3rag572oKc96GkPetqDnvagpz3oaQ962oOe9qCnPehpD3rag572+Pa0vz9/48t8tZmvvj3t35+PL/PVZr5699u/Xgdf5qt3v/37jp2NPuiLbk5u8sFNPvjtaX/ftxvohU40zwuvNrza8Ordb/8+I7za8GrDq3e//fu88GrDq3e//ffz8YVXB169Pe3vzz/w6sCrA6/e/fbX68CrA6/e/fbfz8cXXh149e63f38+vDrw6sCrd7/96wWvDrx699u/P599hsN8dZiv3v32789nn+EwXx3mq3e//evFPsNhvnr329937N1v/+mJDvRCNyff/fafbk5+e9q/ujn57Wn/ap4XXh14deDV29P+fUZ4deDVgVfvfvv3eeHVgVfvfvv358OrA68OvHr3278/H14deHXg1bvf/vWCVwdevfvt358Prw68OvDq3W///Xx84dWBV+9++9cLXh149e63f3/+wZf56jBfvfvtv5+PL/PVYb5699u/Xhdf5qt3v/37jt2NPuiLbk6+Pe3f97AGujn57Wn/6oVONM8Lrw68OvDqss9w4dWFVxdevT3t7/NeeHXh1WWf4cKrC68uvLrsM1x4deHVhVdvT/vXC15deHXZZ7jw6sKrC68u+wwXXl14deHV29P+9YJXF169Pe3fnx/4Ml9d5qu3p/378wNf5qvLfPX2tH+9Al/mq7en/X3H3p72n57oQC90c/Ltaf/p5uS3p/2rm5Pf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f//7RAd6oRO90Qd90dV6P2h8N74b343vxnfju/Hd+L68mn/65dVXD/RENycDXgW8CngV3SdzAl4FvAp4Fd0ncwJeBbyiv/3ExZf5Kpiv6G8/cfFlvgrmqyh8C1/mK/rbT8CrgFcBr+hvPwteLXi14NXq/auz4NWCV6vP2893v/2rL7r/fhe8WsxXi+/BBa8WvFrMV4vvwQWvFvPV4ntwwSv22w/77Yf99rPgFfvth/32w377WfCK/fbDfvtZ8Ir99sN++2G//Sx4xX77Yb/9sN9+Frxiv/2w334W8xX77Yf99sN++1nMV+y3H/bbD/vtZzFfsd9+2G8/q/v6zuq+vrO6r++s5L3i/Ir+9kN/+6G//bDffuhvP/S3H/rbz9q8z50PHvrbz9r4bnwPvoff78H34HvwPfx+D74H38N7xfnVuvhefC+/X86v1sX34nv5/V58L76X94rzK/rbD/3th/72szi/or/90N9+6G8/q/DtfPDQ336y88GTnQ+e7HzwZOeDJzsfPAmvsvPBk50Pnux88GTng4f99sN++6G//dDffthvP+y3H/rbD/3th/32k5Pn7XzwsN9+2G8/9Lcf+tsP++2H/fZDf/uhv/2w336S83b620/CK/bbD/vth/32k/CK/fbDfvthv/0kvGK//bDffhJesd9+2G8/7LefhFfstx/22w/77SfhFfvth/32k50Pnux88GTngyc7HzzZ+eDJzgdPdj54svPBk50Pnux88GTngyf5HmS//bDffthvP8n3IPvth/32w377Sc6v2G8/7Lef5HswOW+nv/3Q336S78HkvJ3+9kN/+0nO25PzdvrbT3J+lZxfJbxKeJWcXyXnVwmvEl4l51fJeXvCq+R7cHN+tTlv3+SDm+/BzfnV5rx9kw9uzq825+2bfHCTD27ywU0+uMkHN/ngJh/c5IObfHCTD27ywU0+uJmvNryiv/3Q334289WGV/S3H/rbz2a+2vCK/vazma82vKK//dDffjbz1YZX9Lcf+tvPZr7a8Ir+9rOZrza8or/90N9+NvPVhlf0tx/6289mvtrwiv72szm/2pxfbc7bN/PV5vxqc361OW/fzFeb86vNefsmH9zkg5t8cJMPbvLBTT64yQc3+eAmH9zkg5t8cJMPbr4HN7za8GrDq8334IZXG15teLU5v9rwasOrzffghlcbXm14tfke3PBqw6sNrzbn7RtebXi1+R7c8OrAqwOvDt+DB14deHXg1eH86sCrA6/obz/0t5/DfHWYr+hvP/S3n8N8dZiv6G8/h+/Bw3x1yAcP+eAhHzzkg4d88JAPHvLBQz54yAcP+eAhH6S//dDffg68OvCK/vZDf/s58OrAK/rbz4FXB17R337obz8HXh14RX/7ob/9HHh14BX97efAqwOvDuftB14deHXg1eG8/cCrA68OvDqctx94deAV/e3ncN5+mK8O8xX97edw3n6Yrw7z1eG8/XDefpivDvngIR885IOHfPCQDx7ywUM+eMgHD/ngIR885IP0t58Drw68OvCK/vZz4NWBVwdeHc6vDrw68Ir+9nPg1YFXF17R334uvLrw6sKry/nVhVcXXl3O2y+8uvDqwqvLefuFVxdeXXh1OW+/8OrCK/rbz+X86jJfXeYr+tvP5fzqMl9d5qvLefvl/OoyX13ywUs+eMkHL/ngJR+85IOXfPCSD17ywUs+eMkH6W8/F15deHXhFf3t58KrC68uvLrkgxdeXXhFf/u58OrCqwuv6G8/F15deHXh1SUfvPDqwqtLPnjh1YVXF15d8sELry68uvDqkg9eeHXhFf3t53LefpmvLvMV/e3nct5+ma8u89XlvP1y3n6Zry754CUfvOSDl3zwkg9e8sFLPnjJBy/54CUfvOSD9LefC68uvLrwiv72U/Cq4FXBq+K8veBVwSv620/Bq4JXBa/obz8FrwpeFbwq8sGCVwWvinyw4FXBq4JXRT5Y8KrgVcGrIh8seFXwiv72U+SDxXxVzFf0t58iHyzmq2K+KvLBIh8s5qsiHyzywSIfLPLBIh8s8sEiHyzywSIfLPLBd7/9p3leeFXwquAV/e2n4FXBq4JXlTwvvCp4RX/7KXhV8KrgFf3tp+BVwauCV3XwhVcFr4p8sOBVwauCV0U+WPCq4FXBqyIfLHhV8Ir+9lPkg8V8VcxX9LefIh8s5qtivirywSIfLOar7377+47VRh/0Rf/j5P3ut99XD/Q/Tt53v/2nFzrR/573Ps2r+zSv7tO8uvS336d5dZ/m1X2aV/fpfob7NK/u07y69LffZ+A78G1eXfrb7zPxnfg2r+4z8Z34Nq/uM/Gd+Aa+zav7BL6Bb+DbvLpP4Bv4Nq8u/e33WfgufHu+uvS332fhu/Dt+eo+C9+Fb89X97vf/r5jfZ/Xffo+r/t0Pnifzgfv0/ngfTofvE/f53Wfvs/rPn2f1336Pq9Lf/t9Ns/bvLpP8+rS336fzfM2r+7TvLrP5nmbV/dpXl362+9z8D34Nq8u/e33OfgefJtX97n4XnybV/e5+F58L76Xv9+L78X34lv8/Ra+hW/z6tLffp/Ct/At/n4L395nuKPnqzt6vrqj+2Tu6H2GO3q+uqPv87qj7/O6o+/zuqPv87qj7/O6o+/zuqPv87qj7/O6o+/zuqPv87qj7/O69LffAa8GvBrwiv72O+DVgFcDXo3J88KrAa/ob78DXg14NeAV/e13wKsBrwa8GoEvvBrwagS+8GrAqwGvxsIXXg14NeDVWPjCqwGv6G+/I/FNfHu+uvS335H4Jr49X92R+Ca+PV/d0fd53dH3ed3R93nd0fd53dH3ed3R93nd0fd53dH3ed3R93nd0fd53dH3eV362++AVwNeDXhFf/sd8GrAqwGvxuF54dWAV/S33wGvBrwa8Ir+9jvg1YBXA16NwhdeDXg1Cl94NeDVgFej8IVXA15NeDW7T+ZOeDXhFf3td3afzJ3MV5P5iv72Ox98ma8m89Uc+A58ma9m3+d1Z9/ndWff53Vn3+d1Z9/ndWff53Vn3+d1Z9/ndWff53Vn3+d13/32vx3I+91v//73g77oah0PeqAnOtALnWh8A9/AN/Bd+C58F74L35dX89WJ3uiDbk5OeDXh1YRXs/tk7oRXE15NeDW7T+ZOeDXhFf3td258ma8m8xX97XdufJmvJvPV3PhufJmv6G+/E15NeDXhFf3td8KrCa8mvJoHX3g14dW8vM8vr7460Pz9wqvJfDUvf7/wasKryXw1i79feDWZr2bx9wuv2G+/7Ldf9tvvhFfst1/22y/77TfgVTBfRZ9f/a/bl/32y377Zb/9Brxiv/2y337Zb78Br9hvv+y332C+Yr/9st9+2W+/wXzFfvtlv/2y336D+Yr99st++43u67vRfX03uq/vRvf1XfbbL/3tl/72S3/7Zb/90t9+6W+/9Lff6Hzw0t9+6W+/sfBd+C58F7/fhe/Cd+Gb/H4T38Q3ea8S38Q38U1+v4lv4rvx3fx+N74b3817tfHd+G58N+/Vxvfge/A9vFcH34Pv4b3qfPBG54M3Du/V4b26vFfwKjofvNH54I3OB290PnjZb7/st1/62y/97Zf99st++6W//dLfftlvv1E8b/F3BK/Yb7/0t1/62y/77Zf99kt/+6W//bLffleft1/62++CV+y3X/bbL/vtd8Er9tsv++2X/fa74BX77Zf99rvgFfvtl/32y377XfCK/fbLfvtlv/0ueMV++2W//a7OB+/qfPCuzgfv6nzwrs4H7+p88K7OB+/qfPCuzgfv6nzwrs4H7+J7kP32y377Zb/9Lr4H2W+/7Ldf9tvv4vyK/fbLfvtdfA+uxBde0d9+F9+DK/GFV/S337Xx3fjCq8X51eL8asGrBa8W51eL86sFrxa8WpxfrYMvvFp8Dy7Or9bBt/PBu/geXJxfrYvv5e+X86t18e188K7OB+/qfPCuzgfv6nzwrs4H7+p88K7OB+/qfPCuzgfv6nzwrs4H72K+WvCK/vZLf/tN5quEV/S3X/rbbzJfJbyiv/0m81XCK/rbL/3tN5mvEl7R337pb7/JfJXwiv72m8xXCa/ob7/0t99kvkp4RX/7pb/9JvNVwiv6229yfpWcXyXn7cl8lZxfJedXyXl7Ml8l51fJeXt2Pniz88GbnQ/e7HzwZueDNzsfvNn54M3OB292Pniz88GbnQ/e7HzwJt+DCa8SXiW8Sr4HE14lvEp4lZxfJbxKeJV8Dya8SniV8Cr5Hkx4lfAq4VVy3p7wKuFV8j2Y8CrhVcKr5Hsw4VXCq4RXyflVwquEV/S3X/rbbzJfJfMV/e2X/vabzFfJfEV/+02+B5P5KjsfvNn54M3OB292PniTfHCTD27ywU0+uMkHN/ngJh+kv/3S3343vNrwiv72S3/73fBqwyv62++GVxte0d9+6W+/G15teEV/+6W//W54teEV/e13w6sNrzbn7RtebXi14dXmvH3Dqw2vNrzanLdveLXhFf3td3PevpmvNvMV/e13c96+ma8289XmvH1z3r6Zrzb54CYf3OSDm3xwkw9u8sFNPrjJBzf54CYf3OSD9LffDa82vNrwiv72u+HVhlcbXm3Orza82vCK/va74dWGVxte0d9+N7za8GrDq8351YZXG15tzts3vNrwasOrzXn7hlcbXm14tTlv3/Bqwyv62+/m/GozX23mK/rb7+b86jBfHearw3n74fzqMF8d8sFDPnjIBw/54CEfPOSDh3zwkA8e8sFDPnjIB+lvvwdeHXh14BX97ffAqwOvDrw65IMHXh14RX/7PfDqwKsDr+hvvwdeHXh14NUhHzzw6sCrQz544NWBVwdeHfLBA68OvDrw6pAPHnh14BX97fdw3n6Yrw7zFf3t93DefpivDvPV4bz9cN5+mK8O+eAhHzzkg4d88JAPHvLBQz54yAcP+eAhHzzkg/S33wOvDrw68Ir+9nvg1YFXB14dztsPvDrwiv72e+DVgVcHXtHffg+8OvDqwKtDPnjg1YFXh3zwwKsDrw68OuSDB14deHXh1SUfvPDqwiv62+8lH7zMV5f5iv72e8kHL/PVZb665IOXfPAyX13ywUs+eMkHL/ngJR+85IOXfPCSD17ywUs++O63/zTPC68uvLrwiv72e+HVhVcXXt3geeHVhVf0t98Lry68uvCK/vZ74dWFVxde3YUvvLrw6pIPXnh14dWFV5d88MKrC68uvLrkgxdeXXhFf/u95IOX+eoyX9Hffi/54GW+usxXl3zwkg9e5qvvfvv7jp2BnuhAL3Rz8rvf/tXNyXe//aebk+9++0/zvPDqwqsLr+hvvxdeXXh14dW9PC+8uvCK/vZ74dWFVxde0d9+L7y68OrCq+p+hlvwquBV9X0Tt+BVwauCV9X3TdyCVwWvCl7VwBdeFbyiv/3WwJf5qpiv6G+/NfBlvirmq5r4TnyZr7777efVG33QF92cLPLBIh+svs/rVt/ndavv87rV93ld+ttvwauCVwWv6G+/Ba8KXhW8qsXzwquCV/S334JXBa8KXtHffgteFbwqeFWJL7wqeFWJL7wqeFXwqja+8KrgVcGr2vjCq4JX9LffYp+hmK+K+Yr+9lvsMxTzVTFf1cGXfYZivqq+z+tW3+d1q+/zutX3ed3q+7xu9X1et/o+r1t9n9etvs/rVt/ndavv87r0t9+CVwWvCl7R334LXhW8KnhV3SdTT/OqnuZV0d9eT/OqnuZVPc2ror+9nuZVPc2reppX9Qx8B77Nq3oGvgPfgW/zqp6B78B34Nu8qmfiO/FtXhX97fVMfCe+PV8V/e31THwD356v6gl8A9+er+rp+7zq6fu86un7vOrp+7zq6fu86un7vOrp+7zq6fu86un7vOrp+7zq6fu8iv72ehbP27yqp3lV9LfXkzxv86qe5lU9yfM2r+ppXhX97fUkvolv86rob69n47vxbV7Vs/Hd+Dav6tn4bnwPvs2reg6+B9+Db/OqnoPvwbd5VfS313Pxvfhe/n4vvhffi+/l7/fie/G9cKPv86qn7/Oqp+/zqqfv86qn7/Oqp+/zqqfv86qn7/Oqp+/zqqfv86p3v/1vB7K+++3f/z7RgV7oRG/0QV90tR4PGt+B78B34DvwHfgOfAe+L6/mn3559dUDPdHNyQGvBrwa8Gp0n0wNeDXg1YBXo/tkasCrAa/ob68R+Aa+PV8V/e01At+Fb89XNRa+C9+er4r+9hrwasCrAa/ob68Brwa8GvBqJL7wasCr0eft9d1v/+qL7r/fAa9Gz1c1+nuwBrwa8Gr0fFWjvwdrwKvR81WN/h6sAa/Yby/224v99hrwiv32Yr+92G+vAa/Yby/222vAK/bbi/32Yr+9Brxiv73Yby/222vAK/bbi/32GoVv4Vv4Fu9V4Vv4Fr79PViT+Yr99mK/vWb39dXsvr6a3ddXs/v6iv32or+96G8v+tuL/faiv73oby/622t2Plj0txf97TUHvgPfiW/vM9Sc+E58J769z1Bz4jvx7X2GmhPfwDfw7X2GmoFv4Bv49j5DzcA38O19hpoL34Xvwrf3r2oufBe+C9/ev6q58F34Ju9V54M1Ox+smbxXyXuVvFfwanY+WLPzwZqdD9bsfLDYby/224v+9qK/vdhvL/bbi/72or+92G+veXjew98RvGK/vehvL/rbi/32Yr+96G8v+tuL/faaF9/L3y+8Yr+92G8v9ttrwiv224v99mK/vSa8Yr+92G+vCa/Yby/224v99prwiv32Yr+92G+vgFfst/+vF7q/U6LzwYrOBys6H6zofLCi88GKzgcrOh+s6HywovPBis4HK/geZL+92G8v9tsr+B5kv73Yby/22ysmz9v5YLHfXsH3YEx84RX97RV8D0bgC6/ob68IfANfeBWBb+ALrwJexcJ34QuvAl7FwnfhC6+C78FIfBPfzgcr+B6MxDfx7XywIvFNfDsfrOh8sKLzwYrOBys6H6zofLCi88GKzgcrOh+s6HywovPBis4HK5ivAl7R3170t1cwXwW8or+96G+vYL4KeEV/ewXzVcAr+tuL/vYK5quAV/S3F/3tFcxXAa/ob69gvgp4RX970d9ewXwV8Ir+9qK/vRbz1YJX9LfX4vxqcX61+ry9FvPV4vxqcX61Br7MV4vzqzXw7XywVueDtTofrNX5YK3OB2t1Plir88FanQ/W6nywVueDtTofrNX5YC2+Bxe8WvBqwavF9+CCVwteLXi1OL9a8GrBq8X34IJXC14teLX4HlzwasGrBa/WwhdeLXi1+B5c8GrBqwWvFt+DC14teLXg1eL8asGrBa/oby/622sxXy3mK/rbi/72WsxXi/mK/vZafA8u5qvV+WCtzgdrdT5Yq/PBWp0P1up8sFbng7U6H6zV+WCtzgdrdT5Y9LcX/e214NWCV/S3F/3tteDVglf0t9eCVwte0d9e9LfXglcLXtHfXvS314JXC17R314JrxJeJeftCa8SXiW8Ss7bE14lvEp4lZy3J7xKeEV/eyXn7cl8lcxX9LdXct6ezFfJfJWctyfn7cl8lZ0PVnY+WNn5YGXng5WdD1Z2PljZ+WBl54OVnQ9Wdj5Y2flg0d9eCa8SXiW8or+9El4lvEp4lZxfJbxKeEV/eyW8SniV8Ir+9kp4lfAq4VVyfpXwKuFVct6e8CrhVcKr5Lw94VXCq4RXyXl7wquEV/S3V3J+lcxXyXxFf3sl51fJfJXMV8l5e3J+lcxX2flgZeeDlZ0PVnY+WNn5YGXng5WdD1Z2PljZ+WBl54OVnQ8W/e2V8CrhVcIr+tsr4VXCq4RXST644dWGV/S314ZXG15teEV/e214teHVhlebfHDDqw2vNvnghlcbXm14tckHN7za8GrDq00+uOHVhlf0t9fmvH0zX23mK/rba3PevpmvNvPV5rx9c96+ma82+eAmH9zkg5t8cJMPbvLBTT64yQc3+eAmH9zkg/S314ZXG15teEV/e214teHVhleb8/YNrza8or+9Nrza8GrDK/rba8OrDa82vNrkgxtebXi1yQc3vNrwasOrTT644dWGVxtebfLBDa82vKK/vTb54Ga+2sxX9LfXJh/czFeb+WqTD27ywc18tckHN/ngJh/c5IObfHCTD27ywU0+uMkHN/ngu9/+0/28B14deHXgFf3tdeDVgVcHXp2+b6IOvDrwiv72OvDqwKsDr+hvrwOvDrw68OpMfOHVgVeHfPDAqwOvDrw65IMHXh14deDVIR888OrAK/rb65APHuarw3xFf3sd8sHDfHWYrw754CEfPMxX3/328+qNPuiLbk5+99vvqwe6Ofnut//0Qiea54VXB14deEV/ex14deDVgVdn87zw6sAr+tvrwKsDrw68or+9Drw68OrAq3PwhVcHXp2DL7w68OrAq3PxhVcHXh14dS6+8OrAK/rb6xS+zFeH+Yr+9jqFL/PVYb46hW/hy3z13W8/rx7oiQ70QjcnL/ng7fu86vZ9XnX7Pq+6fZ9X0d9eF15deHXhFf3tdeHVhVcXXt3B88KrC6/ob68Lry68uvCK/va68OrCqwuvbuALry68uoEvvLrw6sKrG/jCqwuvLry6C194deEV/e112We4zFeX+Yr+9rrsM1zmq8t8dRNf9hku89Xt+7zq9n1edfs+r7p9n1fdvs+rbt/nVbfv86rb93nV7fu86vZ9XnX7Pq+iv70uvLrw6sIr+tvrwqsLry68uofnhVcXXtHfXhdeXXh14RX97XXh1YVXF17diy+8uvDqXnzh1YVXF17dwhdeXXh14dUtfOHVhVf0t1d1n0wV81UxX9HfXtV9MlXMV8V8Vd0nU9X341QxX1Xf51XV93lV9X1eVX2fV1Xf51XV93lV9X1eVX2fV1Xf51XV93lV9X1eRX97FbwqeFXwiv72KnhV8KrgVU2eF14VvKK/vQpeFbwqeEV/exW8KnhV8KoWvvCq4FWxz1DwquBVwatin6HgVcGrgleV+MKrglf0t1clvsxXxXxFf3tV4st8VcxXtfHd+DJfVd/nVdX3eVX1fV5VfZ9XVd/nVdX3eVX1fV5VfZ9XVd/nVdX3edW73/7uQH7327///aAvuvcYv/vtXz3QEx3ohU40vhffi+/Ft/AtfAvfwvfl1Xx1ojf6oJuT9Y9X/59e/ePVRw/0j5MfHeiFTvSPkx990BeN78B34PtvvvpofAe+A99/89VH4zvw/Tdf/a8nvhPfie8/Xn00vhPfie8/Xn00vhPff7z66N/7/NETHejV/xv+8eqjN/qgb/9v+Mer//W/+eqjB3r2/55/89VHLzS+C9+F77/zq4/GN/FNfJP3KvFNfP+dX300volv4pu8Vxvfje/Gd/NebXw3vpv3eeO78d34Ht6rg+/B9+B7eK8Ovgffw/v8r6/vo6v1v76+j+a9urzPl/f58l5dfr+X9/nyPl/eq8vvt3if/+WDH817VfgWvoVv8fstfAvfat/ub//o9u3+9o8OdPuOJ9EbfdCXn4/vwHcMNL4D37HQ+A58B77jovGd+E5850TjO/Gdif7939+PPuiL7vdqRL9XA16Nf/ngRwd6oRPN88Kr7m//6P47GvBqwKvub//oQPO8i+ddG40vvOr+9v91Pmh84VX3t3/0QuOb+OZB4wuver/9owcaX3jV++0fnWh8N777ovGFV73f/tETjS+86v32j95ofA++p//v4PiXD370QE90oBf6953y0Rv9+0756Iuu1v/ywY/meYvnhVcDXo3ieYvnhVcDXo3q5+399o8e6PadT6AXOtHtO5+Dvujmxhz4Dnzh1Rz4Dnzh1YRXc+A78IVXE17Nie/EF17Nie/Ed+I7DxrfiW/gGwONb+AbC/37TvnojT7oi25OztWcnGugm5NzBXqhE83zwqsJrya8msxXE15NeDXh1WS+mvBqwqvJfDXh1YRXE15N5qsJrya8mvBqMl9NeDXh1WS+mvBqwqsJrybz1YRXE15NeDWZrya8mvBqHnwvvhdf5qt58b34XnyZr+bF9+J74UY1J2cN9EQHeqGbk7M2ujk566Kbk/E86H7egFcBrwJeBd+DAa8CXgW8iqefN+BVwKvgezDgVcCrgFfB92DAq4BXAa9i4guvAl4F34MBrwJeBbwKvgcDXgW8CngVgS+8CngVfA8G34PBfBXMV8H3YPA9GMxXwXwVfA8G34PBfBWrORlrow/6opuTkc3JyIFuTkYGeqETzfPCq4BXAa+C78GAVwGvAl4F34MBrwJeBd+DAa8CXgW8Cr4HA14FvAp4FXwPBrwKeBUHX3gV8CrgVVx84VXAq4BXcfGFVwGvur/9f134Ml8F81X3t380vsxXwXwVhW/hy3y1nubkegZ6ogO90M3J9Wx0c3I9F92cXONB9/MueLXg1YJXi/OrBa8WvFrwanF+teDVgleL86sFrxa8WvBqcX614NWCVwteLc6vFrxa8GoFvvBqwasFr1bgC68WvFrwai184dWCV93f/tH4Ml8t5qvub/9ofJmvFvPVSnw5v1rMVyubkys3+qAvujm5dnNy7YFuTq4d6IVONM8Lrxa8WvCq+9s/mueFVwtercPzwqsFr7q//aPxhVcLXnV/+0fjC68WvFoXX3i14NW6+MKrBa8WvFqFL7xa8GrBq1X4wqsFrxbn7cl5ezJfJfNVct6enLcn81UyXyXn7cl5ezJf5WhO5hjoiQ70Qjcnc2x0czLHRTcncz5onhdeJbxKeJWctye8SniV8Co5b094lfCq+9s/Gl94lfCq+9s/Gl94lfAqF77wKuFVLnzhVcKrhFe58IVXCa8SXmXiC68SXnV/+0fjy3yVzFfd3/7R+DJfJfNVbnw3vsxXuZuTuTf6oC+6OZmnOZlnoJuTeQK90InmeeFVwquEV93f/tE8L7xKeJWX54VXCa+6v/2j8YVXCa+6v/2j8YVXCa+y8IVXCa+y8IVXG15teLXJBze82vBqw6tNPrjh1YZXm3xwkw9u5qvNfLXJBzf54Ga+2sxXm3xwkw9u5qvvfvt59UBPdKAXujn53W//6ubku9/+083Jd7/9p3leeLXh1YZX3d/+0TwvvNrwagfPC682vOr+9o/GF15teNX97R+NL7za8GonvvBqw6ud+MKrDa82vNqJL7za8GrDq73xhVcbXnV/+0fjy3y1ma+6v/2j8WW+2sxX++B78GW++u63v+/Y2eiDvujm5CYf3OSD+zYn9w30Qiea54VXG15teNX97R/N88KrDa928bzwasOr7m//aHzh1YFX3d/+0RMd6IVu3wOvDrw6z+Xn4wuvDrw6A194deDVgVdn4AuvDrzq/vb/NfsMh/nqMF91f/tH48t8dZivzsSXfYbDfHWiOXlioCc60AvdnDyx0c3JExfdnDzrQfO88OrAqwOvur/9o3leeHXg1Vk8L7w68Kr72z8aX3h14FX3t380vvDqwKuz8YVXB16djS+8OvDqwKuz8YVXB14deHUOvvDqwKvub/9ofJmvDvNV97d/NL7MV4f56lx8L77MV+c2J8/d6IO+6ObkqebkqYFuTp4K9EInmueFVwdeHXh12We48OrCqwuv7tPPe+HVhVeXfYYLry68uvDqss9w4dWFVxde3YEvvLrw6rLPcOHVhVcXXl32GS68uvDqwqs78YVXF151f/v/OvBlvrrMV93f/tH4Ml9d5qsb+Aa+zFd3NSfvGuiJDvRCNyfv2ujm5F0X3Zx899s/O5Af/dsn/OiJDvRCJ3qjD/qiq/V+0PhufDe+G9+N78Z347vxfXk1//TLq68e6IluTl54deHVhVf3NCcvvLrw6sKre5uTF15deHXZv7rsX13mq8t8ddm/uuxfXeary3x12b+6hS/z1WX/6sKrC68uvLrsXxW8KnhV8KrYvyp4VfCqOG//7rd/9UX332/Bq2K+Kr4HC14VvCrmq+J7sOBVMV8V34MFrwpeFfNVcX5V8KrgVTFfFedXBa+K+ao4vyp4VfCq+B4svgcLXhW8Kr4Hi+/BglfF92DxPVjMV8V8VcxXxfdgMV8V81UxXxXfg8V8VcxXxfdgZXOycqGbk5W8V5xfFflgkQ8W+wzF+VWRDxb5YLHPUOSDRT5Y7DMU5+3FeXuRDxb7DMV5e3HeXuSDxT5Dcd5e5IPFPkNxflWctxf5YLHPUJxfFeftRT5Y7DMU5+1FPljsMxTnV8V5e5EPFvtXxflVcd5e5IPF/lVx3t797f+fIvX+1Xg6HxxP54Pj6XxwPJ0PjqfzwfE0r8bT+eB4Oh8cT+eD4+l8cLDfPthvH93f/tEL/e95B/vto/vbP/qied7J83Y+ONhvH+y3j+5v/+hE4zvxnfh2PjjYbx9P4Nv54HgC38A38O18cDyBb+Ab+HY+OJ6F78K388HxLHwXvgvfzgfHs/Bd+Ca+nQ+OJ/FNfDsfHE/ng+PpfHA8nQ+Op/PB8XQ+OJ7OB8fT+eB4Oh8cT+eD4+l8cDydD45n87yb521eDfbbx3N43sPzNq8G++3jOTxv54OD/fbxHHwPvgff5tV4Lr4X34tv82o8F9+Lb/NqPBffi2/hW/z9Fr6Fb+Fb/P0WvoVv82o8/T04Rp9fjdHn7WN0PjhGfw+O0edXY/R5+xidD47R51dj9Hn7GJ0PjtH54BidD47R+eAYnQ+O0fngGJ0PjtH54BidD47R+eAYnQ+O0fngGJPnhVcDXg14NSbPC68GvBrwakyeF14NeDUCX3g14NWAVyPwhVcDXg14NRa+8GrAq7HwhVcDXg14NRa+8GrAqwGvRuILrwa8Golv4pv49nw1RuKb+G58e74aY+O78e18cIzOB8fofHCMzgfH6HxwjM4Hx+h8cIzOB8fofHCMzgfH6HxwjM4Hxzg8L7wa8GrAq3F5Xng14NWAV+PyvPBqwKtx8YVXA14NeDUKX3g14NWAV6PwhVcDXo3CF15NeDXh1ezvwTHh1YRXE17NPr8aE15NeNX97f/rgS/z1WS+6v72j8aX+WoyX3V/+0fjy3w1Ox8cs/PBMTsfHLPzwTE7Hxyz88ExOx8cs/PBMTsfHLPzwTE7Hxzd3/7RPC+8mvCq+9s/mueFVxNedX/7/xpeTXjV/e0fjS+8mvCq+9s/Gl94NeFV97d/NL7waia+8GrCqwmvZuILrya8mvBqbnzh1YRX3d/+0fgyX03mq+5v/2h8ma8m89U8+B58ma9m54Njdj44ZueDY3Y+OGbng2N2Pjhm54Njdj44ZueDY3Y+OGbng6P72z+a54VXE151f/tH87zwasKrWTwvvJrwqvvbPxpfeBXwqvvbP3qiA73Q7RvwKuBV9Hn7CHgV8CrgVQx84VXAq4BXMfCFVwGvur/9fz3xZb4K5qvub/9ofJmvgvkqJr4TX+ar6HxwROeDIzofHNH54IjOB0d0Pjii88ERnQ+O6HxwROeDIzofHN3f/tE8L7wKeNX97R/N88KrgFexeF54FfCq+9s/Gl94FfCq+9s/Gl94FfAqNr7wKuBVbHzhVcCrgFex8YVXAa8CXsXBF14FvOr+9o/Gl/kqmK+6v/2j8WW+CuaruPhefJmvovPBEZ0Pjuh8cETngyM6HxzR+eCIzgdHdD44ovPBEZ0Pjuh8cHR/+0fzvPAq4FX3t3/0QE90oPt5F7xa8Kr72z/6ovGFV93f/tH4wqsFr9bAF14teLUGvvBqwasFr9bEF14teLXg1Zr4wqsFr7q//X8d+DJfLear7m//aHyZrxbz1Qp8A1/mq9X54FidD47V+eBYnQ+O1fngWJ0PjtX54FidD47V+eBYnQ+Od7/9p3leeLXg1YJX3d/+0TwvvFrwaiXPC68WvOr+9o/GF14teNX97R+NL7xa8GodfOHVglfr4AuvFrxa8GodfOHVglcLXq2LL7xa8Kr72z8aX+arxXzV/e0fjS/z1WK+WoVv4ct89d1vf9+x2uiDvujm5He//b56oJuT7377Ty90ovt5E14lvEp41f3tHz3QEx3oft6EVwmvur/9o/GFVwmvur/9o/GFVwmvcuILrxJe5cQXXiW8SniVgS+8SniV8CoDX3iV8Kr72//XC1/mq2S+6v72j8aX+SqZr3Lhu/Blvvrut7/vWA70RAd6oZuT2fngyGxOZl50czL3g+Z54VXCq4RX3d/+0TwvvEp4lZvnhVcJr7q//aPxhVcJr7q//aPxhVcJr/LiC68SXuXFF14lvEp4lRdfeJXwKuFVFr7wKuFV97d/NL7MV8l81f3tH92+m/lqM1/t7pMZu/cZxma+2k9zcj8bfdAX3Zzcozm5x0A3J/cI9EInup93w6sNrza86v72j+Z54dWGV3vyvPBqw6vub/9ofOHVhlfd3/7R+MKrDa924AuvNrzagS+82vBqw6u98IVXG15teLUXvvBqw6vub/9fJ77MV5v5qvvbPxpf5qvNfLUT38SX+Wrv5uTeAz3RgV7o5uTeG92c3Puim5P7PGieF15teLXhVfe3fzTPC682vNqH54VXG151f/tH4wuvNrzq/vaPxhdebXi1C194teHVLnzh1YZXG17twhdebXh14NXpPplx4NWBV93f/tGJ3uiDvvx8fJmvDvPVGfgOfJmvzmhOnrHRB33Rzckzm5NnDnRz8sxAL/QfJ8er/+0Tju9++1dfdLWOBz3QEx3ohU40voFv4Bv4LnwXvgvfhe/Lq/nqRG/0QTcnD7w68OrAq9N9MuPAqwOvDrw63SczDrw68Kr72//XG1/mq8N81f3tH40v89Vhvjob340v81X3t380vvDqwKvub/9ofOHVgVfn4AuvDrw6nLd/99u/OtD8/cKrw3x1+B488OrAq8N8dfgePPDqMF8dvgcPvGK/fbDfPthvHwdesd8+2G8f7LePC6/Ybx/st48Lr9hvH+y3D/bbx4VX7LcP9tsH++3jwiv22wf77eMyX7HfPthvH+y3j8t8xX77YL99sN8+LvMV++2D/fZxu69v3O7rG7f7+sbtvr7Bfvu45IOXfPCyz8B++7jkg5d88LLPcMkHL/ngZZ/hct5+OW+/5IOXfYbLefvlvP2SD172GS7n7Zd88LLPcDm/upy3X/LByz7D5fzqct5+yQcv+wyX8/ZLPnjZZ7icX13O2y/54GX/6nJ+dTlvv+SDl/2ry3n7JR+87F9d8sFLPnjJBy/54CUfvPDqkg9e8sFLPnjJB9lvH+y3j0s+eMkH2W8f7LePSz54yQfZbx+XfPCSD7LfPthvH5fz9iIfZL99sN8+ivP2Ih9kv30U5+1FPljwiv32wX77YL99FLxiv32w3z7Ybx8Fr9hvH+y3j4JX7LcP9tsH++2j4BX77YP99sF++yh4xX77YL99FPlgkQ8W+WCRDxb5YJEPFvlgkQ8W+WCRDxb5YPE9yH77YL99sN8+iu9B9tsH++2D/fZRnF+x3z7Ybx/F92Bx3l7wquBV8T1YnLcXvCp4VZy3F+ftBa+K86vi/KrgVcGr4vyqOL8qeFXwqji/Ks7bC14V34PF+VVx3l7kg8X3YHF+VZy3F/lgcX5VnLcX+WCRDxb5YJEPFvlgkQ8W+WCRDxb5YJEPFvlgkQ8W81XBq4JX9LfPp+er+TSvJv3tk/72+fR8NZ/m1aS/fT49X82neTXpb5/0t89n4DvwHfg2r+Yz8B34Nq/mM/Ad+E58m1fzmfhOfCe+zav5THwnvs2r+Ux8A9/At+er+QS+gW/g2/PVfALfwLfzwfl0Pjifzgfn0/ngfDofnE/ng/PpfHA+nQ/Op/PB+XQ+OJ/OB+fT+eB8kudNnrd5NZ/m1XyS502et3k1n+bVfJLnbV7Np3k1n43vxnfj27yaz8Z347vxbV7N5+B78G1ezefge/A9+Dav5nPwPfgefC9/vxffi2/zatLfPulvn8/F9/L3e/G9+Ba+xd9v4Vv4FtzofHA+nQ/Op/PB+XQ+OJ/OB+fofHCOzgfn6Hxwjs4H5+h8cI7OByf97ZP+9jng1YBX9LdP+tvngFcDXtHfPge8GvCK/vZJf/sc8GrAK/rbJ/3tc8CrAa/ob58DXg14NSa+8GrAqwGvRuALrwa8GvBqBL7wasAr+tvnWPgufHu+mvS3z7HwXfj2fDXHwnfh2/PVHJ0PztH54BydD87R+eAcnQ/O0fngHJ0PztH54BydD87R+eAcnQ9O+tvngFcDXg14RX/7HPBqwKsBr8bmeeHVgFf0t88Brwa8GvCK/vY54NWAVwNejYsvvBrwalx84dWAVwNejYsvvBrwasCrUfjCqwGv6G+fo/AtfIu/38K3z6/mZL6azFezz9vn7POrOZmvZueDc3Y+OGfng3N2Pjhn54Nzdj44Z+eDc3Y+OGfng3N2Pjhn54OT/vY54dWEVxNe0d8+J7ya8GrCqzl5Xng14RX97XPCqwmvJryiv31OeDXh1YRXM/CFVxNezcAXXk14NeHVXPjCqwmvJryaC194NeEV/e1zJr7MV5P5iv72ORNf5qvJfDUT38SX+Wp2Pjhn54Nzdj44Z+eDc3Y+OGfng3N2Pjhn54Nzdj44Z+eDc3Y+OOlvnxNeTXg14RX97XPCqwmvJryah+eFVxNe0d8+J7ya8GrCK/rb54RXE15NeDULX3g14dUsfOHVhFcTXs3CF15NeBXwKjofnAGvAl5F54P/60Rv9EFffj6+zFfBfBUD34Ev81V0Pjij88EZnQ/O6HxwRueDMzofnNH54IzOB2d0Pjij88H57rf/NM8LrwJeBbyiv30GvAp4FfAqgueFVwGv6G+fAa8CXgW8or99BrwKeBXwKha+8CrgVSx84VXAq4BXkfjCq4BXAa8i8YVXAa/ob5+x8WW+CuYr+ttnbHyZr4L5Kja+G1/mq+9++/uOnYGe6EAvdHPyu9/+1c3Jd7/9p5uT7377T/O88CrgVcAr+ttnwKuAVwGv4vK88CrgFf3tM+BVwKuAV/S3z4BXAa8CXq3uZ5gLXi14tfq+ibng1YJXC16tvm9iLni14NWCV2vgC68WvKK/fa6BL/PVYr6iv32ugS/z1WK+WhPfiS/z1Xe//bx6ow/6opuTq/PBuTofnKvv85qr7/Oaq+/zmqvv85r0t88Frxa8WvCK/va54NWCVwtercXzwqsFr+hvnwteLXi14BX97XPBqwWvFrxaiS+8WvBqJb7wasGrBa/WxhdeLXi14NXa+MKrBa/ob5/r4Mt8tZiv6G+f6+DLfLWYr9bB9+DLfLX6Pq+5+j6vufo+r7n6Pq+5+j6vufo+r7n6Pq+5+j6vufo+r7n6Pq+5+j6vSX/7XPBqwasFr+hvnwteLXi14NXqPpmZ8CrhFf3tM+FVwquEV/S3z4RXCa8SXuXAF14lvMqBL7xKeJXwKge+8CrhVcKrnPjCq4RX9LfPnPgyXyXzFf3tMye+zFfJfJWBb+DLfJV9n9fMvs9rZt/nNbPv85rZ93nN7Pu8ZvZ9XjP7Pq+ZfZ/XzL7Pa2bf5zXpb58JrxJeJbyiv30mvEp4lfAqk+eFVwmv6G+fCa8SXiW8or99JrxKeJXwKje+8CrhVW584VXCq4RXefCFVwmvEl7lwRdeJbyiv33mxZf5Kpmv6G+fefFlvkrmq7z4XnyZr7Lv85rZ93nN7Pu8ZvZ9XjP7Pq+ZfZ/XzL7Pa2bf5zWz7/Oa2fd5zXe//W8Hcn7327//faIDvdCJ3uiDvuhqPR40vgPfge/Ad+A78B34DnxfXs0//fLqqwd6opuTG15teLXh1e4+mbnh1YZXG17t7pOZG15teEV/+9yBL/PVZr6iv33uwJf5ajNf7YXvwpf5iv72ueHVhlcbXtHfPje82vBqw6ud+MKrDa825+3f/favvuj++93wajNfbb4HN7za8GozX22+Bze82sxXm+/BDa/Yb5/st0/22+eGV+y3T/bbJ/vtc8Mr9tsn++1zwyv22yf77ZP99rnhFfvtk/32yX773PCK/fbJfvvczFfst0/22yf77XMzX7HfPtlvn+y3z8N8xX77ZL99nu7rm6f7+ubpvr55uq9vst8+6W+f9LdP+tsn++2T/vZJf/ukv30e8kH62yf97fNw3k5/+6S/fdLfPg/n7fS3T/rbJ/3t83DeTn/7pL99Hs6vDufth3zwsM9wOL86nLcf8sHDPsPhvP2QDx72GQ7nV/S3T/rbJ/3t83B+RX/7pL990t8+D+ft9LdP+tvnIR885IOHfPCQDx7ywQOvDvngIR885IOHfJD99sl++6S/fdLfPtlvn+y3T/rbJ/3tk/32ecgH6W+f7LdP9tsn/e2T/vbJfvtkv33S3z7pb5/st8/DeTv97fPAK/bbJ/vtk/32eeAV++2T/fbJfvs88Ir99sl++zzwiv32yX77ZL99HnjFfvtkv32y3z4vvGK/fbLfPi/54CUfvOSDl3zwkg9e8sFLPnjJBy/54CUfvOSDl+9B9tsn++2T/fZ5+R5kv32y3z7Zb5+X8yv22yf77fPyPXg5b6e/fdLfPi/fg5fzdvrbJ/3t83Lefjlvp799Xs6vLudXF15deHU5v7qcX114deHV5fzqct5+4dXle/ByfnU5b7/kg5fvwcv51eW8/ZIPXs6vLuftl3zwkg9e8sFLPnjJBy/54CUfvOSDl3zwkg9e8sFLPniZry68or990t8+L/PVhVf0t0/62+dlvrrwiv72eZmvLryiv33S3z4v89WFV/S3T/rb52W+uvCK/vZ5ma8uvKK/fdLfPi/z1YVX9LdP+ttnMV8VvKK/fRbnV8X5VXHeXsxXxflVcX5VnLcX81VxflWctxf5YJEPFvlgkQ8W+WCRDxb5YJEPFvlgkQ8W+WCRDxbfgwWvCl4VvCq+BwteFbwqeFWcXxW8KnhVfA8WvCp4VfCq+B4seFXwquBVcd5e8KrgVfE9WPCq4FXBq+J7sOBVwauCV8X5VcGrglf0t0/622cxXxXzFf3tk/72WcxXxXxFf/ssvgeL+arIB4t8sMgHi3ywyAeLfLDIB4t8sMgHi3ywyAfpb5/0t8+CVwWv6G+f9LfPglcFr+hvnwWvCl7R3z7pb58Frwpe0d8+6W+fBa+qeRX0t8fTvIqneRVPn7fH07yKp3kVT/Mqnj5vj6d5Fc+Db/MqnoHvwLd5FfS3xzPwHfj2fBX0t8cz8J349nwVz8R34tvzVTydD8bT+WA8nQ/G0/lgPJ0PxtP5YDydD8bT+WA8nQ/G0/lgPJ0PBv3t8QTP27yKp3kV9LfHs3je5lU8zat4Fs/bvIqneRX0t8ez8F34Nq+C/vZ4Et/Et3kVT+Kb+Dav4kl8E9+Nb/Mqno3vxnfj27yKZ+O78W1eBf3t8Rx8D749XwX97fEcfA++PV/Fc/A9+PZ8FU/ng/F0PhhP54PxdD4YT+eD8XQ+GE/ng/F0PhhP54PxdD4YT+eDQX97PMXzFtwo/n6L5y2et+BG8ffb+WAMeDXgFf3tMeDVgFcDXtHfHgNeDXg14NUY+MKrAa/GwBdeDXg14NUY+MKrAa8GvBoTX3g14BX97TEmvhPfnq+C/vYYE9/At+erGIFv4NvzVYzOB2N0Phij88EYnQ/G6HwwRueDMTofjNH5YIzOB2N0Phij88Ggvz0GvBrwasAr+ttjwKsBrwa8GsnzwqsBr+hvjwGvBrwa8Ir+9hjwasCrAa/GxhdeDXg1Nr7wasCrAa/GwRdeDXg14NU4+MKrAa/ob49x8b34Xv5+L74X34vv5e/34nvxvXCj88EYnQ/G6HwwRueDMTofjNH5YIzOB2N0Phij88EYnQ/Gu9/+0/28E15NeDXhFf3tMeHVhFcTXs2+byImvJrwiv72mPBqwqsJr+hvjwmvJrya8GpOfOHVhFdz4guvJrya8GpOfOHVhFcTXs3AF15NeEV/e8zAl/lqMl/R3x4z8GW+msxXc+G78GW++u63n1dv9EFfdHPyu99+Xz3Qzcl3v/2nFzrRPC+8mvBqwiv622PCqwmvJryam+eFVxNe0d8eE15NeDXhFf3tMeHVhFcTXs2DL7ya8GoefOHVhFcTXs2LL7ya8GrCq3nxhVcTXtHfHrPwZb6azFf0t8csfJmvJvPVLHwLX+ar7377efVAT3SgF7o5GZ0PRvR9XhF9n1dE3+cV0fd5Bf3tEfAq4FXAK/rbI+BVwKuAVzF4XngV8Ir+9gh4FfAq4BX97RHwKuBVwKsIfOFVwKsIfOFVwKuAVxH4wquAVwGvYuELrwJe0d8esfBlvgrmK/rbIxa+zFfBfBWJb+LLfBV9n1dE3+cV0fd5RfR9XhF9n1dE3+cV0fd5RfR9XhF9n1dE3+cV0fd5Bf3tEfAq4FXAK/rbI+BVwKuAV3F4XngV8Ir+9gh4FfAq4BX97RHwKuBVwKu4+MKrgFdx8YVXAa8CXkXhC68CXgW8isIXXgW8or89VvfJxGK+WsxX9LfH6j6ZWMxXi/lqdZ9MrL4fJxbz1er7vGL1fV6x+j6vWH2fV6y+zytW3+cVq+/zitX3ecXq+7xi9X1esfo+r6C/PRa8WvBqwSv622PBqwWvFrxak+eFVwte0d8eC14teLXgFf3tseDVglcLXq2FL7xa8GotfOHVglcLXq2FL7xa8GrBq5X4wqsFr+hvj5X4Ml8t5iv622MlvsxXi/lqbXw3vsxXq+/zitX3ecXq+7xi9X1esfo+r1h9n1esvs8rVt/nFavv84rV93nFu9/+twMZ3/32738/6Iuu1vdBD/REB3qhE43vxffie/EtfAvfwrfwfXk1X53ojT7o5uSCVwmvEl5l98lEwquEVwmvsvtkIuFVwiv62yMHvsxXyXxFf3vkwJf5KpmvcuA78GW+or89El4lvEp4RX97JLxKeJXwKie+8CrhVXLe/t1v/+pA999vwqtkvkq+BxNeJbxK5qvkezDhVTJfJd+DCa/Ybw/224P99kh4xX57sN8e7LdHwiv224P99kh4xX57sN8e7LdHwiv224P99mC/PRJesd8e7LdHMl+x3x7stwf77ZHMV+y3B/vtwX57JPMV++3Bfntk9/VFdl9fZPf1RV7eK86v6G8P+tuD/vZgvz3obw/624P+9sjife58MOhvj+S8nf72oL896G+P5Lyd/vagvz3ob4/NeTv97UF/e2zOrzbn7Zt8cPc+Q2zOrzbn7Zt8cPc+Q2zO2zf54O59hticX9HfHvS3B/3tsTm/or896G8P+ttjc95Of3vQ3x6bfHCTD27ywU0+uMkHN7za5IObfHCTD27yQfbbg/32oL896G8P9tuD/fagvz3obw/222OTD9LfHuy3B/vtQX970N8e7LcH++1Bf3vQ3x7st8fmvJ3+9tjwiv32YL892G+PDa/Ybw/224P99tjwiv32YL89Nrxivz3Ybw/222PDK/bbg/32YL89Nrxivz3Yb49NPrjJBzf54CYf3OSDm3xwkw9u8sFNPrjJBzf54OZ7kP32YL892G+Pzfcg++3Bfnuw3x6b8yv224P99jh8Dx7O2+lvD/rb4/A9eDhvp7896G+Pw3n74byd/vY4nF8dzq8OvDrw6nB+dTi/OvDqwKvD+dXhvP3Aq8P34OH86nDefsgHD9+Dh/Orw3n7IR88nF8dztsP+eAhHzzkg4d88JAPHvLBQz54yAcP+eAhHzzkg4d88DBfHXhFf3vQ3x6H+erAK/rbg/72OMxXB17R3x6H+erAK/rbg/72OMxXB17R3x70t8dhvjrwiv72OMxXB17R3x70t8dhvjrwiv72oL89DvPVgVf0t8fh/OpwfnU4bz/MV4fzq8P51eG8/TBfHc6vDufth3zwkA8e8sFDPnjIBw/54CEfPOSDh3zwkA8e8sFLPnj5Hrzw6sKrC68u34MXXl14deHV5fzqwqsLry7fgxdeXXh14dXle/DCqwuvLry6nLdfeHXh1eV78MKrC68uvLp8D154deHVhVeX86sLry68or896G+Py3x1ma/obw/62+MyX13mK/rb4/I9eJmvLvngJR+85IOXfPCSD17ywUs+eMkHL/ngJR+85IP0twf97XHh1YVX9LcH/e1x4dWFV/S3x4VXF17R3x70t8eFVxde0d8e9LfHhVcXXtHfHhdeXXh1OW+/8OrCqwuvLuftF15deHXh1eW8/cKrC6/ob4/LeftlvrrMV/S3x+W8/TJfXeary3n75bz9Ml8V+WCRDxb5YJEPFvlgkQ8W+WCRDxb5YJEPFvkg/e1R8KrgVcEr+tuj4FXBq4JXxflVwauCV/S3R8GrglcFr+hvj4JXBa8KXhXnVwWvCl4V5+0FrwpeFbwqztsLXhW8KnhVnLcXvCp4RX97FOdXxXxVzFf0t0dxflXMV8V8VZy3F+dXxXxV5INFPljkg0U+WOSDRT5Y5INFPljkg0U+WOSD9LdHwauCVwWv6G+PglcFrwpeFflgwauCV/S3R8GrglcFr+hvj4JXBa8KXhX5YMGrgldFPljwquBVwasiHyx4VfCq4FWRDxa8KnhFf/t6+rx9PT1frafnq0V/+3r6vH09PV+tp+er9fR5+3r6vH09PV+tp/PB9XQ+uJ7OB9fT+eB6Oh9cT+eD6+l8cD2dD66n88H1dD64ns4HF/3t65k8b/NqPc2rRX/7eibP27xaT/NqPZPnbV6tp3m16G9fT+Ab+DavFv3t6wl8A9/m1XoWvgvf5tV6Fr4L34Vv82o9C9+F78K3ebWexDfxbV4t+tvXk/gmvj1fLfrb15P4bnx7vlrPxnfj2/PVejofXE/ng+vpfHA9nQ+up/PB9XQ+uJ7OB9fT+eB6Oh9cT+eD691v/2me9/C8zav1HP5+L897ed7m1Xouf7+X521erad5tehvX8/F9+JbcKPwLXwL34IbhW/hW3Cj8IVXA14NeDU6H1wDXg14NeDV6HxwDXg14BX97WsMfAe+PV8t+tvXGPgOfHu+WmPgO/Dt+Wp999vPqwd6ogO90M3J7377Vzcn3/32n25OvvvtP83zwqsBrwa8or99DXg14NWAVyN4Xng14BX97WvAqwGvBryiv30NeDXg1YBXI/GFVwNejcQXXg14NeDVSHzh1YBXA16NjS+8GvCK/vY1Nr4b356vFv3ta2x8D749X61x8D349ny1vvvt7zvW93mt0fd5rdH54BqdD67R+eAanQ+u0fd5rdH3ea3R93mt0fd5Lfrb14BXA14NeEV/+xrwasCrAa9G8bzwasAr+tvXgFcDXk14RX/7mvBqwqsJr2bfj7MmvJrwanafzJrwasKrCa/mwBdeTXg14dUc+MKrCa/ob19z4st8NZmv6G9fc+LLfDWZr+bEd+LLfDX7Pq81+z6vNfs+rzX7Pq81+z6vNfs+rzX7Pq81+z6vNfs+rzX7Pq81+z6vRX/7mvBqwqsJr+hvXxNeTXg14dVcPC+8mvCK/vY14dWEVxNe0d++Jrya8GrCq7nxhVcTXs2NL7ya8GrCq7nxhVcTXk14NQ++8GrCK/rb1zz4Ml9N5iv629c8+DJfTearefG9+DJfzb7Pa82+z2vNvs9rzb7Pa82+z2vNvs9rzb7Pa82+z2vNvs9rzb7Pa82+z2vR374mvJrwasIr+ttXwKuAVwGvovtk/teJ3ujDz79ofOEV/e0r4FXAq4BXMfCFVwGvYuALrwJeBbyKiS+8CngV8ComvvAq4BX97SsCX+arYL6iv31F4Mt8FcxXEfgGvsxX0fd5rej7vFb0fV4r+j6vFX2f14q+z2tF3+e1ou/zWtH3ea3o+7zWu9/+twO5vvvt3/8+0YFe6ERv9EFfdLXeDxrfje/Gd+O78d34bnw3vi+v5p9+efXVAz3RzcmAVwGvAl5F98msgFcBrwJeRffJrIBXAa/ob19x8WW+CuYr+ttXXHyZr4L5Kgrfwpf5iv72FfAq4FXAK/rb14JXC14teLV6/2oteLXg1erz9vXdb//qi+6/3wWvFvPV4ntwwasFrxbz1eJ7cMGrxXy1+B5c8Ir99sV++2K/fS14xX77Yr99sd++Frxiv32x374WvGK/fbHfvthvXwtesd++2G9f7LevBa/Yb1/st6/FfMV++2K/fbHfvhbzFfvti/32xX77WsxX7Lcv9tvX6r6+tbqvb63u61srea84v6K/fdHfvuhvX+y3L/rbF/3ti/72tTbvc+eDi/72tTa+G9+D7+H3e/A9+B58D7/fg+/B9/BecX61Lr4X38vvl/OrdfG9+F5+vxffi+/lveL8iv72RX/7or99Lc6v6G9f9Lcv+tvXKnw7H1z0t6/sfHBl54MrOx9c2fngys4HV8Kr7HxwZeeDKzsfXNn54GK/fbHfvuhvX/S3L/bbF/vti/72RX/7Yr995eR5Ox9c7Lcv9tsX/e2L/vbFfvtiv33R377ob1/st6/kvJ3+9pXwiv32xX77Yr99Jbxiv32x377Yb18Jr9hvX+y3r4RX7Lcv9tsX++0r4RX77Yv99sV++0p4xX77Yr99ZeeDKzsfXNn54MrOB1d2Priy88GVnQ+u7HxwZeeDKzsfXNn54Eq+B9lvX+y3L/bbV/I9yH77Yr99sd++kvMr9tsX++0r+R5Mztvpb1/0t6/kezA5b6e/fdHfvpLz9uS8nf72lZxfJedXCa8SXiXnV8n5VcKrhFfJ+VVy3p7wKvke3Jxfbc7bN/ng5ntwc361OW/f5IOb86vNefsmH9zkg5t8cJMPbvLBTT64yQc3+eAmH9zkg5t8cJMPbuarDa/ob1/0t6/NfLXhFf3ti/72tZmvNryiv31t5qsNr+hvX/S3r818teEV/e2L/va1ma82vKK/fW3mqw2v6G9f9LevzXy14RX97Yv+9rWZrza8or99bc6vNudXm/P2zXy1Ob/anF9tzts389Xm/Gpz3r7JBzf54CYf3OSDm3xwkw9u8sFNPrjJBzf54CYf3OSDm+/BDa82vNrwavM9uOHVhlcbXm3Orza82vBq8z244dWGVxtebb4HN7za8GrDq815+4ZXG15tvgc3vDrw6sCrw/fggVcHXh14dTi/OvDqwCv62xf97eswXx3mK/rbF/3t6zBfHeYr+tvX4XvwMF8d8sFDPnjIBw/54CEfPOSDh3zwkA8e8sFDPnjIB+lvX/S3rwOvDryiv33R374OvDrwiv72deDVgVf0ty/629eBVwde0d++6G9fB14deEV/+zrw6sCrw3n7gVcHXh14dThvP/DqwKsDrw7n7QdeHXhFf/s6nLcf5qvDfEV/+zqctx/mq8N8dThvP5y3H+arQz54yAcP+eAhHzzkg4d88JAPHvLBQz54yAcP+SD97evAqwOvDryiv30deHXg1YFXh/OrA68OvKK/fR14deDVhVf0t68Lry68uvDqcn514dWFV5fz9guvLry68Opy3n7h1YVXF15dztsvvLrwiv72dTm/usxXl/mK/vZ1Ob+6zFeX+epy3n45v7rMV5d88JIPXvLBSz54yQcv+eAlH7zkg5d88JIPXvJB+tvXhVcXXl14RX/7uvDqwqsLry754IVXF17R374uvLrw6sIr+tvXhVcXXl14dckHL7y68OqSD154deHVhVeXfPDCqwuvLry65IMXXl14RX/7upy3X+ary3xFf/u6nLdf5qvLfHU5b7+ct1/mq0s+eMkHL/ngJR+85IOXfPCSD17ywUs+eMkHL/kg/e3rwqsLry68or99FbwqeFXwqjhvL3hV8Ir+9lXwquBVwSv621fBq4JXBa+KfLDgVcGrIh8seFXwquBVkQ8WvCp4VfCqyAcLXhW8or99FflgMV8V8xX97avIB4v5qpivinywyAeL+arIB4t8sMgHi3ywyAeLfLDIB4t8sMgHi3zw3W//aZ4XXhW8KnhFf/sqeFXwquBVJc8Lrwpe0d++Cl4VvCp4RX/7KnhV8KrgVR184VXBqyIfLHhV8KrgVZEPFrwqeFXwqsgHC14VvKK/fRX5YDFfFfMV/e2ryAeL+aqYr4p8sMgHi/nqu9/+vmO10Qd90f84md/99vvqgf7HyXz32396oRP973nzaV7l07zKp3mV9Lfn07zKp3mVT/Mqn+5nyKd5lU/zKulvz2fgO/BtXiX97flMfCe+zat8Jr4T3+ZVPhPfiW/g27zKJ/ANfAPf5lU+gW/g27xK+tvzWfgufHu+Svrb81n4Lnx7vspn4bvw7fkqv/vt7zvW93nl0/d55dP5YD6dD+bT+WA+nQ/m0/d55dP3eeXT93nl0/d5Jf3t+Wyet3mVT/Mq6W/PZ/O8zat8mlf5bJ63eZVP8yrpb8/n4HvwbV4l/e35HHwPvs2rfC6+F9/mVT4X34vvxffy93vxvfhefIu/38K38G1eJf3t+RS+hW/x91v49j5Djp6vcvR8laP7ZHL0PkOOnq9y9H1eOfo+rxx9n1eOvs8rR9/nlaPv88rR93nl6Pu8cvR9Xjn6Pq8cfZ9X0t+eA14NeDXgFf3tOeDVgFcDXo3J88KrAa/ob88Brwa8GvCK/vYc8GrAqwGvRuALrwa8GoEvvBrwasCrsfCFVwNeDXg1Fr7wasAr+ttzJL6Jb89XSX97jsQ38e35Kkfim/j2fJWj7/PK0fd55ej7vHL0fV45+j6vHH2fV46+zytH3+eVo+/zytH3eeXo+7yS/vYc8GrAqwGv6G/PAa8GvBrwahyeF14NeEV/ew54NeDVgFf0t+eAVwNeDXg1Cl94NeDVKHzh1YBXA16NwhdeDXg14dXsPpmc8GrCK/rbc3afTE7mq8l8RX97zgdf5qvJfDUHvgNf5qvZ93nl7Pu8cvZ9Xjn7Pq+cfZ9Xzr7PK2ff55Wz7/PK2fd55ez7vPLdb//bgczvfvv3vx/0RVfreNADPdGBXuhE4xv4Br6B78J34bvwXfi+vJqvTvRGH3RzcsKrCa8mvJrdJ5MTXk14NeHV7D6ZnPBqwiv623NufJmvJvMV/e05N77MV5P5am58N77MV/S354RXE15NeEV/e054NeHVhFfz4AuvJryal/f55dVXB5q/X3g1ma/m5e8XXk14NZmvZvH3C68m89Us/n7hFfvtyX57st+eE16x357styf77RnwKpivos+v/tfty357st+e7LdnwCv225P99mS/PQNesd+e7LdnMF+x357styf77RnMV+y3J/vtyX57BvMV++3JfntG9/VldF9fRvf1ZXRfX7LfnvS3J/3tSX97st+e9Lcn/e1Jf3tG54NJf3vS356x8F34LnwXv9+F78J34Zv8fhPfxDd5rxLfxDfxTX6/iW/iu/Hd/H43vhvfzXu18d34bnw379XG9+B78D28Vwffg+/hvep8MKPzwYzDe3V4ry7vFbyKzgczOh/M6Hwwo/PBZL892W9P+tuT/vZkvz3Zb0/625P+9mS/PaN43uLvCF6x3570tyf97cl+e7LfnvS3J/3tyX57rj5vT/rbc8Er9tuT/fZkvz0XvGK/PdlvT/bbc8Er9tuT/fZc8Ir99mS/PdlvzwWv2G9P9tuT/fZc8Ir99mS/PVfng7k6H8zV+WCuzgdzdT6Yq/PBXJ0P5up8MFfng7k6H8zV+WAuvgfZb0/225P99lx8D7Lfnuy3J/vtuTi/Yr892W/PxffgSnzhFf3tufgeXIkvvKK/PdfGd+MLrxbnV4vzqwWvFrxanF8tzq8WvFrwanF+tQ6+8GrxPbg4v1oH384Hc/E9uDi/Whffy98v51fr4tv5YK7OB3N1Ppir88FcnQ/m6nwwV+eDuTofzNX5YK7OB3N1Ppir88FczFcLXtHfnvS3ZzJfJbyivz3pb89kvkp4RX97JvNVwiv625P+9kzmq4RX9Lcn/e2ZzFcJr+hvz2S+SnhFf3vS357JfJXwiv72pL89k/kq4RX97ZmcXyXnV8l5ezJfJedXyflVct6ezFfJ+VVy3p6dD2Z2PpjZ+WBm54OZnQ9mdj6Y2flgZueDmZ0PZnY+mNn5YGbng5l8Dya8SniV8Cr5Hkx4lfAq4VVyfpXwKuFV8j2Y8CrhVcKr5Hsw4VXCq4RXyXl7wquEV8n3YMKrhFcJr5LvwYRXCa8SXiXnVwmvEl7R3570t2cyXyXzFf3tSX97JvNVMl/R357J92AyX2Xng5mdD2Z2PpjZ+WAm+eAmH9zkg5t8cJMPbvLBTT5If3vS357/9XUHO5Ik6XWF34XrXoSZuZn9V69CEARJUcIAAw4xIgUIwry7Kt3Cyz9tuGncqe6Mk5HhdcYz/MBj4auFr7h/++T+7XPhq4WvuH/7XPhq4Svu3z65f/tc+GrhK+7fPrl/+1z4auEr7t8+F75a+GrxfvvCVwtfLXy1eL994auFrxa+WrzfvvDVwlfcv30u3m9fnF8tzq+4f/tcvN++OL9anF8t3m9fvN++OL9aXB9cXB9cXB9cXB9cXB9cXB9cXB9cXB9cXB9cXB9cXB/k/u1z4auFrxa+4v7tc+Grha8Wvlq8f7Xw1cJX3L99Lny18NXCV9y/fS58tfDVwleL968Wvlr4avF++8JXC18tfLV4v33hq4WvFr5avN++8NXCV9y/fS7ev1qcXy3Or7h/+1y8f7U5v9qcX23eb9+8f7U5v9pcH9xcH9xcH9xcH9xcH9xcH9xcH9xcH9xcH9xcH9xcH+T+7XPjq42vNr7i/u1z46uNrza+2lwf3Phq4yvu3z43vtr4auMr7t8+N77a+Grjq831wY2vNr7aXB/c+Grjq42vNtcHN77a+Grjq831wY2vNr7i/u1z83775vxqc37F/dvn5v32zfnV5vxq83775v32zfnV5vrg5vrg5vrg5vrg5vrg5vrg5vrg5vrg5vrg5vrg5vog92+fG19tfLXxFfdvnxtfbXy18dXm/faNrza+4v7tc+Orja82vuL+7XPjq42vNr7aXB/c+Grjq831wY2vNr7a+GpzfXDjq42vCl8V1wcLXxW+4v7ts7g+WJxfFedX3L99FtcHi/Or4vyquD5YXB8szq+K64PF9cHi+mBxfbC4PlhcHyyuDxbXB4vrg8X1wdO3P5vni68KXxW+4v7ts/BV4avCVzV4vviq8BX3b5+FrwpfFb7i/u2z8FXhq8JXdcHFV4WviuuDha8KXxW+Kq4PFr4qfFX4qrg+WPiq8BX3b5/F9cHi/Ko4v+L+7bO4PlicXxXnV8X1weL6YHF+9e3bzzG2G7uzB/tiv5789u3f/Xry9O3Pfj15+vZn83zxVeGrwlfcv30Wvip8VfiqiueLrwpfcf/2Wfiq8FXhK+7fPgtfFb4qfJX3/gwz+Cr4Ku/nTczgq+Cr4Ku8nzcxg6+Cr4Kv0uDiq+Ar7t8+0+ByfhXOr7h/+0yDy/lVOL9Kh9vhcn717dv32Yu92cV+PRmuD4brg3k/z2vm/TyvmffzvGbez/Oa3L99Bl8FXwVfcf/2GXwVfBV8lYvni6+Cr7h/+wy+Cr4KvuL+7TP4Kvgq+CoTLr4KvsqEi6+Cr4KvsuDiq+Cr4KssuPgq+Ir7t8/QM4Tzq3B+xf3bZ+gZwvlVOL/KhkvPEM6v8n6e18z7eV4z7+d5zbyf5zXzfp7XzPt5XjPv53nNvJ/nNfN+ntfM+3leM+/neU3u3z6Dr4Kvgq+4f/sMvgq+Cr7Kez+Z9Xl9tT6vrxb3b1+f11fr8/pqfV5fLe7fvj6vr9bn9dX6vL5anwa3wX19tT4NboPb4L6+Wp8Gt8FtcF9frU+H2+G+vlrcv319OtwO9z2/Wty/fX063AH3Pb9anwF3wH3Pr9bn/Tyv9Xk/z2t93s/zWp/387zW5/08r/V5P89rfd7P81qf9/O81uf9PK/1eT/Pa33ez/Na3L99fS6e7+ur9Xl9tbh/+/pMnu/rq/V5fbU+k+f7+mp9Xl8t7t++PhPuhPv6anH/9vVZcBfc11frs+AuuK+v1mfBXXA33NdX67Phbrgb7uur9dlwN9zXV4v7t69PwS24xd/fgltwC27x97fgFtzCG+/nea3P+3le6/N+ntf6vJ/ntT7v53mtz/t5Xuvzfp7X+ryf57U+7+d5rc/7eV7r9O13A7lO397G2Z092Bd7shd7s4udd5/7X3033Aa3wW1wG9wGt8FtcM/9ZO7X7vTtz27szr65dfbFnuzFvrk5u9h597k/w3ff3H12Zw823AF3wD09w3fDHXAvuLevng33gnt89d1wL7gX3HN98LvhTrgT7vk8r++GO+Gez/P67h9uP8fn7atnFzvv93Deb//uxu7s8X4P5/5X3z3Zi73f7+e8f/XdefeGu+FuuJvjasPdcDfczXG14W645/fB74ZbcAtucVwV3IJbcIvjquAGbjieAzdwAzccV4EbuIGb97g6ffthnb792Z39w+2fsy/2/H3MnL792e/xfPr2Z7/H1enbn/0ez6dvf/ZgX+z3eD59+7M3G26D2+H2xobb4Xa4fbLhdri92HAH3AF3dDbcAXfAHYsNd8Ad73H1vX/7efwL7gX3Gmy4F9wL7rXZcC+4k+Pq9tX3mLl99WyOq8lxNTmu8NXp2/s4u9h59+2rZ/N88dXp2599sXm++Or07c8uNs9383w3f4/wVcdXp29/9mTDxVenb382f3/x1enbn83fX3zV8dXp25+92HDx1enbvzsfNtzAzWDDxVenb3823sBXHV+dvv3Zjf1yT9/+7Is9fx9j4/jquze72Hn37atzHJ6+/dn99/F2+vZnX+zJfp/v6dufXezXG6dv/z7HzvPFVwNfnb79+3z7ZC823A4XXw18dfr27+MPuPhq4KvTt39ZAy6+On378/hw8dXAV6dv/z7+BRdfDXx1+vYv64KLr773bz+PP+FOuLOz4U64E+5cbLgT7ny9cfr27zG2GruzB/tiv548ffuzX0+evv3ZrydP3/5sni++Gvhq4KvB+dXAVwNfDXw1OL8a+Grgq8H51cBXA18NfDU4vxr4auCrga8G51cDXw18NTi/Gvhq4KuBrwbnVwNfDXx14auL86sLX1346vTt5/FP3/7sxd7s4vHhNricX52+/ctqcNvFfj15+vZnb3axX0+evv0ch6dvf/brydO3P/tiTzbPF19d+OrCVxe/D1746sJXF746ffv3+eKrC19d/D544asLX1346uL3wQtfXfjqwlenb/+y8NWFry5+H7zw1YWvLnx18fvgha8ufHXhq9O3f1n46sJXF78PXvw+eHF+dXF+dfH74MXvgxfnVxfnVxe/D178PnhxfnX69u8xthu7swf7Yr+ePH37s19Pnr792a8nT9/+bJ4vvrrw1YWvLn4fvPDVha8ufHXx++CFry58dfH74IWvLnx14auL3wcvfHXhqwtfTX4fnPhq4qvTt5/Hn/hq4quJ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VcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXwVcNXDV81fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fNXxVcdXHV91fDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfDXw1cBXA18NfEXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXf/mvDxVf07UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707UXfXvTtRd9e9O1F31707aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFv/7Xh4iv69tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtoW8PfXvo20PfHvr20LeHvj307aFvD3176NtD3x769tC3h7499O2hbw99e+jbQ98e+vbQt4e+PfTtefv2X78N/vbVz27szh7siz3Zi73ZxYbb4Da4DW6D2+A2uA1ug9vgNrgdbofb4Xa4HW6H2+F2uB1uhzvgDrgD7oA74A64A+6AO+AOuBfcC+7tq6ufPdg/3Gud/cO96uzF/uFeObvYP9zZ7n37as2zG/uHu/bZP9x1vvb21bMn+4e7z/d2++rZ9e7bUfs6+4dV393Zg32xJ3uxf1h1fg63o56dd9+OevbNPT+f21HPHuyLPdmLfXPP87od9ey8+3bUsxu7swf7Yk/2Yu/3e7gd9ey8+3bUs2/ueU1vRz17sC/2ZC823MDNyz1N+7Mbu7MH+2K/3NO0P3uzi51334569g83n7Pf4+o07c++2JO92D/ctLOL/cPN/Vqcpv3Zjd3Zg32xJ3ux7+e7zy523n076tmN3dmDfbEne7HhDri3o3J+trejnt3YnT3YF/t+vuvsxd7sYufdt6OefXPPMTPhTrgT7u2oZy/2ZsOdcBfc21fP7uzBvrk5G+6Cu+Devno23A13w91wN9zbV8/+xf11Qf7sxd7sYufdP776daH+7PazzzHw46vfe/zs8xx/fPXrwvjZP9w+/vbH3/3vf/rrn/7pn//8r//r7/7b//31P//Hf/7bv/zHn/7yb9//+R//59+ff/PPf/3Tn//8p//5j//+17/8y7/+9//867/+45//8i8//+7vPj//+Plb/fdt/dHbP/z6j9vPH/1i//3Vsv+4+mf/wx/nP7nGan/8+sf6+YN2/mD//EF+vq4/X9d/vfy/Huv8Zz9f1/u8/vj1jzxf1/uev/5g75+vG9/v4+9//e3PH7/+qv/8Zz+P88tg1x+/1HU9j/NLFe2PX//4zf/1FZ9ff1D953Gu53H6r/+z7jf951Hm54/1+f2d/HrEPt7v4xp/9Gv+fPV8vvvRfz3n57//9X/dc/386/X753R9/jhfsX8/3/xxHvL/+9f1Xz9gfj9gb7++2/sH//mvvuRvf/uHv/0/",
      "is_unconstrained": false,
      "name": "verify_attestation",
      "verification_key": "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"
    }
  ],
  "name": "AttVerifier",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {},
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "sender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "att_verifier_address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "business_logic_address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::SuccessEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "att_verifier_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "business_logic_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::_emit_success_event_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::_emit_success_event_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AttVerifier::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "public_key_x",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "public_key_y",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "signature",
                    "type": {
                      "kind": "array",
                      "length": 64,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "request_urls",
                    "type": {
                      "kind": "array",
                      "length": 2,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 1024,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "allowed_urls",
                    "type": {
                      "kind": "array",
                      "length": 3,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 1024,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "data_hashes",
                    "type": {
                      "kind": "array",
                      "length": 2,
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 8
                        }
                      }
                    }
                  },
                  {
                    "name": "plain_json_response_contents",
                    "type": {
                      "kind": "array",
                      "length": 2,
                      "type": {
                        "fields": [
                          {
                            "name": "storage",
                            "type": {
                              "kind": "array",
                              "length": 1000,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          },
                          {
                            "name": "len",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::collections::bounded_vec::BoundedVec"
                      }
                    }
                  },
                  {
                    "name": "business_logic_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AttVerifier::verify_attestation_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AttVerifier::verify_attestation_abi"
        }
      ]
    }
  },
  "transpiled": true
}
